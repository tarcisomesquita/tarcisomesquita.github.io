/*
      The ClientHello message includes a random structure, which is used
      later in the protocol.

         struct {
             uint32 gmt_unix_time;
             opaque random_bytes[28];
         } Random;

      gmt_unix_time
         The current time and date in standard UNIX 32-bit format
         (seconds since the midnight starting Jan 1, 1970, UTC, ignoring
         leap seconds) according to the sender's internal clock.  Clocks
         are not required to be set correctly by the basic TLS protocol;
         higher-level or application protocols may define additional
         requirements.  Note that, for historical reasons, the data
         element is named using GMT, the predecessor of the current
         worldwide time base, UTC.

      random_bytes
         28 bytes generated by a secure random number generator.

   The ClientHello message includes a variable-length session
   identifier.  If not empty, the value identifies a session between the
   same client and server whose security parameters the client wishes to
   reuse.  The session identifier MAY be from an earlier connection,
   this connection, or from another currently active connection.  The
   second option is useful if the client only wishes to update the
   random structures and derived values of a connection, and the third
   option makes it possible to establish several independent secure
   connections without repeating the full handshake protocol.  These
   independent connections may occur sequentially or simultaneously; a
   SessionID becomes valid when the handshake negotiating it completes
   with the exchange of Finished messages and persists until it is
   removed due to aging or because a fatal error was encountered on a
   connection associated with the session.  The actual contents of the
   SessionID are defined by the server.

      opaque SessionID<0..32>;

   Warning: Because the SessionID is transmitted without encryption or
   immediate MAC protection, servers MUST NOT place confidential
   information in session identifiers or let the contents of fake
   session identifiers cause any breach of security.  (Note that the
   content of the handshake as a whole, including the SessionID, is
   protected by the Finished messages exchanged at the end of the
   handshake.)

   The cipher suite list, passed from the client to the server in the
   ClientHello message, contains the combinations of cryptographic
   algorithms supported by the client in order of the client's
   preference (favorite choice first).  Each cipher suite defines a key
   exchange algorithm, a bulk encryption algorithm (including secret key
   length), a MAC algorithm, and a PRF.  The server will select a cipher
   suite or, if no acceptable choices are presented, return a handshake
   failure alert and close the connection.  If the list contains cipher
   suites the server does not recognize, support, or wish to use, the
   server MUST ignore those cipher suites, and process the remaining
   ones as usual.

      uint8 CipherSuite[2];    // Cryptographic suite selector

   The ClientHello includes a list of compression algorithms supported
   by the client, ordered according to the client's preference.

      enum { null(0), (255) } CompressionMethod;
      struct {
          ProtocolVersion client_version;
          Random random;
          SessionID session_id;
          CipherSuite cipher_suites<2..2^16-2>;
          CompressionMethod compression_methods<1..2^8-1>;
          select (extensions_present) {
              case false:
                  struct {};
              case true:
                  Extension extensions<0..2^16-1>;
          };
      } ClientHello;

   TLS allows extensions to follow the compression_methods field in an
   extensions block.  The presence of extensions can be detected by
   determining whether there are bytes following the compression_methods
   at the end of the ClientHello.  Note that this method of detecting
   optional data differs from the normal TLS method of having a
   variable-length field, but it is used for compatibility with TLS
   before extensions were defined.

   client_version
      The version of the TLS protocol by which the client wishes to
      communicate during this session.  This SHOULD be the latest
      (highest valued) version supported by the client.  For this
      version of the specification, the version will be 3.3 (see
      Appendix E for details about backward compatibility).

   random
      A client-generated random structure.

   session_id
      The ID of a session the client wishes to use for this connection.
      This field is empty if no session_id is available, or if the
      client wishes to generate new security parameters.

   cipher_suites
      This is a list of the cryptographic options supported by the
      client, with the client's first preference first.  If the
      session_id field is not empty (implying a session resumption
      request), this vector MUST include at least the cipher_suite from
      that session.  Values are defined in Appendix A.5.

   compression_methods
      This is a list of the compression methods supported by the client,
      sorted by client preference.  If the session_id field is not empty
      (implying a session resumption request), it MUST include the
      compression_method from that session.  This vector MUST contain,
      and all implementations MUST support, CompressionMethod.null.
      Thus, a client and server will always be able to agree on a
      compression method.

   extensions
      Clients MAY request extended functionality from servers by sending
      data in the extensions field.  The actual "Extension" format is
      defined in Section 7.4.1.4.

   After sending the ClientHello message, the client waits for a
   ServerHello message.  Any handshake message returned by the server,
   except for a HelloRequest, is treated as a fatal error.

        enum {
            hello_request(0), client_hello(1), server_hello(2),
            certificate(11), server_key_exchange (12),
            certificate_request(13), server_hello_done(14),
            certificate_verify(15), client_key_exchange(16),
            finished(20), (255)
        } HandshakeType;

        struct {
            HandshakeType msg_type;    // handshake type
            uint24 length;             // bytes in message
            select (HandshakeType) {
                case hello_request: HelloRequest;
                case client_hello: ClientHello;
                case server_hello: ServerHello;
                case certificate: Certificate;
                case server_key_exchange: ServerKeyExchange;
                case certificate_request: CertificateRequest;
                case server_hello_done: ServerHelloDone;
                case certificate_verify: CertificateVerify;
                case client_key_exchange: ClientKeyExchange;
                case finished: Finished;
            } body;
        } Handshake;
*/

struct ssl {
   unsigned char ContentType; 
   unsigned char VersionMajor;
   unsigned char VersionMinor;
   unsigned short int Length;
} *ssl_packet = 0;

void https_fim() {
   int falta;
   
   falta = pcap_packet_hdr.incl_len - (cache_pos - cache);
   printf("\n");
   hexdump_string(total, cache_pos, falta);
   
   total = total + falta;
   cache_pos = cache_pos + falta;
}

int aplicacao_https() {
   int falta;
   
   falta = pcap_packet_hdr.incl_len - (cache_pos - cache);
   if ((falta - sizeof(struct ssl)) < 0 ) {
      printf("\n");
      hexdump_string(total, cache_pos, falta);
      
      total = total + falta;
      cache_pos = cache_pos + falta;
      
      return 0;
   }
   
   ssl_packet = (struct ssl *)cache_pos;
   cache_pos = cache_pos + sizeof(struct ssl);
   total = total + sizeof(struct ssl);
   
   printf("\n\nContentType: 0x%02X   ", ssl_packet->ContentType);
   if (ssl_packet->ContentType == 0x16) printf("ChangeCipherSpec\n");
   else if (ssl_packet->ContentType == 0x17) printf("Alert\n");
   else if (ssl_packet->ContentType == 0x18) printf("Handshake\n");
   else if (ssl_packet->ContentType == 0x19) printf("Application\n");
   else { https_fim() ; return 0; }
   
   printf("Version: %02d.%02d   ", ssl_packet->VersionMajor, ssl_packet->VersionMinor);
   if (ssl_packet->VersionMajor == 3) {
      if (ssl_packet->VersionMinor == 0) printf("SSL 3.0\n");
      else if (ssl_packet->VersionMinor == 1) printf("TLS 1.0\n");
      else if (ssl_packet->VersionMinor == 2) printf("TLS 1.1\n");
      else if (ssl_packet->VersionMinor == 3) printf("TLS 1.2\n");
      else printf("Programar isso\n");
   }
   else { https_fim() ; return 0; }

   printf("Length: 0x%04X   %d\n", ssl_packet->Length, ssl_packet->Length);
   //RECORD-LENGTH = ((byte[0] & 0x3f) << 8)) | byte[1];
   
   if (ssl_packet->ContentType == 0x18) {
      falta = pcap_packet_hdr.incl_len - (cache_pos - cache);
      printf("\n");
      hexdump_string(total, cache_pos, falta);
      
      total = total + falta;
      cache_pos = cache_pos + falta;
      
      return 0;
   }
   else { https_fim() ; return 0; }
   return 1;
}

