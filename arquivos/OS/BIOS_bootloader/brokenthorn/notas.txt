Protected Mode:
    Has Memory Protection
    Has hardware support for Virtual Memory and Task State Switching (TSS)
    Hardware support for interruting programs and executing another
    4 Operating Modes: Ring 0, Ring 1, Ring 2, Ring 3


All I/O Ports are mapped to a given memory location. This allows us to use the IN and OUT instructions.

The System Bus connects the CPU to the Northbridge on a motherboard. 
The System Bus is a combination of the Data Bus, Address Bus, and Control Bus.

x86 Real Mode Memory Map:

    0x00000000 - 0x000003FF - Real Mode Interrupt Vector Table
    0x00000400 - 0x000004FF - BIOS Data Area
    0x00000500 - 0x00007BFF - Unused
    0x00007C00 - 0x00007DFF - Our Bootloader
    0x00007E00 - 0x0009FFFF - Unused
    0x000A0000 - 0x000BFFFF - Video RAM (VRAM) Memory
    0x000B0000 - 0x000B7777 - Monochrome Video Memory
    0x000B8000 - 0x000BFFFF - Color Video Memory
    0x000C0000 - 0x000C7FFF - Video ROM BIOS
    0x000C8000 - 0x000EFFFF - BIOS Shadow Area
    0x000F0000 - 0x000FFFFF - System BIOS

1024*1024 = 0x100000

INT 0x19
writing the value 0x1234 at 0x0040:0x0072, and jumping to 0xFFFF:0, we effectivly warm reboot the computer. (Simular to Windows ctrl+alt+del.)
can convert 0x0040:0x0072 to the absolute address 0x000000472, a byte within the BIOS data area. 

I/O Controllers watches the Address Bus. If the Address Bus currosponds to a number that is assigned to the device, that device takes the value from the data bus and acts upon it. 

ver io_ports.html

Port mapping and Port I/O are very important. It is our only way of cummunicating with hardware in protected mode. 

Keyboard Controller is in port addresses 0x60 through 0x6F
Port 0x60 is a control register, Port 0x64 is a status register
If bit 1 in the status register is set, data is inside the input buffer.
WaitLoop:    in     al, 64h    			 ; Get status register value
             and    al, 10b    			 ; Test bit 1 of status register
             jz     WaitLoop   			 ; If status register bit not set, no data is in buffer
             in     al, 60h    			 ; Its set--Get the byte from the buffer (Port 0x60), and store it

 In an IN instruction, the processor places the port address--like 0x64--into the Address Bus, and sets the I/O DEVICE line in the control bus, followed by the READ line. The device that has been assigned to 0x60 by the ROM BIOS-- In this case, the Status Register in the keyboard Controller, knows its a read operation because the READ line is set. So, it copies data from some location inside the keyboard registers onto the Data Bus, resets the READ and I/O DEVICE lines on the control bus, and sets the READY line. Now, the processor has the data from the Data Bus that was read.

An OUT instruction is simular. The processor copies the byte to be written into the Data Bus (Zero extending it to the Data Bus Width). Then, it sets the WRITE and I/O DEVICE lines on the control bus. It then copies the port address--lets say--0x60, into the Address Bus. Because the I/O DEVICE Line is set, it is a signal that tells all controllers to watch the address bus. If the number on the address bus currosponds with there assigned number, the device acts on that data. In our case--The Keyboard Controller. The Keyboard controller knows its a WRITE operation because the WRITE line is set in the control bus. So, it copies the value on the data bus into its Control Register--which was assigned port address 0x60. The Keyboard Controller the resets the WRITE and I/O DEVICE line, sets the READY line on the control bus, and the processor is back in control. 


The x86 family has the following registers: RAX (EAX(AX/AH/AL)), RBX (EBX(BX/BH/BL)), RCX (ECX(CX/CH/CL)), RDX (EDX(DX/DH/DL)), CS,SS,ES,DS,FS,GS, RSI (ESI (SI)), RDI (EDI (DI)), RBP (EBP (BP)). RSP (ESP (SP)), RIP (EIP (IP)), RFLAGS (EFLAGS (FLAGS)), DR0, DR1, DR2, DR3, DR4, DR5, DR6, DR7, TR1, TR2, TR3, TR4, TR5, TR6, TR7, CR0, CR1, CR2, CR3, CR4, CR8, ST, mm0, mm1, mm2, mm3, mm4, mm5, mm6, mm7, xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7, GDTR, LDTR, IDTR, MSR, and TR. All of these registers are stored in a special area of memory inside the processor called a Register File.


bits 12-13 of FLAGS register
The IO Privilege Level (IOPL) controls the current ring level required to use certain instructions. For example, the CLI, STI, IN and OUT instructions will only execute if the current Privilege Level is equal, or greater, then the IOPL. If not, a General Protection Fault (GPF) will be generated by the processor. 
 Most operating systems set the IOPF to 0 or 1. This means that only Kernel level software can use these instructions. This is a very good thing. After all, if an application issues a CLI, it can effectivly stop the Kernel from running.


mov	ax, cr0			; get value in CR0
		or	ax, 1			; set bit 0--enter protected mode
		mov	cr0, ax			; Bit 0 now set, we are in 32 bit mode!

Bit 31 (PG) : Enables Memory Paging.
    0 - Disable
    1 - Enabled and use CR3 register


CR3 Control Register
Used when the PG bit in CR0 is set. Last 20 bits Contains the Page Directory Base Register (PDBR)

CR8 Control Register
Provides Read and Write access to the Task Prority Register (TPR)




