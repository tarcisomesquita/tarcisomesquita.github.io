; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	c:\Documents and Settings\Michael\Desktop\bte_lighter\Demos\Demo11\SysCore\Kernel\mmngr_virtual.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?_cur_directory@@3PAUpdirectory@@A		; _cur_directory
PUBLIC	?_cur_pdbr@@3IA					; _cur_pdbr
_BSS	SEGMENT
?_cur_directory@@3PAUpdirectory@@A DD 01H DUP (?)	; _cur_directory
?_cur_pdbr@@3IA DD 01H DUP (?)				; _cur_pdbr
_BSS	ENDS
PUBLIC	?vmmngr_ptable_virt_to_index@@YAII@Z		; vmmngr_ptable_virt_to_index
; Function compile flags: /Ogtpy
; File c:\documents and settings\michael\desktop\bte_lighter\demos\demo11\syscore\kernel\mmngr_virtual.cpp
;	COMDAT ?vmmngr_ptable_virt_to_index@@YAII@Z
_TEXT	SEGMENT
_addr$ = 8						; size = 4
?vmmngr_ptable_virt_to_index@@YAII@Z PROC		; vmmngr_ptable_virt_to_index, COMDAT

; 64   : 
; 65   : 	//! return index only if address doesnt exceed page table address space size
; 66   : 	return (addr >= PTABLE_ADDR_SPACE_SIZE) ? 0 : addr/PAGE_SIZE;

	mov	eax, DWORD PTR _addr$[esp-4]
	cmp	eax, 4194304				; 00400000H
	jb	SHORT $LN3@vmmngr_pta
	xor	eax, eax

; 67   : }

	ret	0
$LN3@vmmngr_pta:

; 64   : 
; 65   : 	//! return index only if address doesnt exceed page table address space size
; 66   : 	return (addr >= PTABLE_ADDR_SPACE_SIZE) ? 0 : addr/PAGE_SIZE;

	shr	eax, 12					; 0000000cH

; 67   : }

	ret	0
?vmmngr_ptable_virt_to_index@@YAII@Z ENDP		; vmmngr_ptable_virt_to_index
_TEXT	ENDS
PUBLIC	?vmmngr_ptable_lookup_entry@@YAPAIPAUptable@@I@Z ; vmmngr_ptable_lookup_entry
; Function compile flags: /Ogtpy
;	COMDAT ?vmmngr_ptable_lookup_entry@@YAPAIPAUptable@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_addr$ = 12						; size = 4
?vmmngr_ptable_lookup_entry@@YAPAIPAUptable@@I@Z PROC	; vmmngr_ptable_lookup_entry, COMDAT

; 70   : 
; 71   : 	if (p)

	mov	ecx, DWORD PTR _p$[esp-4]
	test	ecx, ecx
	je	SHORT $LN1@vmmngr_pta@2

; 72   : 		return &p->m_entries[ vmmngr_ptable_virt_to_index (addr) ];

	mov	eax, DWORD PTR _addr$[esp-4]
	cmp	eax, 4194304				; 00400000H
	jb	SHORT $LN6@vmmngr_pta@2
	xor	eax, eax
	lea	eax, DWORD PTR [ecx+eax*4]

; 74   : }

	ret	0

; 72   : 		return &p->m_entries[ vmmngr_ptable_virt_to_index (addr) ];

$LN6@vmmngr_pta@2:
	shr	eax, 12					; 0000000cH
	lea	eax, DWORD PTR [ecx+eax*4]

; 74   : }

	ret	0
$LN1@vmmngr_pta@2:

; 73   : 	return 0;

	xor	eax, eax

; 74   : }

	ret	0
?vmmngr_ptable_lookup_entry@@YAPAIPAUptable@@I@Z ENDP	; vmmngr_ptable_lookup_entry
_TEXT	ENDS
PUBLIC	?vmmngr_ptable_clear@@YAXPAUptable@@@Z		; vmmngr_ptable_clear
EXTRN	?memset@@YAPAXPAXDI@Z:PROC			; memset
; Function compile flags: /Ogtpy
;	COMDAT ?vmmngr_ptable_clear@@YAXPAUptable@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?vmmngr_ptable_clear@@YAXPAUptable@@@Z PROC		; vmmngr_ptable_clear, COMDAT

; 77   : 
; 78   : 	if (p)

	mov	eax, DWORD PTR _p$[esp-4]
	test	eax, eax
	je	SHORT $LN1@vmmngr_pta@3

; 79   : 		memset ( p,0,sizeof (ptable) );

	push	4096					; 00001000H
	push	0
	push	eax
	call	?memset@@YAPAXPAXDI@Z			; memset
	add	esp, 12					; 0000000cH
$LN1@vmmngr_pta@3:

; 80   : }

	ret	0
?vmmngr_ptable_clear@@YAXPAUptable@@@Z ENDP		; vmmngr_ptable_clear
_TEXT	ENDS
PUBLIC	?vmmngr_pdirectory_clear@@YAXPAUpdirectory@@@Z	; vmmngr_pdirectory_clear
; Function compile flags: /Ogtpy
;	COMDAT ?vmmngr_pdirectory_clear@@YAXPAUpdirectory@@@Z
_TEXT	SEGMENT
_dir$ = 8						; size = 4
?vmmngr_pdirectory_clear@@YAXPAUpdirectory@@@Z PROC	; vmmngr_pdirectory_clear, COMDAT

; 83   : 
; 84   : 	if (dir)

	mov	eax, DWORD PTR _dir$[esp-4]
	test	eax, eax
	je	SHORT $LN1@vmmngr_pdi

; 85   : 		memset ( dir,0,sizeof (pdirectory) );

	push	4096					; 00001000H
	push	0
	push	eax
	call	?memset@@YAPAXPAXDI@Z			; memset
	add	esp, 12					; 0000000cH
$LN1@vmmngr_pdi:

; 86   : }

	ret	0
?vmmngr_pdirectory_clear@@YAXPAUpdirectory@@@Z ENDP	; vmmngr_pdirectory_clear
_TEXT	ENDS
PUBLIC	?vmmngr_pdirectory_virt_to_index@@YAII@Z	; vmmngr_pdirectory_virt_to_index
; Function compile flags: /Ogtpy
;	COMDAT ?vmmngr_pdirectory_virt_to_index@@YAII@Z
_TEXT	SEGMENT
_addr$ = 8						; size = 4
?vmmngr_pdirectory_virt_to_index@@YAII@Z PROC		; vmmngr_pdirectory_virt_to_index, COMDAT

; 89   : 
; 90   : 	//! return index only if address doesnt exceed 4gb (page directory address space size)
; 91   : 	return (addr >= DTABLE_ADDR_SPACE_SIZE) ? 0 : addr/PAGE_SIZE;

	mov	eax, DWORD PTR _addr$[esp-4]
	xor	ecx, ecx
	cmp	ecx, 1
	jl	SHORT $LN3@vmmngr_pdi@2
	jg	SHORT $LN5@vmmngr_pdi@2
	test	eax, eax
	jb	SHORT $LN3@vmmngr_pdi@2
$LN5@vmmngr_pdi@2:
	xor	eax, eax

; 92   : }

	ret	0
$LN3@vmmngr_pdi@2:

; 89   : 
; 90   : 	//! return index only if address doesnt exceed 4gb (page directory address space size)
; 91   : 	return (addr >= DTABLE_ADDR_SPACE_SIZE) ? 0 : addr/PAGE_SIZE;

	shr	eax, 12					; 0000000cH

; 92   : }

	ret	0
?vmmngr_pdirectory_virt_to_index@@YAII@Z ENDP		; vmmngr_pdirectory_virt_to_index
_TEXT	ENDS
PUBLIC	?vmmngr_pdirectory_lookup_entry@@YAPAIPAUpdirectory@@I@Z ; vmmngr_pdirectory_lookup_entry
; Function compile flags: /Ogtpy
;	COMDAT ?vmmngr_pdirectory_lookup_entry@@YAPAIPAUpdirectory@@I@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_addr$ = 12						; size = 4
?vmmngr_pdirectory_lookup_entry@@YAPAIPAUpdirectory@@I@Z PROC ; vmmngr_pdirectory_lookup_entry, COMDAT

; 95   : 
; 96   : 	if (p)

	mov	ecx, DWORD PTR _p$[esp-4]
	test	ecx, ecx
	je	SHORT $LN1@vmmngr_pdi@3

; 97   : 		return &p->m_entries[ vmmngr_ptable_virt_to_index (addr) ];

	mov	eax, DWORD PTR _addr$[esp-4]
	cmp	eax, 4194304				; 00400000H
	jb	SHORT $LN6@vmmngr_pdi@3
	xor	eax, eax
	lea	eax, DWORD PTR [ecx+eax*4]

; 99   : }

	ret	0

; 97   : 		return &p->m_entries[ vmmngr_ptable_virt_to_index (addr) ];

$LN6@vmmngr_pdi@3:
	shr	eax, 12					; 0000000cH
	lea	eax, DWORD PTR [ecx+eax*4]

; 99   : }

	ret	0
$LN1@vmmngr_pdi@3:

; 98   : 	return 0;

	xor	eax, eax

; 99   : }

	ret	0
?vmmngr_pdirectory_lookup_entry@@YAPAIPAUpdirectory@@I@Z ENDP ; vmmngr_pdirectory_lookup_entry
_TEXT	ENDS
PUBLIC	?vmmngr_switch_pdirectory@@YA_NPAUpdirectory@@@Z ; vmmngr_switch_pdirectory
EXTRN	?pmmngr_load_PDBR@@YAXI@Z:PROC			; pmmngr_load_PDBR
; Function compile flags: /Ogtpy
;	COMDAT ?vmmngr_switch_pdirectory@@YA_NPAUpdirectory@@@Z
_TEXT	SEGMENT
_dir$ = 8						; size = 4
?vmmngr_switch_pdirectory@@YA_NPAUpdirectory@@@Z PROC	; vmmngr_switch_pdirectory, COMDAT

; 102  : 
; 103  : 	if (!dir)

	mov	eax, DWORD PTR _dir$[esp-4]
	test	eax, eax
	jne	SHORT $LN1@vmmngr_swi

; 104  : 		return false;

	xor	al, al

; 109  : }

	ret	0
$LN1@vmmngr_swi:

; 105  : 
; 106  : 	_cur_directory = dir;

	mov	DWORD PTR ?_cur_directory@@3PAUpdirectory@@A, eax ; _cur_directory

; 107  : 	pmmngr_load_PDBR (_cur_pdbr);

	mov	eax, DWORD PTR ?_cur_pdbr@@3IA		; _cur_pdbr
	push	eax
	call	?pmmngr_load_PDBR@@YAXI@Z		; pmmngr_load_PDBR
	add	esp, 4

; 108  : 	return true;

	mov	al, 1

; 109  : }

	ret	0
?vmmngr_switch_pdirectory@@YA_NPAUpdirectory@@@Z ENDP	; vmmngr_switch_pdirectory
_TEXT	ENDS
PUBLIC	?vmmngr_flush_tlb_entry@@YAXI@Z			; vmmngr_flush_tlb_entry
; Function compile flags: /Ogtpy
;	COMDAT ?vmmngr_flush_tlb_entry@@YAXI@Z
_TEXT	SEGMENT
_addr$ = 8						; size = 4
?vmmngr_flush_tlb_entry@@YAXI@Z PROC			; vmmngr_flush_tlb_entry, COMDAT

; 112  : 
; 113  : #ifdef _MSC_VER
; 114  : 	_asm {
; 115  : 		cli

	cli

; 116  : 		invlpg	addr

	invlpg	DWORD PTR _addr$[esp-4]

; 117  : 		sti

	sti

; 118  : 	}
; 119  : #endif
; 120  : }

	ret	0
?vmmngr_flush_tlb_entry@@YAXI@Z ENDP			; vmmngr_flush_tlb_entry
_TEXT	ENDS
PUBLIC	?vmmngr_get_directory@@YAPAUpdirectory@@XZ	; vmmngr_get_directory
; Function compile flags: /Ogtpy
;	COMDAT ?vmmngr_get_directory@@YAPAUpdirectory@@XZ
_TEXT	SEGMENT
?vmmngr_get_directory@@YAPAUpdirectory@@XZ PROC		; vmmngr_get_directory, COMDAT

; 123  : 
; 124  : 	return _cur_directory;

	mov	eax, DWORD PTR ?_cur_directory@@3PAUpdirectory@@A ; _cur_directory

; 125  : }

	ret	0
?vmmngr_get_directory@@YAPAUpdirectory@@XZ ENDP		; vmmngr_get_directory
_TEXT	ENDS
PUBLIC	?vmmngr_alloc_page@@YA_NPAI@Z			; vmmngr_alloc_page
EXTRN	?pt_entry_add_attrib@@YAXPAII@Z:PROC		; pt_entry_add_attrib
EXTRN	?pt_entry_set_frame@@YAXPAII@Z:PROC		; pt_entry_set_frame
EXTRN	?pmmngr_alloc_block@@YAPAXXZ:PROC		; pmmngr_alloc_block
; Function compile flags: /Ogtpy
;	COMDAT ?vmmngr_alloc_page@@YA_NPAI@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
?vmmngr_alloc_page@@YA_NPAI@Z PROC			; vmmngr_alloc_page, COMDAT

; 128  : 
; 129  : 	//! allocate a free physical frame
; 130  : 	void* p = pmmngr_alloc_block ();

	call	?pmmngr_alloc_block@@YAPAXXZ		; pmmngr_alloc_block

; 131  : 	if (!p)

	test	eax, eax
	jne	SHORT $LN1@vmmngr_all

; 132  : 		return false;

	xor	al, al

; 139  : }

	ret	0
$LN1@vmmngr_all:
	push	esi

; 133  : 
; 134  : 	//! map it to the page
; 135  : 	pt_entry_set_frame (e, (physical_addr)p);

	mov	esi, DWORD PTR _e$[esp]
	push	eax
	push	esi
	call	?pt_entry_set_frame@@YAXPAII@Z		; pt_entry_set_frame

; 136  : 	pt_entry_add_attrib (e, I86_PTE_PRESENT);

	push	1
	push	esi
	call	?pt_entry_add_attrib@@YAXPAII@Z		; pt_entry_add_attrib
	add	esp, 16					; 00000010H

; 137  : 
; 138  : 	return true;

	mov	al, 1
	pop	esi

; 139  : }

	ret	0
?vmmngr_alloc_page@@YA_NPAI@Z ENDP			; vmmngr_alloc_page
_TEXT	ENDS
PUBLIC	?vmmngr_free_page@@YAXPAI@Z			; vmmngr_free_page
EXTRN	?pt_entry_del_attrib@@YAXPAII@Z:PROC		; pt_entry_del_attrib
EXTRN	?pmmngr_free_block@@YAXPAX@Z:PROC		; pmmngr_free_block
EXTRN	?pt_entry_pfn@@YAII@Z:PROC			; pt_entry_pfn
; Function compile flags: /Ogtpy
;	COMDAT ?vmmngr_free_page@@YAXPAI@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
?vmmngr_free_page@@YAXPAI@Z PROC			; vmmngr_free_page, COMDAT

; 141  : void vmmngr_free_page (pt_entry* e) {

	push	esi

; 142  : 
; 143  : 	void* p = (void*)pt_entry_pfn (*e);

	mov	esi, DWORD PTR _e$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	?pt_entry_pfn@@YAII@Z			; pt_entry_pfn
	add	esp, 4

; 144  : 	if (p)

	test	eax, eax
	je	SHORT $LN1@vmmngr_fre

; 145  : 		pmmngr_free_block (p);

	push	eax
	call	?pmmngr_free_block@@YAXPAX@Z		; pmmngr_free_block
	add	esp, 4
$LN1@vmmngr_fre:

; 146  : 
; 147  : 	pt_entry_del_attrib (e, I86_PTE_PRESENT);

	push	1
	push	esi
	call	?pt_entry_del_attrib@@YAXPAII@Z		; pt_entry_del_attrib
	add	esp, 8
	pop	esi

; 148  : }

	ret	0
?vmmngr_free_page@@YAXPAI@Z ENDP			; vmmngr_free_page
_TEXT	ENDS
PUBLIC	?vmmngr_initialize@@YAXXZ			; vmmngr_initialize
EXTRN	?pmmngr_paging_enable@@YAX_N@Z:PROC		; pmmngr_paging_enable
EXTRN	?pd_entry_set_frame@@YAXPAII@Z:PROC		; pd_entry_set_frame
EXTRN	?pd_entry_add_attrib@@YAXPAII@Z:PROC		; pd_entry_add_attrib
EXTRN	?pmmngr_alloc_blocks@@YAPAXI@Z:PROC		; pmmngr_alloc_blocks
; Function compile flags: /Ogtpy
;	COMDAT ?vmmngr_initialize@@YAXXZ
_TEXT	SEGMENT
_page$2784 = -4						; size = 4
?vmmngr_initialize@@YAXXZ PROC				; vmmngr_initialize, COMDAT

; 150  : void vmmngr_initialize () {

	push	ecx
	push	edi

; 151  : 
; 152  : 	//! allocate default page table
; 153  : 	ptable* table = (ptable*) pmmngr_alloc_block ();

	call	?pmmngr_alloc_block@@YAPAXXZ		; pmmngr_alloc_block
	mov	edi, eax

; 154  : 	if (!table)

	test	edi, edi
	je	$LN6@vmmngr_ini
	push	ebx
	push	esi

; 155  : 		return;
; 156  : 
; 157  : 	//! clear page table
; 158  : 	vmmngr_ptable_clear (table);

	push	4096					; 00001000H
	push	0
	push	edi
	call	?memset@@YAPAXPAXDI@Z			; memset
	add	esp, 12					; 0000000cH

; 159  : 
; 160  : 	//! idenitity map the page table (First 4mb of virtual memory mapped to same phys address)
; 161  : 	for (int i=0, frame=0; i<1024; i++, frame+=4096) {

	xor	esi, esi
	mov	ebx, 1024				; 00000400H
	npad	6
$LL4@vmmngr_ini:

; 162  : 
; 163  : 		//! create a new page
; 164  : 		pt_entry page=0;
; 165  : 		pt_entry_add_attrib (&page, I86_PTE_PRESENT);

	lea	eax, DWORD PTR _page$2784[esp+16]
	push	1
	push	eax
	mov	DWORD PTR _page$2784[esp+24], 0
	call	?pt_entry_add_attrib@@YAXPAII@Z		; pt_entry_add_attrib

; 166  : 		pt_entry_set_frame (&page, frame);

	lea	ecx, DWORD PTR _page$2784[esp+24]
	push	esi
	push	ecx
	call	?pt_entry_set_frame@@YAXPAII@Z		; pt_entry_set_frame
	add	esp, 16					; 00000010H

; 167  : 
; 168  : 		//! ...and add it to the page table
; 169  : 		table->m_entries [vmmngr_ptable_virt_to_index (frame) ] = page;

	cmp	esi, 4194304				; 00400000H
	jb	SHORT $LN13@vmmngr_ini
	xor	eax, eax
	jmp	SHORT $LN14@vmmngr_ini
$LN13@vmmngr_ini:
	mov	eax, esi
	shr	eax, 12					; 0000000cH
$LN14@vmmngr_ini:
	mov	edx, DWORD PTR _page$2784[esp+16]
	add	esi, 4096				; 00001000H
	sub	ebx, 1
	mov	DWORD PTR [edi+eax*4], edx
	jne	SHORT $LL4@vmmngr_ini

; 170  : 	}
; 171  : 
; 172  : 	//! create default directory table
; 173  : 	pdirectory*	dir = (pdirectory*) pmmngr_alloc_blocks (3);

	push	3
	call	?pmmngr_alloc_blocks@@YAPAXI@Z		; pmmngr_alloc_blocks
	mov	esi, eax
	add	esp, 4

; 174  : 	if (!dir)

	test	esi, esi
	je	SHORT $LN32@vmmngr_ini

; 175  : 		return;
; 176  : 
; 177  : 	//! clear directory table and set it as current
; 178  : 	vmmngr_pdirectory_clear (dir);

	push	4096					; 00001000H
	push	0
	push	esi
	call	?memset@@YAPAXPAXDI@Z			; memset

; 179  : 
; 180  : 	//! get first entry in dir table and set it up to point to our table
; 181  : 	pd_entry* entry = vmmngr_pdirectory_lookup_entry (dir,0);
; 182  : 	pd_entry_add_attrib (entry, I86_PDE_PRESENT);

	push	1
	push	esi
	call	?pd_entry_add_attrib@@YAXPAII@Z		; pd_entry_add_attrib

; 183  : 	pd_entry_add_attrib (entry, I86_PDE_WRITABLE);

	push	2
	push	esi
	call	?pd_entry_add_attrib@@YAXPAII@Z		; pd_entry_add_attrib

; 184  : 	pd_entry_set_frame (entry, (physical_addr)table);

	push	edi
	push	esi
	call	?pd_entry_set_frame@@YAXPAII@Z		; pd_entry_set_frame

; 185  : 
; 186  : 	//! store current PDBR
; 187  : 	_cur_pdbr = (physical_addr) &dir->m_entries;
; 188  : 
; 189  : 	//! switch to our page directory
; 190  : 	vmmngr_switch_pdirectory (dir);

	push	esi
	mov	DWORD PTR ?_cur_pdbr@@3IA, esi		; _cur_pdbr
	mov	DWORD PTR ?_cur_directory@@3PAUpdirectory@@A, esi ; _cur_directory
	call	?pmmngr_load_PDBR@@YAXI@Z		; pmmngr_load_PDBR

; 191  : 
; 192  : 	//! enable paging
; 193  : 	pmmngr_paging_enable (true);

	push	1
	call	?pmmngr_paging_enable@@YAX_N@Z		; pmmngr_paging_enable
	add	esp, 44					; 0000002cH
$LN32@vmmngr_ini:
	pop	esi
	pop	ebx
$LN6@vmmngr_ini:
	pop	edi

; 194  : }

	pop	ecx
	ret	0
?vmmngr_initialize@@YAXXZ ENDP				; vmmngr_initialize
_TEXT	ENDS
END
