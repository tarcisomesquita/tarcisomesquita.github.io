<!DOCTYPE html>
<html>
<head>

<meta charset="utf-8" />
<title>PE Format - Win32 apps | Microsoft Docs</title>

<style>
body {
  margin: 10mm;
  font-family: "Helvetica";
  font-size: 16px;
  font-weight: 400;
}

table, th, td {
    text-align: center;
    padding-left: 4mm;
    padding-right: 4mm;
    border: 1px #000000 solid;
    margin: 0;
    border-collapse: collapse;
}
</style>

</head>

<body lang="en-us" dir="ltr">

<p>fonte: docs.microsoft.com/en-us/windows/win32/debug/pe-format</p>

<h1>PE Format</h1>
<time>08/26/2019</time>

<ul>
<li><a href="#type-indicators">Type Indicators</a></li>
</ul>
</li>
<li><a href="#coff-line-numbers-deprecated">COFF Line Numbers (Deprecated)</a></li>
<li><a href="#coff-symbol-table">COFF Symbol Table</a>
<ul>
<li><a href="#symbol-name-representation">Symbol Name Representation</a></li>
<li><a href="#section-number-values">Section Number Values</a></li>
<li><a href="#type-representation">Type Representation</a></li>
<li><a href="#storage-class">Storage Class</a></li>
</ul>
</li>
<li><a href="#auxiliary-symbol-records">Auxiliary Symbol Records</a>
<ul>
<li><a href="#auxiliary-format-1-function-definitions">Auxiliary Format 1: Function Definitions</a></li>
<li><a href="#auxiliary-format-2-bf-and-ef-symbols">Auxiliary Format 2: .bf and .ef Symbols</a></li>
<li><a href="#auxiliary-format-3-weak-externals">Auxiliary Format 3: Weak Externals</a></li>
<li><a href="#auxiliary-format-4-files">Auxiliary Format 4: Files</a></li>
<li><a href="#auxiliary-format-5-section-definitions">Auxiliary Format 5: Section Definitions</a></li>
<li><a href="#clr-token-definition-object-only">CLR Token Definition (Object Only)</a></li>
</ul>
</li>
<li><a href="#coff-string-table">COFF String Table</a></li>
<li><a href="#the-attribute-certificate-table-image-only">The Attribute Certificate Table (Image Only)</a>
<ul>
<li><a href="#certificate-data">Certificate Data</a></li>
</ul>
</li>
<li><a href="#delay-load-import-tables-image-only">Delay-Load Import Tables (Image Only)</a>
<ul>
<li><a href="#the-delay-load-directory-table">The Delay-Load Directory Table</a></li>
<li><a href="#attributes">Attributes</a></li>
<li><a href="#name">Name</a></li>
<li><a href="#module-handle">Module Handle</a></li>
<li><a href="#delay-import-address-table">Delay Import Address Table</a></li>
<li><a href="#delay-import-name-table">Delay Import Name Table</a></li>
<li><a href="#delay-bound-import-address-table-and-time-stamp">Delay Bound Import Address Table and Time Stamp</a></li>
<li><a href="#delay-unload-import-address-table">Delay Unload Import Address Table</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#special-sections">Special Sections</a>
<ul>
<li><a href="#the-debug-section">The .debug Section</a>
<ul>
<li><a href="#debug-directory-image-only">Debug Directory (Image Only)</a></li>
<li><a href="#debug-type">Debug Type</a></li>
<li><a href="#debugf-object-only">.debug$F (Object Only)</a></li>
<li><a href="#debugs-object-only">.debug$S (Object Only)</a></li>
<li><a href="#debugp-object-only">.debug$P (Object Only)</a></li>
<li><a href="#debugt-object-only">.debug$T (Object Only)</a></li>
<li><a href="#linker-support-for-microsoft-debug-information">Linker Support for Microsoft Debug Information</a></li>
</ul>
</li>
<li><a href="#the-drectve-section-object-only">The .drectve Section (Object Only)</a></li>
<li><a href="#the-edata-section-image-only">The .edata Section (Image Only)</a>
<ul>
<li><a href="#export-directory-table">Export Directory Table</a></li>
<li><a href="#export-address-table">Export Address Table</a></li>
<li><a href="#export-name-pointer-table">Export Name Pointer Table</a></li>
<li><a href="#export-ordinal-table">Export Ordinal Table</a></li>
<li><a href="#export-name-table">Export Name Table</a></li>
</ul>
</li>
<li><a href="#the-idata-section">The .idata Section</a>
<ul>
<li><a href="#import-directory-table">Import Directory Table</a></li>
<li><a href="#import-lookup-table">Import Lookup Table</a></li>
<li><a href="#hintname-table">Hint/Name Table</a></li>
<li><a href="#delay-import-address-table">Import Address Table</a></li>
</ul>
</li>
<li><a href="#the-pdata-section">The .pdata Section</a></li>
<li><a href="#the-reloc-section-image-only">The .reloc Section (Image Only)</a>
<ul>
<li><a href="#base-relocation-block">Base Relocation Block</a></li>
<li><a href="#base-relocation-types">Base Relocation Types</a></li>
</ul>
</li>
<li><a href="#the-tls-section">The .tls Section</a>
<ul>
<li><a href="#the-tls-directory">The TLS Directory</a></li>
<li><a href="#tls-callback-functions">TLS Callback Functions</a></li>
</ul>
</li>
<li><a href="#the-load-configuration-structure-image-only">The Load Configuration Structure (Image Only)</a>
<ul>
<li><a href="#load-configuration-directory">Load Configuration Directory</a></li>
<li><a href="#load-configuration-layout">Load Configuration Layout</a></li>
</ul>
</li>
<li><a href="#the-rsrc-section">The .rsrc Section</a>
<ul>
<li><a href="#resource-directory-table">Resource Directory Table</a></li>
<li><a href="#resource-directory-entries">Resource Directory Entries</a></li>
<li><a href="#resource-directory-string">Resource Directory String</a></li>
<li><a href="#resource-data-entry">Resource Data Entry</a></li>
</ul>
</li>
<li><a href="#the-cormeta-section-object-only">The .cormeta Section (Object Only)</a></li>
<li><a href="#the-sxdata-section">The .sxdata Section</a></li>
</ul>
</li>
<li><a href="#archive-library-file-format">Archive (Library) File Format</a>
<ul>
<li><a href="#archive-file-signature">Archive File Signature</a></li>
<li><a href="#archive-member-headers">Archive Member Headers</a></li>
<li><a href="#first-linker-member">First Linker Member</a></li>
<li><a href="#second-linker-member">Second Linker Member</a></li>
<li><a href="#longnames-member">Longnames Member</a></li>
</ul>
</li>
<li><a href="#import-library-format">Import Library Format</a>
<ul>
<li><a href="#import-header">Import Header</a></li>
<li><a href="#import-type">Import Type</a></li>
</ul>
</li>
</ul>

<p> </p>

<h2 id="general-concepts">General Concepts</h2>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>RVA</td>
<td>Relative virtual address. In an image file, the address of an item after it is loaded into memory, with the base address of the image file subtracted from it. The RVA of an item almost always differs from its position within the file on disk (file pointer).<br> In an object file, an RVA is less meaningful because memory locations are not assigned. In this case, an RVA would be an address within a section (described later in this table), to which a relocation is later applied during linking. For simplicity, a compiler should just set the first RVA in each section to zero.</td>
</tr>
<tr>
<td>VA</td>
<td>virtual address. Same as RVA, except that the base address of the image file is not subtracted. The address is called a &quot;VA&quot; because Windows creates a distinct VA space for each process, independent of physical memory. For almost all purposes, a VA should be considered just an address. A VA is not as predictable as an RVA because the loader might not load the image at its preferred location.</td>
</tr>
</tbody>
</table>

<p> </p>

<h2 id="overview">Overview</h2>
<ul>
<li><p>MS-DOS stub</p></li>
<li><p>PE Header (aligned on 8-byte boundary)</p></li>
<li><p>Section Headers</p></li>
<li><p>Image Pages:</p>
<p>import info</p>
<p>export info</p>
<p>base relocations</p>
<p>resource info</p>
</li>
</ul>

<p>The following list describes the Microsoft COFF object format:</p>
<ul>
<li><p>Microsoft COFF Header</p></li>
<li><p>Section Headers</p></li>
<li>
<p>Raw Data:</p>
<p>code</p>
<p>data</p>
<p>debug info</p>
<p>relocations</p>
</li>
</ul>



<h2 id="file-headers">File Headers</h2>

<h3 id="signature-image-only">Signature</h3>
<p>After the MS-DOS stub, at the file offset specified at offset 0x3c, is a 4-byte signature that identifies the file as a PE format image file. This signature is &quot;PE\0\0&quot; (the letters &quot;P&quot; and &quot;E&quot; followed by two null bytes).</p>

<h3 id="coff-file-header-object-and-image">File Header</h3>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Size</th>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>2</td>
<td>Machine</td>
<td>See <a href="#machine-types">Machine Types</a>.</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>NumberOfSections</td>
<td>The number of sections. Limit: 96.</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>TimeDateStamp</td>
<td>seconds since 00:00 January 1, 1970. When the file was created.</td>
</tr>
<tr>
<td>8</td>
<td>4</td>
<td>PointerToSymbolTable</td>
<td>Should be zero for an image.</td>
</tr>
<tr>
<td>12</td>
<td>4</td>
<td>NumberOfSymbols</td>
<td>Entries in the symbol table.</td>
</tr>
<tr>
<td>16</td>
<td>2</td>
<td>SizeOfOptionalHeader</td>
<td>See <a href="#optional-header-image-only">Optional Header</a>.</td>
</tr>
<tr>
<td>18</td>
<td>2</td>
<td>Characteristics</td>
<td>Attributes of the file. See <a href="#characteristics">Characteristics</a>.</td>
</tr>
</tbody>
</table>

<p> </p>

<h4 id="machine-types">Machine Types</h4>
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>IMAGE_FILE_MACHINE_AMD64</td>
<td>0x8664</td>
<td>x64</td>
</tr>
<td>IMAGE_FILE_MACHINE_EBC</td>
<td>0x0ebc</td>
<td>EFI byte code</td>
</tr>
<tr>
<td>IMAGE_FILE_MACHINE_I386</td>
<td>0x014c</td>
<td>Intel 386</td>
</tr>
</tbody>
</table>
<p> </p>

<h4 id="characteristics">Characteristics</h4>
<p>The Characteristics field contains flags that indicate attributes of the object or image file. The following flags are currently defined:</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>IMAGE_FILE_RELOCS_STRIPPED</td>
<td>0x0001</td>
<td>Not contain base relocations and must be loaded at base address.</td>
</tr>
<tr>
<td>IMAGE_FILE_EXECUTABLE_IMAGE</td>
<td>0x0002</td>
<td>If this flag is not set, it indicates a linker error.</td>
</tr>
<tr>
<td>IMAGE_FILE_LARGE_ADDRESS_ AWARE</td>
<td>0x0020</td>
<td>Application can handle &gt; 2 GiB addresses.</td>
</tr>
<tr>
<td>IMAGE_FILE_32BIT_MACHINE</td>
<td>0x0100</td>
<td>32-bit-word architecture.</td>
</tr>
<tr>
<td>IMAGE_FILE_DEBUG_STRIPPED</td>
<td>0x0200</td>
<td>Debugging information is removed from the image file.</td>
</tr>
<tr>
<td>IMAGE_FILE_REMOVABLE_RUN_ FROM_SWAP</td>
<td>0x0400</td>
<td>If the image is on removable media, fully load it and copy it to the swap file.</td>
</tr>
<tr>
<td>IMAGE_FILE_NET_RUN_FROM_SWAP</td>
<td>0x0800</td>
<td>If the image is on network media, fully load it and copy it to the swap file.</td>
</tr>
<tr>
<td>IMAGE_FILE_SYSTEM</td>
<td>0x1000</td>
<td>The image file is a system file, not a user program.</td>
</tr>
<tr>
<td>IMAGE_FILE_DLL</td>
<td>0x2000</td>
<td>The image file is a dynamic-link library (DLL).</td>
</tr>
<tr>
<td>IMAGE_FILE_UP_SYSTEM_ONLY</td>
<td>0x4000</td>
<td>The file should be run only on a uniprocessor machine.</td>
</tr>
</tbody>
</table>

<p> </p>

<h3 id="optional-header-image-only">Optional Header (Image Only)</h3>
<p>Note that the size of the optional header is not fixed. See <a href="#coff-file-header-object-and-image">COFF File Header (Object and Image)</a>.</p>
<p>The NumberOfRvaAndSizes field of the optional header should also be used to ensure that no probe for a particular data directory entry goes beyond the optional header.</p>

<p> </p>

<p>The optional header magic number determines whether an image is a PE32 or PE32+ executable.</p>
<table>
<thead>
<tr><th>Magic number</th><th>PE format</th></tr>
</thead>
<tbody>
<tr><td>0x10b</td><td>PE32</td></tr>
<tr><td>0x20b</td><td>PE32+</td></tr>
</tbody>
</table>
<p>PE32+ images allow for a 64-bit address space while limiting the image size to 2 gigabytes.</p>

<p> </p>

<p>The optional header itself has three major parts.</p>
<table>
<thead>
<tr><th>Offset (PE32/PE32+)</th><th>Size (PE32/PE32+)</th><th>Header part</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>28/24</td><td>Standard fields</td></tr>
<tr><td>28/24</td><td>68/88</td><td>Windows-specific fields</td></tr>
<tr><td>96/112</td><td>Variable</td><td>Data directories</td></tr>
</tbody>
</table>

<p> </p>

<h4 id="optional-header-standard-fields-image-only">Optional Header Standard Fields (Image Only)</h4>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Size</th>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>2</td>
<td>Magic</td>
<td>0x10B identifies it as a normal executable file, 0x107 identifies it as a ROM image, and 0x20B identifies it as a PE32+ executable.</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>MajorLinkerVersion</td>
<td>The linker major version number.</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>MinorLinkerVersion</td>
<td>The linker minor version number.</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>SizeOfCode</td>
<td>The size of the code (text) section.</td>
</tr>
<tr>
<td>8</td>
<td>4</td>
<td>SizeOfInitializedData</td>
<td>The size of the initialized data section.</td>
</tr>
<tr>
<td>12</td>
<td>4</td>
<td>SizeOfUninitializedData</td>
<td>The size of the uninitialized data section (BSS).</td>
</tr>
<tr>
<td>16</td>
<td>4</td>
<td>AddressOfEntryPoint</td>
<td>The address of the entry point relative to the image base when the executable file is loaded into memory. For program images, this is the starting address. For device drivers, this is the address of the initialization function. An entry point is optional for DLLs. When no entry point is present, this field must be zero.</td>
</tr>
<tr>
<td>20</td>
<td>4</td>
<td>BaseOfCode</td>
<td>The address that is relative to the image base of the beginning-of-code section when it is loaded into memory.</td>
</tr>
</tbody>
</table>

<p> </p>

<p>PE32 contains this additional field, which is absent in PE32+, following BaseOfCode.</p>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Size</th>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>24</td>
<td>4</td>
<td>BaseOfData</td>
<td>The address that is relative to the image base of the beginning-of-data section when it is loaded into memory.</td>
</tr>
</tbody>
</table>

<p> </p>

<h4 id="optional-header-windows-specific-fields-image-only">Optional Header Windows-Specific Fields (Image Only)</h4>
<table>
<thead>
<tr>
<th>Offset (PE32/ PE32+)</th>
<th>Size (PE32/ PE32+)</th>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>28/24</td>
<td>4/8</td>
<td>ImageBase</td>
<td>The preferred address of the first byte of image when loaded into memory; must be a multiple of 64 kiB. The default for DLLs is 0x10000000. The default for Windows NT is 0x00400000.</td>
</tr>
<tr>
<td>32/32</td>
<td>4</td>
<td>SectionAlignment</td>
<td>The alignment (in bytes) of sections when they are loaded into memory. It must be greater than or equal to FileAlignment. The default is the page size for the architecture.</td>
</tr>
<tr>
<td>36/36</td>
<td>4</td>
<td>FileAlignment</td>
<td>Alignment (in bytes) of sections in the image file. The value should be a power of 2 between 512 and 64 kiB, inclusive. The default is 512. If the SectionAlignment is less than the architecture's page size, then FileAlignment must match SectionAlignment.</td>
</tr>
<tr>
<td>40/40</td>
<td>2</td>
<td>MajorOperatingSystemVersion</td>
<td>The major version number of the required operating system.</td>
</tr>
<tr>
<td>42/42</td>
<td>2</td>
<td>MinorOperatingSystemVersion</td>
<td>The minor version number of the required operating system.</td>
</tr>
<tr>
<td>44/44</td>
<td>2</td>
<td>MajorImageVersion</td>
<td>The major version number of the image.</td>
</tr>
<tr>
<td>46/46</td>
<td>2</td>
<td>MinorImageVersion</td>
<td>The minor version number of the image.</td>
</tr>
<tr>
<td>48/48</td>
<td>2</td>
<td>MajorSubsystemVersion</td>
<td>The major version number of the subsystem.</td>
</tr>
<tr>
<td>50/50</td>
<td>2</td>
<td>MinorSubsystemVersion</td>
<td>The minor version number of the subsystem.</td>
</tr>
<tr>
<td>52/52</td>
<td>4</td>
<td>Win32VersionValue</td>
<td>Reserved, must be zero.</td>
</tr>
<tr>
<td>56/56</td>
<td>4</td>
<td>SizeOfImage</td>
<td>The size (in bytes) of the image, including all headers, as the image is loaded in memory. It must be a multiple of SectionAlignment.</td>
</tr>
<tr>
<td>60/60</td>
<td>4</td>
<td>SizeOfHeaders</td>
<td>The combined size of an MS-DOS stub, PE header, and section headers rounded up to a multiple of FileAlignment.</td>
</tr>
<tr>
<td>64/64</td>
<td>4</td>
<td>CheckSum</td>
<td>The image file checksum (algorithm into IMAGHELP.DLL). Are checked at load time: all drivers, any DLL loaded at boot time, and any DLL that is loaded into a critical Windows process.</td>
</tr>
<tr>
<td>68/68</td>
<td>2</td>
<td>Subsystem</td>
<td>The subsystem that is required to run this image. See <a href="#windows-subsystem">Windows Subsystem</a>.</td>
</tr>
<tr>
<td>70/70</td>
<td>2</td>
<td>DllCharacteristics</td>
<td>See <a href="#dll-characteristics">DLL Characteristics</a>.</td>
</tr>
<tr>
<td>72/72</td>
<td>4/8</td>
<td>SizeOfStackReserve</td>
<td>The size of the stack to reserve. Only SizeOfStackCommit is committed; the rest is made available one page at a time until the reserve size is reached.</td>
</tr>
<tr>
<td>76/80</td>
<td>4/8</td>
<td>SizeOfStackCommit</td>
<td>The size of the stack to commit.</td>
</tr>
<tr>
<td>80/88</td>
<td>4/8</td>
<td>SizeOfHeapReserve</td>
<td>The size of the local heap space to reserve. Only SizeOfHeapCommit is committed; the rest is made available one page at a time until the reserve size is reached.</td>
</tr>
<tr>
<td>84/96</td>
<td>4/8</td>
<td>SizeOfHeapCommit</td>
<td>The size of the local heap space to commit.</td>
</tr>
<tr>
<td>88/104</td>
<td>4</td>
<td>LoaderFlags</td>
<td>Reserved, must be zero.</td>
</tr>
<tr>
<td>92/108</td>
<td>4</td>
<td>NumberOfRvaAndSizes</td>
<td>The number of data-directory entries in the remainder of the optional header. Each describes a location and size.</td>
</tr>
</tbody>
</table>

<p> </p>

<h5 id="windows-subsystem">Windows Subsystem</h5>
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>IMAGE_SUBSYSTEM_UNKNOWN</td>
<td>0</td>
<td>An unknown subsystem</td>
</tr>
<tr>
<td>IMAGE_SUBSYSTEM_NATIVE</td>
<td>1</td>
<td>Device drivers and native Windows processes</td>
</tr>
<tr>
<td>IMAGE_SUBSYSTEM_WINDOWS_GUI</td>
<td>2</td>
<td>The Windows graphical user interface (GUI) subsystem</td>
</tr>
<tr>
<td>IMAGE_SUBSYSTEM_WINDOWS_CUI</td>
<td>3</td>
<td>The Windows character subsystem</td>
</tr>
<tr>
<td>IMAGE_SUBSYSTEM_OS2_CUI</td>
<td>5</td>
<td>The OS/2 character subsystem</td>
</tr>
<tr>
<td>IMAGE_SUBSYSTEM_POSIX_CUI</td>
<td>7</td>
<td>The Posix character subsystem</td>
</tr>
<tr>
<td>IMAGE_SUBSYSTEM_NATIVE_WINDOWS</td>
<td>8</td>
<td>Native Win9x driver</td>
</tr>
<tr>
<td>IMAGE_SUBSYSTEM_WINDOWS_CE_GUI</td>
<td>9</td>
<td>Windows CE</td>
</tr>
<tr>
<td>IMAGE_SUBSYSTEM_EFI_APPLICATION</td>
<td>10</td>
<td>An Extensible Firmware Interface (EFI) application</td>
</tr>
<tr>
<td>IMAGE_SUBSYSTEM_EFI_BOOT_ SERVICE_DRIVER</td>
<td>11</td>
<td>An EFI driver with boot services</td>
</tr>
<tr>
<td>IMAGE_SUBSYSTEM_EFI_RUNTIME_ DRIVER</td>
<td>12</td>
<td>An EFI driver with run-time services</td>
</tr>
<tr>
<td>IMAGE_SUBSYSTEM_EFI_ROM</td>
<td>13</td>
<td>An EFI ROM image</td>
</tr>
<tr>
<td>IMAGE_SUBSYSTEM_XBOX</td>
<td>14</td>
<td>XBOX</td>
</tr>
<tr>
<td>IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION</td>
<td>16</td>
<td>Windows boot application.</td>
</tr>
</tbody>
</table>

<p> </p>

<h5 id="dll-characteristics">DLL Characteristics</h5>
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA</td>
<td>0x0020</td>
<td>Image can handle a high entropy 64-bit virtual address space.</td>
</tr>
<tr>
<td>IMAGE_DLLCHARACTERISTICS_<br> DYNAMIC_BASE</td>
<td>0x0040</td>
<td>DLL can be relocated at load time.</td>
</tr>
<tr>
<td>IMAGE_DLLCHARACTERISTICS_<br> FORCE_INTEGRITY</td>
<td>0x0080</td>
<td>Code Integrity checks are enforced.</td>
</tr>
<tr>
<td>IMAGE_DLLCHARACTERISTICS_<br> NX_COMPAT</td>
<td>0x0100</td>
<td>Image is NX compatible.</td>
</tr>
<tr>
<td>IMAGE_DLLCHARACTERISTICS_ NO_ISOLATION</td>
<td>0x0200</td>
<td>Isolation aware, but do not isolate the image.</td>
</tr>
<tr>
<td>IMAGE_DLLCHARACTERISTICS_ NO_SEH</td>
<td>0x0400</td>
<td>Does not use structured exception (SE) handling. No SE handler may be called in this image.</td>
</tr>
<tr>
<td>IMAGE_DLLCHARACTERISTICS_ NO_BIND</td>
<td>0x0800</td>
<td>Do not bind the image.</td>
</tr>
<tr>
<td>IMAGE_DLLCHARACTERISTICS_APPCONTAINER</td>
<td>0x1000</td>
<td>Image must execute in an AppContainer.</td>
</tr>
<tr>
<td>IMAGE_DLLCHARACTERISTICS_ WDM_DRIVER</td>
<td>0x2000</td>
<td>A WDM driver.</td>
</tr>
<tr>
<td>IMAGE_DLLCHARACTERISTICS_GUARD_CF</td>
<td>0x4000</td>
<td>Image supports Control Flow Guard.</td>
</tr>
<tr>
<td>IMAGE_DLLCHARACTERISTICS_ TERMINAL_SERVER_AWARE</td>
<td>0x8000</td>
<td>Terminal Server aware.</td>
</tr>
</tbody>
</table>

<p> </p>

<h4 id="optional-header-data-directories-image-only">Optional Header Data Directories (Image Only)</h4>
<pre><code>typedef struct _IMAGE_DATA_DIRECTORY {
    DWORD   VirtualAddress;
    DWORD   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;
</code></pre>
<p>The first field, VirtualAddress, is actually the RVA of the table. The RVA is the address of the table relative to the base address of the image when the table is loaded.</p>
<p>Note that the number of directories is not fixed.</p>
<p>Also, do not assume that the RVAs in this table point to the beginning of a section or that the sections that contain specific tables have specific names.</p>
<table>
<thead>
<tr>
<th>Offset (PE/PE32+)</th>
<th>Size</th>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>96/112</td>
<td>8</td>
<td>Export Table</td>
<td>The export table address and size. For more information See <a href="#the-edata-section-image-only">.edata Section (Image Only)</a>.</td>
</tr>
<tr>
<td>104/120</td>
<td>8</td>
<td>Import Table</td>
<td>The import table address and size. For more information, See <a href="#the-idata-section">The .idata Section</a>.</td>
</tr>
<tr>
<td>112/128</td>
<td>8</td>
<td>Resource Table</td>
<td>The resource table address and size. For more information, See <a href="#the-rsrc-section">The .rsrc Section</a>.</td>
</tr>
<tr>
<td>120/136</td>
<td>8</td>
<td>Exception Table</td>
<td>The exception table address and size. For more information, See <a href="#the-pdata-section">The .pdata Section</a>.</td>
</tr>
<tr>
<td>128/144</td>
<td>8</td>
<td>Certificate Table</td>
<td>The attribute certificate table address and size.</td>
</tr>
<tr>
<td>136/152</td>
<td>8</td>
<td>Base Relocation Table</td>
<td>The base relocation table address and size. For more information, See <a href="#the-reloc-section-image-only">The .reloc Section (Image Only)</a>.</td>
</tr>
<tr>
<td>144/160</td>
<td>8</td>
<td>Debug</td>
<td>The debug data starting address and size. For more information, See <a href="#the-debug-section">The .debug Section</a>.</td>
</tr>
<tr>
<td>152/168</td>
<td>8</td>
<td>Architecture</td>
<td>Reserved, must be 0</td>
</tr>
<tr>
<td>160/176</td>
<td>8</td>
<td>Global Ptr</td>
<td>The RVA of the value to be stored in the global pointer register. The size member of this structure must be set to zero.</td>
</tr>
<tr>
<td>168/184</td>
<td>8</td>
<td>TLS Table</td>
<td>The thread local storage (TLS) table address and size. For more information,<a href="#the-tls-section">The .tls Section</a>.</td>
</tr>
<tr>
<td>176/192</td>
<td>8</td>
<td>Load Config Table</td>
<td>The load configuration table address and size. For more information,<a href="#the-load-configuration-structure-image-only">The Load Configuration Structure (Image Only)</a>.</td>
</tr>
<tr>
<td>184/200</td>
<td>8</td>
<td>Bound Import</td>
<td>The bound import table address and size.</td>
</tr>
<tr>
<td>192/208</td>
<td>8</td>
<td>IAT</td>
<td>The import address table address and size. For more information, See <a href="#import-address-table">Import Address Table</a>.</td>
</tr>
<tr>
<td>200/216</td>
<td>8</td>
<td>Delay Import Descriptor</td>
<td>The delay import descriptor address and size. For more information, See <a href="#delay-load-import-tables-image-only">Delay-Load Import Tables (Image Only)</a>.</td>
</tr>
<tr>
<td>208/224</td>
<td>8</td>
<td>CLR Runtime Header</td>
<td>The CLR runtime header address and size. For more information, See <a href="#the-cormeta-section-object-only">The .cormeta Section (Object Only)</a>.</td>
</tr>
<tr>
<td>216/232</td>
<td>8</td>
<td>Reserved, must be zero</td>
<td></td>
</tr>
</tbody>
</table>

<p> </p>

<h2 id="section-table-section-headers">Section Table (Section Headers)</h2>
<p>The VAs for sections must be in ascending order and adjacent, and multiple of the SectionAlignment value in the optional header.</p>
<p>Each section header (section table entry) has the following format, for a total of 40 bytes per entry.</p>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Size</th>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>8</td>
<td>Name</td>
<td>An 8-byte, null-padded UTF-8 encoded string.</td>
</tr>
<tr>
<td>8</td>
<td>4</td>
<td>VirtualSize</td>
<td>The total size of the section when loaded into memory. If this value is greater than SizeOfRawData, the section is zero-padded.</td>
</tr>
<tr>
<td>12</td>
<td>4</td>
<td>VirtualAddress</td>
<td>For executable images, the address of the first byte of the section relative to the image base when the section is loaded into memory.</td>
</tr>
<tr>
<td>16</td>
<td>4</td>
<td>SizeOfRawData</td>
<td>Size of the initialized data on disk (for image files). For executable images, this must be a multiple of FileAlignment from the optional header. If this is less than VirtualSize, the remainder of the section is zero-filled. When a section contains only uninitialized data, this field should be zero.</td>
</tr>
<tr>
<td>20</td>
<td>4</td>
<td>PointerToRawData</td>
<td>The file pointer to the first page of the section within the COFF file. For executable images, this must be a multiple of FileAlignment from the optional header. When a section contains only uninitialized data, this field should be zero.</td>
</tr>
<tr>
<td>24</td>
<td>4</td>
<td>PointerToRelocations</td>
<td>This is set to zero for executable images or if there are no relocations.</td>
</tr>
<tr>
<td>28</td>
<td>4</td>
<td>PointerToLinenumbers</td>
<td>Should be zero for an image because COFF debugging information is deprecated.</td>
</tr>
<tr>
<td>32</td>
<td>2</td>
<td>NumberOfRelocations</td>
<td>This is set to zero for executable images.</td>
</tr>
<tr>
<td>34</td>
<td>2</td>
<td>NumberOfLinenumbers</td>
<td>Should be zero for an image because COFF debugging information is deprecated.</td>
</tr>
<tr>
<td>36</td>
<td>4</td>
<td>Characteristics</td>
<td>See <a href="#section-flags">Section Flags</a>.</td>
</tr>
</tbody>
</table>

<p> </p>

<h3 id="section-flags">Section Flags</h3>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>IMAGE_SCN_CNT_CODE</td>
<td>0x00000020</td>
<td>The section contains executable code.</td>
</tr>
<tr>
<td>IMAGE_SCN_CNT_INITIALIZED_DATA</td>
<td>0x00000040</td>
<td>The section contains initialized data.</td>
</tr>
<tr>
<td>IMAGE_SCN_CNT_UNINITIALIZED_ DATA</td>
<td>0x00000080</td>
<td>The section contains uninitialized data.</td>
</tr>
<tr>
<td>IMAGE_SCN_GPREL</td>
<td>0x00008000</td>
<td>The section contains data referenced through the global pointer (GP).</td>
</tr>
<tr>
<tr>
<td>IMAGE_SCN_LNK_NRELOC_OVFL</td>
<td>0x01000000</td>
<td>The section contains extended relocations.</td>
</tr>
<tr>
<td>IMAGE_SCN_MEM_DISCARDABLE</td>
<td>0x02000000</td>
<td>The section can be discarded as needed.</td>
</tr>
<tr>
<td>IMAGE_SCN_MEM_NOT_CACHED</td>
<td>0x04000000</td>
<td>The section cannot be cached.</td>
</tr>
<tr>
<td>IMAGE_SCN_MEM_NOT_PAGED</td>
<td>0x08000000</td>
<td>The section is not pageable.</td>
</tr>
<tr>
<td>IMAGE_SCN_MEM_SHARED</td>
<td>0x10000000</td>
<td>The section can be shared in memory.</td>
</tr>
<tr>
<td>IMAGE_SCN_MEM_EXECUTE</td>
<td>0x20000000</td>
<td>The section can be executed as code.</td>
</tr>
<tr>
<td>IMAGE_SCN_MEM_READ</td>
<td>0x40000000</td>
<td>The section can be read.</td>
</tr>
<tr>
<td>IMAGE_SCN_MEM_WRITE</td>
<td>0x80000000</td>
<td>The section can be written to.</td>
</tr>
</tbody>
</table>

<p>IMAGE_SCN_LNK_NRELOC_OVFL indicates that the count of relocations for the section exceeds the 16 bits that are reserved for it in the section header. If the bit is set and the NumberOfRelocations field in the section header is 0xffff, the actual relocation count is stored in the 32-bit VirtualAddress field of the first relocation. It is an error if IMAGE_SCN_LNK_NRELOC_OVFL is set and there are fewer than 0xffff relocations in the section.</p>

<p> </p>

<h3 id="section-data">Section Data</h3>
<p>Initialized data for a section consists of simple blocks of bytes. However, for sections that contain all zeros, the section data need not be included.</p>
<p>The data for each section is located at the file offset that was given by the PointerToRawData field in the section header. The size of this data in the file is indicated by the SizeOfRawData field. If SizeOfRawData is less than VirtualSize, the remainder is padded with zeros.</p>
<p>In an image file, the section data must be aligned on a boundary as specified by the FileAlignment field in the optional header. Section data must appear in order of the RVA values for the corresponding sections (as do the individual section headers in the section table).</p>
<p>There are additional restrictions on image files if the SectionAlignment value in the optional header is less than the page size of the architecture. For such files, the location of section data in the file must match its location in memory when the image is loaded, so that the physical offset for section data is the same as the RVA.</p>


<h3 id="delay-load-import-tables-image-only">Delay-Load Import Tables (Image Only)</h3>
<p>To delay the loading of a DLL until the first call into that DLL. See <a href="#the-idata-section">.idata Section</a>.</p>

<h4 id="the-delay-load-directory-table">The Delay-Load Directory Table</h4>
<p>The delay-load directory table is the counterpart to the import directory table. It can be retrieved through the Delay Import Descriptor entry in the optional header data directories list (offset 200). The table is arranged as follows:</p>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Size</th>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>4</td>
<td>Attributes</td>
<td>Must be zero.</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>Name</td>
<td>The RVA of the name of the DLL to be loaded. The name resides in the read-only data section of the image.</td>
</tr>
<tr>
<td>8</td>
<td>4</td>
<td>Module Handle</td>
<td>The RVA of the module handle (in the data section of the image) of the DLL to be delay-loaded. It is used for storage by the routine that is supplied to manage delay-loading.</td>
</tr>
<tr>
<td>12</td>
<td>4</td>
<td>Delay Import Address Table</td>
<td>The RVA of the delay-load import address table. For more information, See <a href="#delay-import-address-table">Delay Import Address Table (IAT)</a>.</td>
</tr>
<tr>
<td>16</td>
<td>4</td>
<td>Delay Import Name Table</td>
<td>The RVA of the delay-load name table, which contains the names of the imports that might need to be loaded. This matches the layout of the import name table. For more information, See <a href="#hintname-table">Hint/Name Table</a>.</td>
</tr>
<tr>
<td>20</td>
<td>4</td>
<td>Bound Delay Import Table</td>
<td>The RVA of the bound delay-load address table, if it exists.</td>
</tr>
<tr>
<td>24</td>
<td>4</td>
<td>Unload Delay Import Table</td>
<td>The RVA of the unload delay-load address table, if it exists. This is an exact copy of the delay import address table. If the caller unloads the DLL, this table should be copied back over the delay import address table so that subsequent calls to the DLL continue to use the thunking mechanism correctly.</td>
</tr>
<tr>
<td>28</td>
<td>4</td>
<td>Time Stamp</td>
<td>The timestamp of the DLL to which this image has been bound.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The tables that are referenced in this data structure are organized and sorted just as their counterparts are for traditional imports. For details, See <a href="#the-idata-section">The .idata Section</a>.</p>

<h4 id="attributes">Attributes</h4>
<p>As yet, no attribute flags are defined. The linker sets this field to zero in the image. This field can be used to extend the record by indicating the presence of new fields, or it can be used to indicate behaviors to the delay or unload helper functions.</p>

<h4 id="name">Name</h4>
<p>The name of the DLL to be delay-loaded resides in the read-only data section of the image. It is referenced through the szName field.</p>

<h4 id="module-handle">Module Handle</h4>
<p>The handle of the DLL to be delay-loaded is in the data section of the image. The phmod field points to the handle. The supplied delay-load helper uses this location to store the handle to the loaded DLL.</p>

<h4 id="delay-import-address-table">Delay Import Address Table</h4>
<p>The delay import address table (IAT) is referenced by the delay import descriptor through the pIAT field. The delay-load helper updates these pointers with the real entry points so that the thunks are no longer in the calling loop. The function pointers are accessed by using the expression<code>pINT-&gt;u1.Function</code>.</p>

<h4 id="delay-import-name-table">Delay Import Name Table</h4>
<p>The delay import name table (INT) contains the names of the imports that might require loading. They are ordered in the same fashion as the function pointers in the IAT. They consist of the same structures as the standard INT and are accessed by using the expression<code>pINT-&gt;u1.AddressOfData-&gt;Name[0]</code>.</p>

<h4 id="delay-bound-import-address-table-and-time-stamp">Delay Bound Import Address Table and Time Stamp</h4>
<p>The delay bound import address table (BIAT) is an optional table of IMAGE_THUNK_DATA items that is used along with the timestamp field of the delay-load directory table by a post-process binding phase.</p>

<h4 id="delay-unload-import-address-table">Delay Unload Import Address Table</h4>
<p>The delay unload import address table (UIAT) is an optional table of IMAGE_THUNK_DATA items that the unload code uses to handle an explicit unload request. It consists of initialized data in the read-only section that is an exact copy of the original IAT that referred the code to the delay-load thunks. On the unload request, the library can be freed, the *phmod cleared, and the UIAT written over the IAT to restore everything to its preload state.</p>

<h2 id="special-sections">Special Sections</h2>
<p>Typical COFF sections contain code or data that linkers and Microsoft Win32 loaders process without special knowledge of the section contents. The contents are relevant only to the application that is being linked or executed.</p>
<p>However, some COFF sections have special meanings when found in object files or image files. Tools and loaders recognize these sections because they have special flags set in the section header, because special locations in the image optional header point to them, or because the section name itself indicates a special function of the section. (Even if the section name itself does not indicate a special function of the section, the section name is dictated by convention, so the authors of this specification can refer to a section name in all cases.)</p>
<p>The reserved sections and their attributes are described in the table below, followed by detailed descriptions for the section types that are persisted into executables and the section types that contain metadata for extensions.</p>
<table>
<thead>
<tr>
<th>Section Name</th>
<th>Content</th>
<th>Characteristics</th>
</tr>
</thead>
<tbody>
<tr>
<td>.bss</td>
<td>Uninitialized data (free format)</td>
<td>IMAGE_SCN_CNT_UNINITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE</td>
</tr>
<tr>
<td>.cormeta</td>
<td>CLR metadata that indicates that the object file contains managed code</td>
<td>IMAGE_SCN_LNK_INFO</td>
</tr>
<tr>
<td>.data</td>
<td>Initialized data (free format)</td>
<td>IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE</td>
</tr>
<tr>
<td>.debug$F</td>
<td>Generated FPO debug information (object only, x86 architecture only, and now obsolete)</td>
<td>IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_DISCARDABLE</td>
</tr>
<tr>
<td>.debug$P</td>
<td>Precompiled debug types (object only)</td>
<td>IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_DISCARDABLE</td>
</tr>
<tr>
<td>.debug$S</td>
<td>Debug symbols (object only)</td>
<td>IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_DISCARDABLE</td>
</tr>
<tr>
<td>.debug$T</td>
<td>Debug types (object only)</td>
<td>IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_DISCARDABLE</td>
</tr>
<tr>
<td>.drective</td>
<td>Linker options</td>
<td>IMAGE_SCN_LNK_INFO</td>
</tr>
<tr>
<td>.edata</td>
<td>Export tables</td>
<td>IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ</td>
</tr>
<tr>
<td>.idata</td>
<td>Import tables</td>
<td>IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE</td>
</tr>
<tr>
<td>.idlsym</td>
<td>Includes registered SEH (image only) to support IDL attributes. For information, see &quot;IDL Attributes&quot; in<a href="#references">References</a> at the end of this topic.</td>
<td>IMAGE_SCN_LNK_INFO</td>
</tr>
<tr>
<td>.pdata</td>
<td>Exception information</td>
<td>IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ</td>
</tr>
<tr>
<td>.rdata</td>
<td>Read-only initialized data</td>
<td>IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ</td>
</tr>
<tr>
<td>.reloc</td>
<td>Image relocations</td>
<td>IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_DISCARDABLE</td>
</tr>
<tr>
<td>.rsrc</td>
<td>Resource directory</td>
<td>IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ</td>
</tr>
<tr>
<td>.sbss</td>
<td>GP-relative uninitialized data (free format)</td>
<td>IMAGE_SCN_CNT_UNINITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE | IMAGE _SCN_GPREL The IMAGE_SCN_GPREL flag should be set for IA64 architectures only; this flag is not valid for other architectures. The IMAGE_SCN_GPREL flag is for object files only; when this section type appears in an image file, the IMAGE_SCN_GPREL flag must not be set.</td>
</tr>
<tr>
<td>.sdata</td>
<td>GP-relative initialized data (free format)</td>
<td>IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE | IMAGE _SCN_GPREL The IMAGE_SCN_GPREL flag should be set for IA64 architectures only; this flag is not valid for other architectures. The IMAGE_SCN_GPREL flag is for object files only; when this section type appears in an image file, the IMAGE_SCN_GPREL flag must not be set.</td>
</tr>
<tr>
<td>.srdata</td>
<td>GP-relative read-only data (free format)</td>
<td>IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE _SCN_GPREL The IMAGE_SCN_GPREL flag should be set for IA64 architectures only; this flag is not valid for other architectures. The IMAGE_SCN_GPREL flag is for object files only; when this section type appears in an image file, the IMAGE_SCN_GPREL flag must not be set.</td>
</tr>
<tr>
<td>.sxdata</td>
<td>Registered exception handler data (free format and x86/object only)</td>
<td>IMAGE_SCN_LNK_INFO Contains the symbol index of each of the exception handlers being referred to by the code in that object file. The symbol can be for an UNDEF symbol or one that is defined in that module.</td>
</tr>
<tr>
<td>.text</td>
<td>Executable code (free format)</td>
<td>IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE | IIMAGE_SCN_MEM_READ</td>
</tr>
<tr>
<td>.tls</td>
<td>Thread-local storage (object only)</td>
<td>IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE</td>
</tr>
<tr>
<td>.tls$</td>
<td>Thread-local storage (object only)</td>
<td>IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE</td>
</tr>
<tr>
<td>.vsdata</td>
<td>GP-relative initialized data (free format and for ARM, SH4, and Thumb architectures only)</td>
<td>IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE</td>
</tr>
<tr>
<td>.xdata</td>
<td>Exception information (free format)</td>
<td>IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Some of the sections listed here are marked &quot;object only&quot; or &quot;image only&quot; to indicate that their special semantics are relevant only for object files or image files, respectively. A section that is marked &quot;image only&quot; might still appear in an object file as a way of getting into the image file, but the section has no special meaning to the linker, only to the image file loader.</p>

<h3 id="the-debug-section">The .debug Section</h3>
<p>The .debug section is used in object files to contain compiler-generated debug information and in image files to contain all of the debug information that is generated. This section describes the packaging of debug information in object and image files.</p>
<p>The next section describes the format of the debug directory, which can be anywhere in the image. Subsequent sections describe the &quot;groups&quot; in object files that contain debug information.</p>
<p>The default for the linker is that debug information is not mapped into the address space of the image. A .debug section exists only when debug information is mapped in the address space.</p>

<h4 id="debug-directory-image-only">Debug Directory (Image Only)</h4>
<p>Image files contain an optional debug directory that indicates what form of debug information is present and where it is. This directory consists of an array of debug directory entries whose location and size are indicated in the image optional header.</p>
<p>The debug directory can be in a discardable .debug section (if one exists), or it can be included in any other section in the image file, or not be in a section at all.</p>
<p>Each debug directory entry identifies the location and size of a block of debug information. The specified RVA can be zero if the debug information is not covered by a section header (that is, it resides in the image file and is not mapped into the run-time address space). If it is mapped, the RVA is its address.</p>
<p>A debug directory entry has the following format:</p>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Size</th>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>4</td>
<td>Characteristics</td>
<td>Reserved, must be zero.</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>TimeDateStamp</td>
<td>The time and date that the debug data was created.</td>
</tr>
<tr>
<td>8</td>
<td>2</td>
<td>MajorVersion</td>
<td>The major version number of the debug data format.</td>
</tr>
<tr>
<td>10</td>
<td>2</td>
<td>MinorVersion</td>
<td>The minor version number of the debug data format.</td>
</tr>
<tr>
<td>12</td>
<td>4</td>
<td>Type</td>
<td>The format of debugging information. This field enables support of multiple debuggers. For more information, See <a href="#debug-type">Debug Type</a>.</td>
</tr>
<tr>
<td>16</td>
<td>4</td>
<td>SizeOfData</td>
<td>The size of the debug data (not including the debug directory itself).</td>
</tr>
<tr>
<td>20</td>
<td>4</td>
<td>AddressOfRawData</td>
<td>The address of the debug data when loaded, relative to the image base.</td>
</tr>
<tr>
<td>24</td>
<td>4</td>
<td>PointerToRawData</td>
<td>The file pointer to the debug data.</td>
</tr>
</tbody>
</table>
<p> </p>

<h4 id="debug-type">Debug Type</h4>
<p>The following values are defined for the Type field of the debug directory entry:</p>
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>IMAGE_DEBUG_TYPE_UNKNOWN</td>
<td>0</td>
<td>An unknown value that is ignored by all tools.</td>
</tr>
<tr>
<td>IMAGE_DEBUG_TYPE_COFF</td>
<td>1</td>
<td>The COFF debug information (line numbers, symbol table, and string table). This type of debug information is also pointed to by fields in the file headers.</td>
</tr>
<tr>
<td>IMAGE_DEBUG_TYPE_CODEVIEW</td>
<td>2</td>
<td>The Visual C++ debug information.</td>
</tr>
<tr>
<td>IMAGE_DEBUG_TYPE_FPO</td>
<td>3</td>
<td>The frame pointer omission (FPO) information. This information tells the debugger how to interpret nonstandard stack frames, which use the EBP register for a purpose other than as a frame pointer.</td>
</tr>
<tr>
<td>IMAGE_DEBUG_TYPE_MISC</td>
<td>4</td>
<td>The location of DBG file.</td>
</tr>
<tr>
<td>IMAGE_DEBUG_TYPE_EXCEPTION</td>
<td>5</td>
<td>A copy of .pdata section.</td>
</tr>
<tr>
<td>IMAGE_DEBUG_TYPE_FIXUP</td>
<td>6</td>
<td>Reserved.</td>
</tr>
<tr>
<td>IMAGE_DEBUG_TYPE_OMAP_TO_SRC</td>
<td>7</td>
<td>The mapping from an RVA in image to an RVA in source image.</td>
</tr>
<tr>
<td>IMAGE_DEBUG_TYPE_OMAP_FROM_SRC</td>
<td>8</td>
<td>The mapping from an RVA in source image to an RVA in image.</td>
</tr>
<tr>
<td>IMAGE_DEBUG_TYPE_BORLAND</td>
<td>9</td>
<td>Reserved for Borland.</td>
</tr>
<tr>
<td>IMAGE_DEBUG_TYPE_RESERVED10</td>
<td>10</td>
<td>Reserved.</td>
</tr>
<tr>
<td>IMAGE_DEBUG_TYPE_CLSID</td>
<td>11</td>
<td>Reserved.</td>
</tr>
<tr>
<td>IMAGE_DEBUG_TYPE_REPRO</td>
<td>16</td>
<td>PE determinism or reproducibility.</td>
</tr>
<tr>
<td>IMAGE_DEBUG_TYPE_EX_DLLCHARACTERISTICS</td>
<td>20</td>
<td>Extended DLL characteristics bits.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>If the Type field is set to IMAGE_DEBUG_TYPE_FPO, the debug raw data is an array in which each member describes the stack frame of a function. Not every function in the image file must have FPO information defined for it, even though debug type is FPO. Those functions that do not have FPO information are assumed to have normal stack frames. The format for FPO information is as follows:</p>
<pre><code>#define FRAME_FPO   0               
#define FRAME_TRAP  1
#define FRAME_TSS   2
               
typedef struct _FPO_DATA {
    DWORD       ulOffStart;            // offset 1st byte of function code
    DWORD       cbProcSize;            // # bytes in function
    DWORD       cdwLocals;             // # bytes in locals/4
    WORD        cdwParams;             // # bytes in params/4
    WORD        cbProlog : 8;          // # bytes in prolog
    WORD        cbRegs   : 3;          // # regs saved
    WORD        fHasSEH  : 1;          // TRUE if SEH in func
    WORD        fUseBP   : 1;          // TRUE if EBP has been allocated
    WORD        reserved : 1;          // reserved for future use
    WORD        cbFrame  : 2;          // frame type
} FPO_DATA;
</code></pre>
<p>The presence of an entry of type IMAGE_DEBUG_TYPE_REPRO indicates the PE file is built in a way to achieve determinism or reproducibility. If the input does not change, the output PE file is guaranteed to be bit-for-bit identical no matter when or where the PE is produced. Various date/time stamp fields in the PE file are filled with part or all the bits from a calculated hash value that uses PE file content as input, and therefore no longer represent the actual date and time when a PE file or related specific data within the PE is produced. The raw data of this debug entry may be empty, or may contain a calculated hash value preceded by a four-byte value that represents the hash value length.</p>
<p>If the Type field is set to IMAGE_DEBUG_TYPE_EX_DLLCHARACTERISTICS, the debug raw data contains extended DLL characteristics bits, in additional to those that could be set in image’s optional header. See <a href="#dll-characteristics">DLL Characteristics</a> in section<a href="#optional-header-windows-specific-fields-image-only">Optional Header Windows-Specific Fields (Image Only)</a>.</p>

<h5 id="extended-dll-characteristics">Extended DLL Characteristics</h5>
<p>The following values are defined for the extended DLL characteristics bits.</p>
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>IMAGE_DLLCHARACTERISTICS_EX_CET_COMPAT</td>
<td>0x0001</td>
<td>Image is CET compatible.</td>
</tr>
</tbody>
</table>

<h4 id="debugf-object-only">.debug$F (Object Only)</h4>
<p>The data in this section has been superseded in Visual C++ version 7.0 and later by a more extensive set of data that is emitted into a<strong>.debug$S</strong> subsection.</p>
<p>Object files can contain .debug$F sections whose contents are one or more FPO_DATA records (frame pointer omission information). See &quot;IMAGE_DEBUG_TYPE_FPO&quot; in<a href="#debug-type">Debug Type</a>.</p>
<p>The linker recognizes these<strong>.debug$F</strong> records. If debug information is being generated, the linker sorts the FPO_DATA records by procedure RVA and generates a debug directory entry for them.</p>
<p>The compiler should not generate FPO records for procedures that have a standard frame format.</p>

<h4 id="debugs-object-only">.debug$S (Object Only)</h4>
<p>This section contains Visual C++ debug information (symbolic information).</p>

<h4 id="debugp-object-only">.debug$P (Object Only)</h4>
<p>This section contains Visual C++ debug information (precompiled information). These are shared types among all of the objects that were compiled by using the precompiled header that was generated with this object.</p>

<h4 id="debugt-object-only">.debug$T (Object Only)</h4>
<p>This section contains Visual C++ debug information (type information).</p>

<h4 id="linker-support-for-microsoft-debug-information">Linker Support for Microsoft Debug Information</h4>
<p>To support debug information, the linker:</p>
<ul>
<li><p>Gathers all relevant debug data from the<strong>.debug$F</strong>,<strong>debug$S</strong>,<strong>.debug$P</strong>, and<strong>.debug$T</strong> sections.</p>
</li>
<li><p>Processes that data along with the linker-generated debugging information into the PDB file, and creates a debug directory entry to refer to it.</p>
</li>
</ul>

<h3 id="the-drectve-section-object-only">The .drectve Section (Object Only)</h3>
<p>A section is a directive section if it has the IMAGE_SCN_LNK_INFO flag set in the section header and has the<strong>.drectve</strong> section name. The linker removes a<strong>.drectve</strong> section after processing the information, so the section does not appear in the image file that is being linked.</p>
<p>A<strong>.drectve</strong> section consists of a string of text that can be encoded as ANSI or UTF-8. If the UTF-8 byte order marker (BOM, a three-byte prefix that consists of 0xEF, 0xBB, and 0xBF) is not present, the directive string is interpreted as ANSI. The directive string is a series of linker options that are separated by spaces. Each option contains a hyphen, the option name, and any appropriate attribute. If an option contains spaces, the option must be enclosed in quotes. The<strong>.drectve</strong> section must not have relocations or line numbers.</p>

<h3 id="the-edata-section-image-only">The .edata Section (Image Only)</h3>
<p>The export data section, named .edata, contains information about symbols that other images can access through dynamic linking. Exported symbols are generally found in DLLs, but DLLs can also import symbols.</p>
<p>An overview of the general structure of the export section is described below. The tables described are usually contiguous in the file in the order shown (though this is not required). Only the export directory table and export address table are required to export symbols as ordinals. (An ordinal is an export that is accessed directly by its export address table index.) The name pointer table, ordinal table, and export name table all exist to support use of export names.</p>
<table>
<thead>
<tr>
<th>Table Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Export directory table</td>
<td>A table with just one row (unlike the debug directory). This table indicates the locations and sizes of the other export tables.</td>
</tr>
<tr>
<td>Export address table</td>
<td>An array of RVAs of exported symbols. These are the actual addresses of the exported functions and data within the executable code and data sections. Other image files can import a symbol by using an index to this table (an ordinal) or, optionally, by using the public name that corresponds to the ordinal if a public name is defined.</td>
</tr>
<tr>
<td>Name pointer table</td>
<td>An array of pointers to the public export names, sorted in ascending order.</td>
</tr>
<tr>
<td>Ordinal table</td>
<td>An array of the ordinals that correspond to members of the name pointer table. The correspondence is by position; therefore, the name pointer table and the ordinal table must have the same number of members. Each ordinal is an index into the export address table.</td>
</tr>
<tr>
<td>Export name table</td>
<td>A series of null-terminated ASCII strings. Members of the name pointer table point into this area. These names are the public names through which the symbols are imported and exported; they are not necessarily the same as the private names that are used within the image file.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>When another image file imports a symbol by name, the Win32 loader searches the name pointer table for a matching string. If a matching string is found, the associated ordinal is identified by looking up the corresponding member in the ordinal table (that is, the member of the ordinal table with the same index as the string pointer found in the name pointer table). The resulting ordinal is an index into the export address table, which gives the actual location of the desired symbol. Every export symbol can be accessed by an ordinal.</p>
<p>When another image file imports a symbol by ordinal, it is unnecessary to search the name pointer table for a matching string. Direct use of an ordinal is therefore more efficient. However, an export name is easier to remember and does not require the user to know the table index for the symbol.</p>

<h4 id="export-directory-table">Export Directory Table</h4>
<p>The export symbol information begins with the export directory table, which describes the remainder of the export symbol information. The export directory table contains address information that is used to resolve imports to the entry points within this image.</p>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Size</th>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>4</td>
<td>Export Flags</td>
<td>Reserved, must be 0.</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>Time/Date Stamp</td>
<td>The time and date that the export data was created.</td>
</tr>
<tr>
<td>8</td>
<td>2</td>
<td>Major Version</td>
<td>The major version number. The major and minor version numbers can be set by the user.</td>
</tr>
<tr>
<td>10</td>
<td>2</td>
<td>Minor Version</td>
<td>The minor version number.</td>
</tr>
<tr>
<td>12</td>
<td>4</td>
<td>Name RVA</td>
<td>The address of the ASCII string that contains the name of the DLL. This address is relative to the image base.</td>
</tr>
<tr>
<td>16</td>
<td>4</td>
<td>Ordinal Base</td>
<td>The starting ordinal number for exports in this image. This field specifies the starting ordinal number for the export address table. It is usually set to 1.</td>
</tr>
<tr>
<td>20</td>
<td>4</td>
<td>Address Table Entries</td>
<td>The number of entries in the export address table.</td>
</tr>
<tr>
<td>24</td>
<td>4</td>
<td>Number of Name Pointers</td>
<td>The number of entries in the name pointer table. This is also the number of entries in the ordinal table.</td>
</tr>
<tr>
<td>28</td>
<td>4</td>
<td>Export Address Table RVA</td>
<td>The address of the export address table, relative to the image base.</td>
</tr>
<tr>
<td>32</td>
<td>4</td>
<td>Name Pointer RVA</td>
<td>The address of the export name pointer table, relative to the image base. The table size is given by the Number of Name Pointers field.</td>
</tr>
<tr>
<td>36</td>
<td>4</td>
<td>Ordinal Table RVA</td>
<td>The address of the ordinal table, relative to the image base.</td>
</tr>
</tbody>
</table>
<p> </p>

<h4 id="export-address-table">Export Address Table</h4>
<p>The export address table contains the address of exported entry points and exported data and absolutes. An ordinal number is used as an index into the export address table.</p>
<p>Each entry in the export address table is a field that uses one of two formats in the following table. If the address specified is not within the export section (as defined by the address and length that are indicated in the optional header), the field is an export RVA, which is an actual address in code or data. Otherwise, the field is a forwarder RVA, which names a symbol in another DLL.</p>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Size</th>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>4</td>
<td>Export RVA</td>
<td>The address of the exported symbol when loaded into memory, relative to the image base. For example, the address of an exported function.</td>
</tr>
<tr>
<td>0</td>
<td>4</td>
<td>Forwarder RVA</td>
<td>The pointer to a null-terminated ASCII string in the export section. This string must be within the range that is given by the export table data directory entry. See <a href="#optional-header-data-directories-image-only">Optional Header Data Directories (Image Only)</a>. This string gives the DLL name and the name of the export (for example, &quot;MYDLL.expfunc&quot;) or the DLL name and the ordinal number of the export (for example, &quot;MYDLL.#27&quot;).</td>
</tr>
</tbody>
</table>
<p> </p>
<p>A forwarder RVA exports a definition from some other image, making it appear as if it were being exported by the current image. Thus, the symbol is simultaneously imported and exported.</p>
<p>For example, in Kernel32.dll in Windows XP, the export named &quot;HeapAlloc&quot; is forwarded to the string &quot;NTDLL.RtlAllocateHeap.&quot; This allows applications to use the Windows XP-specific module Ntdll.dll without actually containing import references to it. The application's import table refers only to Kernel32.dll. Therefore, the application is not specific to Windows XP and can run on any Win32 system.</p>

<h4 id="export-name-pointer-table">Export Name Pointer Table</h4>
<p>The export name pointer table is an array of addresses (RVAs) into the export name table. The pointers are 32 bits each and are relative to the image base. The pointers are ordered lexically to allow binary searches.</p>
<p>An export name is defined only if the export name pointer table contains a pointer to it.</p>

<h4 id="export-ordinal-table">Export Ordinal Table</h4>
<p>The export ordinal table is an array of 16-bit unbiased indexes into the export address table. Ordinals are biased by the Ordinal Base field of the export directory table. In other words, the ordinal base must be subtracted from the ordinals to obtain true indexes into the export address table.</p>
<p>The export name pointer table and the export ordinal table form two parallel arrays that are separated to allow natural field alignment. These two tables, in effect, operate as one table, in which the Export Name Pointer column points to a public (exported) name and the Export Ordinal column gives the corresponding ordinal for that public name. A member of the export name pointer table and a member of the export ordinal table are associated by having the same position (index) in their respective arrays.</p>
<p>Thus, when the export name pointer table is searched and a matching string is found at position i, the algorithm for finding the symbol's RVA and biased ordinal is:</p>
<pre><code>i = Search_ExportNamePointerTable (name);
ordinal = ExportOrdinalTable [i];

rva = ExportAddressTable [ordinal];
biased_ordinal = ordinal + OrdinalBase;
</code></pre>
<p>When searching for a symbol by (biased) ordinal, the algorithm for finding the symbol's RVA and name is:</p>
<pre><code>ordinal = biased_ordinal - OrdinalBase;
i = Search_ExportOrdinalTable (ordinal);

rva = ExportAddressTable [ordinal];
name = ExportNameTable [i];
</code></pre>

<h4 id="export-name-table">Export Name Table</h4>
<p>The export name table contains the actual string data that was pointed to by the export name pointer table. The strings in this table are public names that other images can use to import the symbols. These public export names are not necessarily the same as the private symbol names that the symbols have in their own image file and source code, although they can be.</p>
<p>Every exported symbol has an ordinal value, which is just the index into the export address table. Use of export names, however, is optional. Some, all, or none of the exported symbols can have export names. For exported symbols that do have export names, corresponding entries in the export name pointer table and export ordinal table work together to associate each name with an ordinal.</p>
<p>The structure of the export name table is a series of null-terminated ASCII strings of variable length.</p>

<h3 id="the-idata-section">The .idata Section</h3>
<p>All image files that import symbols, including virtually all executable (EXE) files, have an .idata section. A typical file layout for the import information follows:</p>
<ul>
<li><p>Directory Table</p>
<p>Null Directory Entry</p>
</li>
<li><p>DLL1 Import Lookup Table</p>
<p>Null</p>
</li>
<li><p>DLL2 Import Lookup Table</p>
<p>Null</p>
</li>
<li><p>DLL3 Import Lookup Table</p>
<p>Null</p>
</li>
<li><p>Hint-Name Table</p>
</li>
</ul>

<h4 id="import-directory-table">Import Directory Table</h4>
<p>The import information begins with the import directory table, which describes the remainder of the import information. The import directory table contains address information that is used to resolve fixup references to the entry points within a DLL image. The import directory table consists of an array of import directory entries, one entry for each DLL to which the image refers. The last directory entry is empty (filled with null values), which indicates the end of the directory table.</p>
<p>Each import directory entry has the following format:</p>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Size</th>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>4</td>
<td>Import Lookup Table RVA (Characteristics)</td>
<td>The RVA of the <a href="#import-lookup-table">import lookup table</a>.</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>Time/Date Stamp</td>
<td>The stamp that is set to zero until the image is bound. After the image is bound, this field is set to the time/data stamp of the DLL.</td>
</tr>
<tr>
<td>8</td>
<td>4</td>
<td>Forwarder Chain</td>
<td>The index of the first forwarder reference.</td>
</tr>
<tr>
<td>12</td>
<td>4</td>
<td>Name RVA</td>
<td>The address of an ASCII string that contains the name of the DLL. This address is relative to the image base.</td>
</tr>
<tr>
<td>16</td>
<td>4</td>
<td>Import Address Table RVA (Thunk Table)</td>
<td>The RVA of the <a href="#import-address-table">import address table</a>.</td>
</tr>
</tbody>
</table>
<p> </p>

<h4 id="import-lookup-table">Import Lookup Table</h4>
<p>An import lookup table is an array of 32-bit numbers for PE32 or an array of 64-bit numbers for PE32+. The last entry is set to zero (NULL) to indicate the end of the table.</p>
<table>
<thead>
<tr>
<th>Bit(s)</th>
<th>Size</th>
<th>Bit field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>31/63</td>
<td>1</td>
<td>Ordinal/Name Flag</td>
<td>If this bit is set, import by ordinal. Otherwise, import by name. Bit is masked as 0x80000000 for PE32, 0x8000000000000000 for PE32+.</td>
</tr>
<tr>
<td>15-0</td>
<td>16</td>
<td>Ordinal Number</td>
<td>A 16-bit ordinal number. This field is used only if the Ordinal/Name Flag bit field is 1 (import by ordinal). Bits 30-15 or 62-15 must be 0.</td>
</tr>
<tr>
<td>30-0</td>
<td>31</td>
<td>Hint/Name Table RVA</td>
<td>A 31-bit RVA of a hint/name table entry. This field is used only if the Ordinal/Name Flag bit field is 0 (import by name). For PE32+ bits 62-31 must be zero.</td>
</tr>
</tbody>
</table>

<p> </p>

<h4 id="hintname-table">Hint/Name Table</h4>
<p>One hint/name table suffices for the entire import section. Each entry in the hint/name table has the following format:</p>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Size</th>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>2</td>
<td>Hint</td>
<td>An index into the export name pointer table. A match is attempted first with this value. If it fails, a binary search is performed on the DLL's export name pointer table.</td>
</tr>
<tr>
<td>2</td>
<td>variable</td>
<td>Name</td>
<td>An ASCII string that contains the name to import. This is the string that must be matched to the public name in the DLL. This string is case sensitive and terminated by a null byte.</td>
</tr>
<tr>
<td>*</td>
<td>0 or 1</td>
<td>Pad</td>
<td>A trailing zero-pad byte that appears after the trailing null byte, if necessary, to align the next entry on an even boundary.</td>
</tr>
</tbody>
</table>
<p> </p>

<h4 id="import-address-table">Import Address Table</h4>
<p>The structure and content of the import address table are identical to those of the import lookup table, until the file is bound. During binding, the entries in the import address table are overwritten with the 32-bit (for PE32) or 64-bit (for PE32+) addresses of the symbols that are being imported. These addresses are the actual memory addresses of the symbols, although technically they are still called &quot;virtual addresses.&quot; The loader typically processes the binding.</p>

<h3 id="the-pdata-section">The .pdata Section</h3>
<p>The .pdata section contains an array of function table entries that are used for exception handling. It is pointed to by the exception table entry in the image data directory. The entries must be sorted according to the function addresses (the first field in each structure) before being emitted into the final image. The target platform determines which of the three function table entry format variations described below is used.</p>
<p>For 32-bit MIPS images, function table entries have the following format:</p>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Size</th>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>4</td>
<td>Begin Address</td>
<td>The VA of the corresponding function.</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>End Address</td>
<td>The VA of the end of the function.</td>
</tr>
<tr>
<td>8</td>
<td>4</td>
<td>Exception Handler</td>
<td>The pointer to the exception handler to be executed.</td>
</tr>
<tr>
<td>12</td>
<td>4</td>
<td>Handler Data</td>
<td>The pointer to additional information to be passed to the handler.</td>
</tr>
<tr>
<td>16</td>
<td>4</td>
<td>Prolog End Address</td>
<td>The VA of the end of the function's prolog.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>For the ARM, PowerPC, SH3 and SH4 Windows CE platforms, function table entries have the following format:</p>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Size</th>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>4</td>
<td>Begin Address</td>
<td>The VA of the corresponding function.</td>
</tr>
<tr>
<td>4</td>
<td>8 bits</td>
<td>Prolog Length</td>
<td>The number of instructions in the function's prolog.</td>
</tr>
<tr>
<td>4</td>
<td>22 bits</td>
<td>Function Length</td>
<td>The number of instructions in the function.</td>
</tr>
<tr>
<td>4</td>
<td>1 bit</td>
<td>32-bit Flag</td>
<td>If set, the function consists of 32-bit instructions. If clear, the function consists of 16-bit instructions.</td>
</tr>
<tr>
<td>4</td>
<td>1 bit</td>
<td>Exception Flag</td>
<td>If set, an exception handler exists for the function. Otherwise, no exception handler exists.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>For x64 and Itanium platforms, function table entries have the following format:</p>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Size</th>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>4</td>
<td>Begin Address</td>
<td>The RVA of the corresponding function.</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>End Address</td>
<td>The RVA of the end of the function.</td>
</tr>
<tr>
<td>8</td>
<td>4</td>
<td>Unwind Information</td>
<td>The RVA of the unwind information.</td>
</tr>
</tbody>
</table>
<p> </p>

<h3 id="the-reloc-section-image-only">The .reloc Section (Image Only)</h3>
<p>The base relocation table contains entries for all base relocations in the image. The Base Relocation Table field in the optional header data directories gives the number of bytes in the base relocation table. For more information, See <a href="#optional-header-data-directories-image-only">Optional Header Data Directories (Image Only)</a>. The base relocation table is divided into blocks. Each block represents the base relocations for a 4K page. Each block must start on a 32-bit boundary.</p>
<p>The loader is not required to process base relocations that are resolved by the linker, unless the load image cannot be loaded at the image base that is specified in the PE header.</p>

<h4 id="base-relocation-block">Base Relocation Block</h4>
<p>Each base relocation block starts with the following structure:</p>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Size</th>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>4</td>
<td>Page RVA</td>
<td>The image base plus the page RVA is added to each offset to create the VA where the base relocation must be applied.</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>Block Size</td>
<td>The total number of bytes in the base relocation block, including the Page RVA and Block Size fields and the Type/Offset fields that follow.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The Block Size field is then followed by any number of Type or Offset field entries. Each entry is a WORD (2 bytes) and has the following structure:</p>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Size</th>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>4 bits</td>
<td>Type</td>
<td>Stored in the high 4 bits of the WORD, a value that indicates the type of base relocation to be applied. For more information, See <a href="#base-relocation-types">Base Relocation Types</a>.</td>
</tr>
<tr>
<td>0</td>
<td>12 bits</td>
<td>Offset</td>
<td>Stored in the remaining 12 bits of the WORD, an offset from the starting address that was specified in the Page RVA field for the block. This offset specifies where the base relocation is to be applied.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>To apply a base relocation, the difference is calculated between the preferred base address and the base where the image is actually loaded. If the image is loaded at its preferred base, the difference is zero and thus the base relocations do not have to be applied.</p>

<h4 id="base-relocation-types">Base Relocation Types</h4>
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>IMAGE_REL_BASED_ABSOLUTE</td>
<td>0</td>
<td>The base relocation is skipped. This type can be used to pad a block.</td>
</tr>
<tr>
<td>IMAGE_REL_BASED_HIGH</td>
<td>1</td>
<td>The base relocation adds the high 16 bits of the difference to the 16-bit field at offset. The 16-bit field represents the high value of a 32-bit word.</td>
</tr>
<tr>
<td>IMAGE_REL_BASED_LOW</td>
<td>2</td>
<td>The base relocation adds the low 16 bits of the difference to the 16-bit field at offset. The 16-bit field represents the low half of a 32-bit word.</td>
</tr>
<tr>
<td>IMAGE_REL_BASED_HIGHLOW</td>
<td>3</td>
<td>The base relocation applies all 32 bits of the difference to the 32-bit field at offset.</td>
</tr>
<tr>
<td>IMAGE_REL_BASED_HIGHADJ</td>
<td>4</td>
<td>The base relocation adds the high 16 bits of the difference to the 16-bit field at offset. The 16-bit field represents the high value of a 32-bit word. The low 16 bits of the 32-bit value are stored in the 16-bit word that follows this base relocation. This means that this base relocation occupies two slots.</td>
</tr>
<tr>
<td>IMAGE_REL_BASED_MIPS_JMPADDR</td>
<td>5</td>
<td>The relocation interpretation is dependent on the machine type.<br> When the machine type is MIPS, the base relocation applies to a MIPS jump instruction.</td>
</tr>
<tr>
<td>IMAGE_REL_BASED_ARM_MOV32</td>
<td>5</td>
<td>This relocation is meaningful only when the machine type is ARM or Thumb. The base relocation applies the 32-bit address of a symbol across a consecutive MOVW/MOVT instruction pair.</td>
</tr>
<tr>
<td>IMAGE_REL_BASED_RISCV_HIGH20</td>
<td>5</td>
<td>This relocation is only meaningful when the machine type is RISC-V. The base relocation applies to the high 20 bits of a 32-bit absolute address.</td>
</tr>
<tr>
<td></td>
<td>6</td>
<td>Reserved, must be zero.</td>
</tr>
<tr>
<td>IMAGE_REL_BASED_THUMB_MOV32</td>
<td>7</td>
<td>This relocation is meaningful only when the machine type is Thumb. The base relocation applies the 32-bit address of a symbol to a consecutive MOVW/MOVT instruction pair.</td>
</tr>
<tr>
<td>IMAGE_REL_BASED_RISCV_LOW12I</td>
<td>7</td>
<td>This relocation is only meaningful when the machine type is RISC-V. The base relocation applies to the low 12 bits of a 32-bit absolute address formed in RISC-V I-type instruction format.</td>
</tr>
<tr>
<td>IMAGE_REL_BASED_RISCV_LOW12S</td>
<td>8</td>
<td>This relocation is only meaningful when the machine type is RISC-V. The base relocation applies to the low 12 bits of a 32-bit absolute address formed in RISC-V S-type instruction format.</td>
</tr>
<tr>
<td>IMAGE_REL_BASED_MIPS_JMPADDR16</td>
<td>9</td>
<td>The relocation is only meaningful when the machine type is MIPS. The base relocation applies to a MIPS16 jump instruction.</td>
</tr>
<tr>
<td>IMAGE_REL_BASED_DIR64</td>
<td>10</td>
<td>The base relocation applies the difference to the 64-bit field at offset.</td>
</tr>
</tbody>
</table>
<p> </p>

<h3 id="the-rsrc-section">The .rsrc Section</h3>
<p>Resources are indexed by a multiple-level binary-sorted tree structure. The general design can incorporate 2**31 levels. By convention, however, Windows uses three levels:</p>
<dl> Type  
Name  
Language  
</dl>
<p>A series of resource directory tables relates all of the levels in the following way: Each directory table is followed by a series of directory entries that give the name or identifier (ID) for that level (Type, Name, or Language level) and an address of either a data description or another directory table. If the address points to a data description, then the data is a leaf in the tree. If the address points to another directory table, then that table lists directory entries at the next level down.</p>
<p>A leaf's Type, Name, and Language IDs are determined by the path that is taken through directory tables to reach the leaf. The first table determines Type ID, the second table (pointed to by the directory entry in the first table) determines Name ID, and the third table determines Language ID.</p>
<p>The general structure of the .rsrc section is:</p>
<table>
<thead>
<tr>
<th>Data</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Resource Directory Tables (and Resource Directory Entries)</td>
<td>A series of tables, one for each group of nodes in the tree. All top-level (Type) nodes are listed in the first table. Entries in this table point to second-level tables. Each second-level tree has the same Type ID but different Name IDs. Third-level trees have the same Type and Name IDs but different Language IDs.<br> Each individual table is immediately followed by directory entries, in which each entry has a name or numeric identifier and a pointer to a data description or a table at the next lower level.</td>
</tr>
<tr>
<td>Resource Directory Strings</td>
<td>Two-byte-aligned Unicode strings, which serve as string data that is pointed to by directory entries.</td>
</tr>
<tr>
<td>Resource Data Description</td>
<td>An array of records, pointed to by tables, that describe the actual size and location of the resource data. These records are the leaves in the resource-description tree.</td>
</tr>
<tr>
<td>Resource Data</td>
<td>Raw data of the resource section. The size and location information in the Resource Data Descriptions field delimit the individual regions of resource data.</td>
</tr>
</tbody>
</table>
<p> </p>

<h4 id="resource-directory-table">Resource Directory Table</h4>
<p>Each resource directory table has the following format. This data structure should be considered the heading of a table because the table actually consists of directory entries (described in section 6.9.2, &quot;Resource Directory Entries&quot;) and this structure:</p>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Size</th>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>4</td>
<td>Characteristics</td>
<td>Resource flags. This field is reserved for future use. It is currently set to zero.</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>Time/Date Stamp</td>
<td>The time that the resource data was created by the resource compiler.</td>
</tr>
<tr>
<td>8</td>
<td>2</td>
<td>Major Version</td>
<td>The major version number, set by the user.</td>
</tr>
<tr>
<td>10</td>
<td>2</td>
<td>Minor Version</td>
<td>The minor version number, set by the user.</td>
</tr>
<tr>
<td>12</td>
<td>2</td>
<td>Number of Name Entries</td>
<td>The number of directory entries immediately following the table that use strings to identify Type, Name, or Language entries (depending on the level of the table).</td>
</tr>
<tr>
<td>14</td>
<td>2</td>
<td>Number of ID Entries</td>
<td>The number of directory entries immediately following the Name entries that use numeric IDs for Type, Name, or Language entries.</td>
</tr>
</tbody>
</table>
<p> </p>

<h4 id="resource-directory-entries">Resource Directory Entries</h4>
<p>The directory entries make up the rows of a table. Each resource directory entry has the following format. Whether the entry is a Name or ID entry is indicated by the resource directory table, which indicates how many Name and ID entries follow it (remember that all the Name entries precede all the ID entries for the table). All entries for the table are sorted in ascending order: the Name entries by case-sensitive string and the ID entries by numeric value. Offsets are relative to the address in the IMAGE_DIRECTORY_ENTRY_RESOURCE DataDirectory. See <a href="https://docs.microsoft.com/previous-versions/ms809762(v=msdn.10)#pe-file-resources" data-linktype="external">Peering Inside the PE: A Tour of the Win32 Portable Executable File Format</a> for more information.</p>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Size</th>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>4</td>
<td>Name Offset</td>
<td>The offset of a string that gives the Type, Name, or Language ID entry, depending on level of table.</td>
</tr>
<tr>
<td>0</td>
<td>4</td>
<td>Integer ID</td>
<td>A 32-bit integer that identifies the Type, Name, or Language ID entry.</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>Data Entry Offset</td>
<td>High bit 0. Address of a Resource Data entry (a leaf).</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>Subdirectory Offset</td>
<td>High bit 1. The lower 31 bits are the address of another resource directory table (the next level down).</td>
</tr>
</tbody>
</table>
<p> </p>

<h4 id="resource-directory-string">Resource Directory String</h4>
<p>The resource directory string area consists of Unicode strings, which are word-aligned. These strings are stored together after the last Resource Directory entry and before the first Resource Data entry. This minimizes the impact of these variable-length strings on the alignment of the fixed-size directory entries. Each resource directory string has the following format:</p>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Size</th>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>2</td>
<td>Length</td>
<td>The size of the string, not including length field itself.</td>
</tr>
<tr>
<td>2</td>
<td>variable</td>
<td>Unicode String</td>
<td>The variable-length Unicode string data, word-aligned.</td>
</tr>
</tbody>
</table>
<p> </p>

<h4 id="resource-data-entry">Resource Data Entry</h4>
<p>Each Resource Data entry describes an actual unit of raw data in the Resource Data area. A Resource Data entry has the following format:</p>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Size</th>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>4</td>
<td>Data RVA</td>
<td>The address of a unit of resource data in the Resource Data area.</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>Size</td>
<td>The size, in bytes, of the resource data that is pointed to by the Data RVA field.</td>
</tr>
<tr>
<td>8</td>
<td>4</td>
<td>Codepage</td>
<td>The code page that is used to decode code point values within the resource data. Typically, the code page would be the Unicode code page.</td>
</tr>
<tr>
<td>12</td>
<td>4</td>
<td>Reserved, must be 0.</td>
<td></td>
</tr>
</tbody>
</table>
<p> </p>

<h3 id="the-cormeta-section-object-only">The .cormeta Section (Object Only)</h3>
<p>CLR metadata is stored in this section. It is used to indicate that the object file contains managed code. The format of the metadata is not documented, but can be handed to the CLR interfaces for handling metadata.</p>

<h3 id="the-sxdata-section">The .sxdata Section</h3>
<p>The valid exception handlers of an object are listed in the<strong>.sxdata</strong> section of that object. The section is marked IMAGE_SCN_LNK_INFO. It contains the COFF symbol index of each valid handler, using 4 bytes per index.</p>
<p>Additionally, the compiler marks a COFF object as registered SEH by emitting the absolute symbol &quot;@feat.00&quot; with the LSB of the value field set to 1. A COFF object with no registered SEH handlers would have the &quot;@feat.00&quot; symbol, but no<strong>.sxdata</strong> section.</p>

<h2 id="archive-library-file-format">Archive (Library) File Format</h2>
<p>The COFF archive format provides a standard mechanism for storing collections of object files. These collections are commonly called libraries in programming documentation.</p>
<p>The first 8 bytes of an archive consist of the file signature. The rest of the archive consists of a series of archive members, as follows:</p>
<ul>
<li><p>The first and second members are &quot;linker members.&quot; Each of these members has its own format as described in section<a href="#import-name-type">Import Name Type</a>. Typically, a linker places information into these archive members. The linker members contain the directory of the archive.</p>
</li>
<li><p>The third member is the &quot;longnames&quot; member. This member consists of a series of null-terminated ASCII strings in which each string is the name of another archive member.</p>
</li>
<li><p>The rest of the archive consists of standard (object-file) members. Each of these members contains the contents of one object file in its entirety.</p>
</li>
</ul>
<p>An archive member header precedes each member. The following list shows the general structure of an archive:</p>
<ul>
<li><p>Signature :&quot;!&lt;arch&gt;\n&quot;</p>
</li>
<li><p>Header</p>
<dl> 1st Linker Member  
</dl>
</li>
<li><p>Header</p>
<dl> 2nd Linker Member  
</dl>
</li>
<li><p>Header</p>
<dl> Longnames Member  
</dl>
</li>
<li><p>Header</p>
<dl> Contents of OBJ File 1  
(COFF format)  
</dl>
</li>
<li><p>Header</p>
<dl> Contents of OBJ File 2  
(COFF format)  
</dl>
</li>
</ul>

<h3 id="archive-file-signature">Archive File Signature</h3>
<p>The archive file signature identifies the file type. Any utility (for example, a linker) that takes an archive file as input can check the file type by reading this signature. The signature consists of the following ASCII characters, in which each character below is represented literally, except for the newline (\n) character:</p>
<p><code>!&lt;arch&gt;\n</code></p>

<h3 id="archive-member-headers">Archive Member Headers</h3>
<p>Each member (linker, longnames, or object-file member) is preceded by a header. An archive member header has the following format, in which each field is an ASCII text string that is left justified and padded with spaces to the end of the field. There is no terminating null character in any of these fields.</p>
<p>Each member header starts on the first even address after the end of the previous archive member.</p>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Size</th>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>16</td>
<td>Name</td>
<td>The name of the archive member, with a slash (/) appended to terminate the name. If the first character is a slash, the name has a special interpretation, as described in the following table.</td>
</tr>
<tr>
<td>16</td>
<td>12</td>
<td>Date</td>
<td>The date and time that the archive member was created: This is the ASCII decimal representation of the number of seconds since 1/1/1970 UCT.</td>
</tr>
<tr>
<td>28</td>
<td>6</td>
<td>User ID</td>
<td>An ASCII decimal representation of the user ID. This field does not contain a meaningful value on Windows platforms because Microsoft tools emit all blanks.</td>
</tr>
<tr>
<td>34</td>
<td>6</td>
<td>Group ID</td>
<td>An ASCII decimal representation of the group ID. This field does not contain a meaningful value on Windows platforms because Microsoft tools emit all blanks.</td>
</tr>
<tr>
<td>40</td>
<td>8</td>
<td>Mode</td>
<td>An ASCII octal representation of the member's file mode. This is the ST_MODE value from the C run-time function _wstat.</td>
</tr>
<tr>
<td>48</td>
<td>10</td>
<td>Size</td>
<td>An ASCII decimal representation of the total size of the archive member, not including the size of the header.</td>
</tr>
<tr>
<td>58</td>
<td>2</td>
<td>End of Header</td>
<td>The two bytes in the C string &quot;˜\n&quot; (0x60 0x0A).</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The Name field has one of the formats shown in the following table. As mentioned earlier, each of these strings is left justified and padded with trailing spaces within a field of 16 bytes:</p>
<table>
<thead>
<tr>
<th>Contents of Name field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>name/</td>
<td>The name of the archive member.</td>
</tr>
<tr>
<td>/</td>
<td>The archive member is one of the two linker members. Both of the linker members have this name.</td>
</tr>
<tr>
<td>//</td>
<td>The archive member is the longnames member, which consists of a series of null-terminated ASCII strings. The longnames member is the third archive member and must always be present even if the contents are empty.</td>
</tr>
<tr>
<td>/n</td>
<td>The name of the archive member is located at offset n within the longnames member. The number n is the decimal representation of the offset. For example: &quot;/26&quot; indicates that the name of the archive member is located 26 bytes beyond the beginning of the longnames member contents.</td>
</tr>
</tbody>
</table>
<p> </p>

<h3 id="first-linker-member">First Linker Member</h3>
<p>The name of the first linker member is &quot;\&quot;. The first linker member is included for backward compatibility. It is not used by current linkers, but its format must be correct. This linker member provides a directory of symbol names, as does the second linker member. For each symbol, the information indicates where to find the archive member that contains the symbol.</p>
<p>The first linker member has the following format. This information appears after the header:</p>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Size</th>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>4</td>
<td>Number of Symbols</td>
<td>Unsigned long that contains the number of indexed symbols. This number is stored in big-endian format. Each object-file member typically defines one or more external symbols.</td>
</tr>
<tr>
<td>4</td>
<td>4 * n</td>
<td>Offsets</td>
<td>An array of file offsets to archive member headers, in which n is equal to the Number of Symbols field. Each number in the array is an unsigned long stored in big-endian format. For each symbol that is named in the string table, the corresponding element in the offsets array gives the location of the archive member that contains the symbol.</td>
</tr>
<tr>
<td>*</td>
<td>*</td>
<td>String Table</td>
<td>A series of null-terminated strings that name all the symbols in the directory. Each string begins immediately after the null character in the previous string. The number of strings must be equal to the value of the Number of Symbols field.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The elements in the offsets array must be arranged in ascending order. This fact implies that the symbols in the string table must be arranged according to the order of archive members. For example, all the symbols in the first object-file member would have to be listed before the symbols in the second object file.</p>

<h3 id="second-linker-member">Second Linker Member</h3>
<p>The second linker member has the name &quot;\&quot; as does the first linker member. Although both linker members provide a directory of symbols and archive members that contain them, the second linker member is used in preference to the first by all current linkers. The second linker member includes symbol names in lexical order, which enables faster searching by name.</p>
<p>The second member has the following format. This information appears after the header:</p>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Size</th>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>4</td>
<td>Number of Members</td>
<td>An unsigned long that contains the number of archive members.</td>
</tr>
<tr>
<td>4</td>
<td>4 * m</td>
<td>Offsets</td>
<td>An array of file offsets to archive member headers, arranged in ascending order. Each offset is an unsigned long . The number m is equal to the value of the Number of Members field.</td>
</tr>
<tr>
<td>*</td>
<td>4</td>
<td>Number of Symbols</td>
<td>An unsigned long that contains the number of symbols indexed. Each object-file member typically defines one or more external symbols.</td>
</tr>
<tr>
<td>*</td>
<td>2 * n</td>
<td>Indices</td>
<td>An array of 1-based indexes (unsigned short ) that map symbol names to archive member offsets. The number n is equal to the Number of Symbols field. For each symbol that is named in the string table, the corresponding element in the Indices array gives an index into the offsets array. The offsets array, in turn, gives the location of the archive member that contains the symbol.</td>
</tr>
<tr>
<td>*</td>
<td>*</td>
<td>String Table</td>
<td>A series of null-terminated strings that name all of the symbols in the directory. Each string begins immediately after the null byte in the previous string. The number of strings must be equal to the value of the Number of Symbols field. This table lists all the symbol names in ascending lexical order.</td>
</tr>
</tbody>
</table>
<p> </p>

<h3 id="longnames-member">Longnames Member</h3>
<p>The name of the longnames member is &quot;\\&quot;. The longnames member is a series of strings of archive member names. A name appears here only when there is insufficient room in the Name field (16 bytes). The longnames member can be empty, though its header must appear.</p>
<p>The strings are null-terminated. Each string begins immediately after the null byte in the previous string.</p>

<h2 id="import-library-format">Import Library Format</h2>
<p>Traditional import libraries, that is, libraries that describe the exports from one image for use by another, typically follow the layout described in section 7,<a href="#archive-library-file-format">Archive (Library) File Format</a>. The primary difference is that import library members contain pseudo-object files instead of real ones, in which each member includes the section contributions that are required to build the import tables that are described in section 6.4,<a href="#the-idata-section">The .idata Section</a> The linker generates this archive while building the exporting application.</p>
<p>The section contributions for an import can be inferred from a small set of information. The linker can either generate the complete, verbose information into the import library for each member at the time of the library's creation or write only the canonical information to the library and let the application that later uses it generate the necessary data on the fly.</p>
<p>In an import library with the long format, a single member contains the following information:</p>
<dl> Archive member header  
File header  
Section headers  
Data that corresponds to each of the section headers  
COFF symbol table  
Strings  
  
</dl>
<p>In contrast, a short import library is written as follows:</p>
<dl> Archive member header  
Import header  
Null-terminated import name string  
Null-terminated DLL name string  
</dl>
<p>This is sufficient information to accurately reconstruct the entire contents of the member at the time of its use.</p>

<h3 id="import-header">Import Header</h3>
<p>The import header contains the following fields and offsets:</p>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Size</th>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>2</td>
<td>Sig1</td>
<td>Must be IMAGE_FILE_MACHINE_UNKNOWN. For more information, See <a href="#machine-types">Machine Types</a>.</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>Sig2</td>
<td>Must be 0xFFFF.</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
<td>Version</td>
<td>The structure version.</td>
</tr>
<tr>
<td>6</td>
<td>2</td>
<td>Machine</td>
<td>The number that identifies the type of target machine. For more information, See <a href="#machine-types">Machine Types</a>.</td>
</tr>
<tr>
<td>8</td>
<td>4</td>
<td>Time-Date Stamp</td>
<td>The time and date that the file was created.</td>
</tr>
<tr>
<td>12</td>
<td>4</td>
<td>Size Of Data</td>
<td>The size of the strings that follow the header.</td>
</tr>
<tr>
<td>16</td>
<td>2</td>
<td>Ordinal/Hint</td>
<td>Either the ordinal or the hint for the import, determined by the value in the Name Type field.</td>
</tr>
<tr>
<td>18</td>
<td>2 bits</td>
<td>Type</td>
<td>The import type. For specific values and descriptions, See <a href="#import-type">Import Type</a>.</td>
</tr>
<tr>
<td></td>
<td>3 bits</td>
<td>Name Type</td>
<td>The import name type. For more information, See <a href="#import-name-type">Import Name Type</a>.</td>
</tr>
<tr>
<td></td>
<td>11 bits</td>
<td>Reserved</td>
<td>Reserved, must be 0.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>This structure is followed by two null-terminated strings that describe the imported symbol's name and the DLL from which it came.</p>

<h3 id="import-type">Import Type</h3>
<p>The following values are defined for the Type field in the import header:</p>
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>IMPORT_CODE</td>
<td>0</td>
<td>Executable code.</td>
</tr>
<tr>
<td>IMPORT_DATA</td>
<td>1</td>
<td>Data.</td>
</tr>
<tr>
<td>IMPORT_CONST</td>
<td>2</td>
<td>Specified as CONST in the .def file.</td>
</tr>
</tbody>
</table>
<p>These values are used to determine which section contributions must be generated by the tool that uses the library if it must access that data.</p>

<h3 id="import-name-type">Import Name Type</h3>
<p>The null-terminated import symbol name immediately follows its associated import header. The following values are defined for the Name Type field in the import header. They indicate how the name is to be used to generate the correct symbols that represent the import:</p>
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>IMPORT_ORDINAL</td>
<td>0</td>
<td>The import is by ordinal. This indicates that the value in the Ordinal/Hint field of the import header is the import's ordinal. If this constant is not specified, then the Ordinal/Hint field should always be interpreted as the import's hint.</td>
</tr>
<tr>
<td>IMPORT_NAME</td>
<td>1</td>
<td>The import name is identical to the public symbol name.</td>
</tr>
<tr>
<td>IMPORT_NAME_NOPREFIX</td>
<td>2</td>
<td>The import name is the public symbol name, but skipping the leading ?, @, or optionally _.</td>
</tr>
<tr>
<td>IMPORT_NAME_UNDECORATE</td>
<td>3</td>
<td>The import name is the public symbol name, but skipping the leading ?, @, or optionally _, and truncating at the first @.</td>
</tr>
</tbody>
</table>


</body>
</html>
