<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>TUTORIAL:</title>
</head>
<body bgcolor="#FFFFFF">

<h2><a name="_Toc353946308">
</a><a name="RTFToC18">1.5.
CONSIDERAÇÕES
C++:</a> 
</h2>
<p>
	Neste tópico iremos explicar recursos mais particulares de C++,
porém não menos importantes para a programação
orientada a objetos na linguagem. Alguns recursos como const que está
relacionado com encapsulamento poderão ser retirados deste tópico
em novas versões do tutorial.
<a name="_Ref342381426">
</a></p><h3><a name="_Ref342381426">
</a><a name="RTFToC19">1.5.1.
</a><a name="_Ref342702773"></a><a name="_Toc342736958"></a><a name="_Toc345409404"></a><a name="_Toc345810909"></a><a name="_Toc345838229"></a><a name="_Toc345942364"></a><a name="_Toc345949524"></a><a name="_Toc346168641"></a><a name="_Toc348417084"></a><a name="_Toc348931340"></a><a name="_Toc353900779"></a><a name="_Toc353946309">
CONST</a>
</h3>
<p>
	Este exemplo mostra o uso de funções const e sua
importância para o encapsulamento. <code>Const</code> pode
qualificar um parâmetro de função (assegurando que este
não será modificado),  uma função membro
(assegurando que esta não modifica os dados membro de sua classe), ou
uma instância de objeto/tipo (assegurando que este não será
modificado.)</p><p>
	Os modos de qualificação descritos atuam em conjunto, para
assegurar que um objeto const não será modificado, C++ só
permite que sejam chamados para este objeto funções membro
qualificadas como <code>const. Const </code>é também
um qualificador, "specifier".</p><p>
<code></code></p><p><code>
</code></p><p><code>
<b></b></code></p><hr><p><code>
</code></p><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
#include &lt;math.h&gt;</code></p><p><code>
//double sqrt(double x); de math.h retorna raiz quadrada do numero</code></p><p><code>
//double pow(double x, double y); de math.h calcula x a potencia de y</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
const float ZERO=0.0;</code></p><p><code>
</code></p><p><code>
class ponto</code></p><p><code>
{</code></p><p><code>
private:</code></p><p><code>
float x;</code></p><p><code>
//sao ocultos por default nao precisaria private mas e' bom</code></p><p><code>
float y;</code></p><p><code>
//sao ocultos por default</code></p><p><code>
public:</code></p><p><code>
//daqui em diante tudo e acessivel em main.</code></p><p><code>
</code></p><p><code>
ponto(float a,float b)</code></p><p><code>
 {  x=a; y=b; }</code></p><p><code>
</code></p><p><code>
void mostra(void) const</code></p><p><code>
 {cout &lt;&lt; "X:" &lt;&lt; x &lt;&lt; " , Y:" &lt;&lt; y &lt;&lt; endl;}</code></p><p><code>
</code></p><p><code>
float distancia(const ponto hi) const</code></p><p><code>
 {</code></p><p><code>
  return</code></p><p><code>
	float(</code></p><p><code>
		  sqrt(</code></p><p><code>
				  (</code></p><p><code>
					 pow(double(hi.x-x),2.0)</code></p><p><code>
					 +</code></p><p><code>
					 pow(double(hi.y-y),2.0)</code></p><p><code>
				  )</code></p><p><code>
				)</code></p><p><code>
		  );</code></p><p><code>
  //teorema de Pitagoras</code></p><p><code>
 }</code></p><p><code>
</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
void main()</code></p><p><code>
{</code></p><p><code>
ponto ap(3.0,4.0);</code></p><p><code>
//instanciacao</code></p><p><code>
ap.mostra();</code></p><p><code>
//funcoes membro public</code></p><p><code>
const ponto origem(ZERO,ZERO);</code></p><p><code>
//defino objeto constante</code></p><p><code>
origem.mostra();</code></p><p><code>
cout &lt;&lt; "Distancia da origem:" &lt;&lt; origem.distancia(ap); </code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
<b></b></code></p><hr><p><code>
</code></p><p>
</p><p>
<b>Resultado do programa:</b></p><p>
<b></b>X:3 , Y:4</p><p>
X:0 , Y:0</p><p>
Distancia da origem:5</p><p>
</p><p>
<b>Comentários:</b></p><p>
<b></b>Const qualificando instâncias de objetos/tipos: <code></code></p><p><code>
const ponto origem(ZERO,ZERO);</code></p><p><code>
const float ZERO=0.0;</code></p><p><code>
</code></p><p>
Const qualificando funções: <code></code></p><p><code>
float distancia(const ponto hi) <b>const</b>;</code></p><p><code>
</code></p><p>
Const qualificando argumentos: <code></code></p><p><code>
float distancia(<b>const</b> ponto hi) const;</code></p><p><code>
</code></p><p>
<b>Exercícios:</b></p><p>
1)Use tudo o que você aprendeu sobre const na classe reta, definida em
CONSTRUTORES E AGREGAÇÃO 1.2.7. </p><p>
<a name="_Ref342132315"></a><a name="_Toc342736959"></a><a name="_Toc345409405"></a><a name="_Toc345810910"></a><a name="_Toc345838230"></a><a name="_Toc345942365"></a><a name="_Toc345949525"></a><a name="_Toc346168642"></a><a name="_Toc348417085"></a><a name="_Toc348931341"></a><a name="_Toc353900780"></a><a name="_Toc353946310">
</a></p><h3><a name="_Toc353946310">
</a><a name="RTFToC20">1.5.2.
FUNÇÕES
INLINE</a>
</h3>
<b></b><p>
<b>Requisitos</b>: </p><p>
	Saber como um programa se comporta na memória, em termos de chamadas de
função e gerenciamento da pilha, "stack".</p><p>
<b>	</b>O que são funções inline: Imagine uma chamada de
uma função membro void altera_raio(float a)  da classe circulo
já apresentada, <code>ac.altera_raio(a). </code> Esta
chamada envolve a passagem de parâmetros, inserção da
função na pilha (stack), retorno de um valor <code> (void),
</code> tudo isso representa uma diminuição da velocidade
do programa com relação a um simples: <code>ac.raio=a;
</code>que nesse caso funcionaria muito bem.</p><p>
	Ocorre que nós desejamos usar chamadas de métodos, vimos
inclusive meios de esconder, encapsular o atributo raio para que a única
alternativa para alterar seu valor seja através da chamada de
<code>altera_raio(a). </code> Porque programar desta forma? Porque
é mais seguro, mais próximo dos princípios de
orientação a objetos. Em verdade POO se caracteriza por muitas
chamadas de métodos e uso do "heap", área de memória usada
pela alocação dinâmica.</p><p>
	O que as funções declaradas como inline fazem é traduzir
a chamada do método em tempo de compilação em um
equivalente <code>ac.raio=17.0. </code>evitando  todo o contratempo
descrito. Essa tradução do método é colocada na
sequência de código do programa, você pode ter vários
trechos que chamariam funções,  desviariam o fluxo do programa
até o retorno desta, convertidos em instruções simples.
Como desvantagem temos o aumento do tamanho do programa, visto que
passarão a existir várias cópias diferentes da
função no programa (uma para cada argumento) ao envés de
um só protótipo de função que era colocado na pilha
no momento da chamada e então tinha os argumentos substituídos.</p><p>
	Nos programa anteriores sobre a classe círculo, se a
função membro mostra fosse <code>inline
</code>haveria uma conversão da chamada interna (dentro de mostra)
de <code>retorna_raio()</code>em simplesmente<code> ac.raio.
</code> Pode haver conversão de várias
funções<code> inline</code> aninhadas, estas
conversões são seguras, porque são feitas pelo
compilador.</p><p>
	Normalmente é vantajoso usar<code> inline</code> para
funções pequenas que não aumentem muito o tamanho do
programa ou funções onde velocidade é crucial. Aqui vale a
conhecida regra  80:20, oitenta porcento do tempo do programa é gasto em
vinte por cento dos métodos. Porém o programador não
precisa se preocupar muito com funções <code>inline
</code>na fase de desenvolvimento, este é um recurso C++ para
aumento de eficiência que pode muito bem ser deixado para o final do
projeto. Saiba porém que as diferenças de tempo decorrentes de
seu uso são sensíveis.</p><p>
</p><p>
	Este exemplo explora as possibilidades que temos para declarar
funções membro e como declará-las para que sejam do
tipo<code> inline: </code><code></code></p><p><code>
<b></b></code></p><hr><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
</code></p><p><code>
struct ponto</code></p><p><code>
{</code></p><p><code>
float x;</code></p><p><code>
float y;</code></p><p><code>
</code></p><p><code>
void inicializa(float a,float b)</code></p><p><code>
 {  x=a; y=b; } //Apesar de nao especificado compilador tenta</code></p><p><code>
 //expandir chamada da funcao como inline porque esta dentro da definicao da
classe.</code></p><p><code>
</code></p><p><code>
void mostra(void); //com certeza nao e' inline, externa a classe e sem
qualificador.</code></p><p><code>
inline void move(float dx,float dy); //e' inline , prototipo, definicao</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
void ponto::mostra(void)</code></p><p><code>
{cout &lt;&lt; "X:" &lt;&lt; x &lt;&lt; " , Y:" &lt;&lt; y &lt;&lt; endl;}</code></p><p><code>
</code></p><p><code>
inline void ponto::move(float dx,float dy) //implementacao, codigo</code></p><p><code>
{</code></p><p><code>
 x+=dx;</code></p><p><code>
 y+=dy;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
void main()</code></p><p><code>
{</code></p><p><code>
ponto ap;</code></p><p><code>
ap.inicializa(0.0,0.0);</code></p><p><code>
ap.mostra();</code></p><p><code>
ap.move(1.0,1.0);</code></p><p><code>
ap.mostra();</code></p><p><code>
ap.x=100.0;</code></p><p><code>
ap.mostra();</code></p><p><code>
}</code></p><p><code>
</code></p><p>
<b></b></p><hr><p>
<b>Comentários</b>: </p><p>
	O compilador tenta converter a função<code>
inicializa</code> em<code> inline, </code> embora não
esteja especificado com a palavra reservada inline que isto é para ser
feito. Esta é uma regra, sempre que a função estiver
definida na própria classe <code> (struct{}) </code>o
compilador tentará convertê-la em <code>inline.
</code> Foi dito que o compilador tenta porque isto pode variar de
compilador para compilador, se ele não consegue converter em
<code>inline</code> , devido a complexidade da
função, você é normalmente  avisado, tendo que
trocar o lugar da definição da função membro. </p><p>
	Note que se a função membro é implementada fora da
classe, tanto o protótipo da função membro, quanto a
implementação devem vir especificados com<code>
inline</code> para que a conversão ocorra.</p><p>
</p><p>
<b>Resultado do programa:</b> </p><p>
X:0 , Y:0</p><p>
X:1 , Y:1</p><p>
X:100 , Y:1<b></b></p><p>
<b>
<a name="_Ref342134358"></a></b><a name="_Ref342134358">
</a></p><h3><a name="_Ref342134358">
</a><a name="RTFToC21">1.5.3.
</a><a name="_Ref342297067"></a><a name="_Toc342736960"></a><a name="_Toc345409406"></a><a name="_Toc345810911"></a><a name="_Toc345838231"></a><a name="_Toc345942366"></a><a name="_Toc345949526"></a><a name="_Toc346168643"></a><a name="_Toc348417086"></a><a name="_Toc348931342"></a><a name="_Toc353900781"></a><a name="_Toc353946311">
ALOCAÇÃO DINÂMICA COM NEW E
DELETE</a>.
</h3>
<p>
	Neste tópico serão apresentados os recursos de C++ para
alocação dinâmica de variáveis de tipos simples e
objetos, ou seja, estudaremos a alocação de estruturas em tempo
de execução.</p><p>
<a name="_Ref342376580"></a><a name="_Toc342736961"></a><a name="_Toc345838232"></a><a name="_Toc345942367"></a><a name="_Toc345949527"></a><a name="_Toc346168644"></a><a name="_Toc348417087"></a><a name="_Toc348931343"></a><a name="_Toc353900782"></a><a name="_Toc353946312">
</a></p><h4><a name="_Toc353946312">
</a><a name="RTFToC22">1.5.3.1.
PONTEIROS, "POINTERS"</a>
</h4>
<i></i><p>
<i></i>	Este exemplo mostra como trabalhar com ponteiros para variáveis
de tipos pré-definidos (não definidos pelo usuário)
usando<code> new e delete. </code></p><p>
</p><p>
	O programa a seguir cria um ponteiro para uma variável inteira, aloca
memória para esta variável e imprime seu valor. <code></code></p><p><code>
<b></b></code></p><hr><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
void main()</code></p><p><code>
{</code></p><p><code>
int* a;</code></p><p><code>
//declara um ponteiro para endereco de variavel inteira</code></p><p><code>
</code></p><p><code>
a=new int(3);</code></p><p><code>
//aloca memoria para o  apontado por a, gravando neste o valor 3</code></p><p><code>
</code></p><p><code>
cout &lt;&lt; (*a) &lt;&lt; endl ;</code></p><p><code>
//imprime o valor do apontado por a</code></p><p><code>
</code></p><p><code>
delete a;</code></p><p><code>
//desaloca memoria</code></p><p><code>
}</code></p><p><code>
<b></b></code></p><hr><p><code>
</code><b></b></p><p>
<b>Resultado do programa:</b></p><p>
<b></b>3</p><p>
<b></b>

</p><pre>Diagrama das variáveis na memória:                                                            <center><img src="TUTORIAL_unicamp_c++_files/pointer.gif"></center>

</pre>
<b></b><p>
<b></b></p><p>
<b>Comentários: </b></p><p>
	Se a fosse uma <code>struct </code>ou <code>class
</code>e tivesse um dado membro chamado<code> dd</code>,
poderíamos obter o valor de <code>dd </code>através
de <code> (*a).dd </code>que pode ser todo abreviado em
<code>a-&gt;dd</code> onde<code> -&gt;</code> é
uma seta, ou flecha que você pode ler como "o apontado" novamente. Os
parênteses em <code> (*a).dd </code>são
necessários devido a precedência do operador . com
relação ao<code> *</code>. Esta sintaxe abreviada
será bastante usada quando alocarmos dinamicamente objetos.</p><p>
<i></i></p><p>
<i></i><b>Observação:</b> <code></code></p><p><code>
int* a;</code></p><p><code>
a=new int(3);</code></p><p><code>
</code></p><p>
pode ser abreviado por:</p><p>
<code></code></p><p><code>
int* a=new int(3);</code></p><p><code>
</code><b></b>
</p><h4>
<a name="RTFToC23">1.5.3.2.
</a><a name="_Ref342371105"></a><a name="_Toc342736962"></a><a name="_Toc345838233"></a><a name="_Toc345942368"></a><a name="_Toc345949528"></a><a name="_Toc346168645"></a><a name="_Toc348417088"></a><a name="_Toc348931344"></a><a name="_Toc353900783"></a><a name="_Toc353946313">
VETORES CRIADOS ESTATICAMENTE</a>
</h4>
<p>
	O exemplo a seguir aloca estaticamente, em tempo de compilação,
um vetor de inteiros com três posições. Em seguida,
gravamos as três posições e as mostramos na tela:
<code></code></p><p><code>
<b></b></code></p><hr><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
</code></p><p><code>
void main()</code></p><p><code>
{</code></p><p><code>
int a[3];</code></p><p><code>
//aloca o vetor de tamanho 3,  estaticamente</code></p><p><code>
</code></p><p><code>
a[0]=1;</code></p><p><code>
//atribui a posicao indice 0 do vetor</code></p><p><code>
</code></p><p><code>
a[1]=2;</code></p><p><code>
//atribui 2 a posicao indice 1 do vetor</code></p><p><code>
</code></p><p><code>
a[2]=3;</code></p><p><code>
//atribui 3 a posicao indice 2 do vetor</code></p><p><code>
</code></p><p><code>
cout &lt;&lt; a[0] &lt;&lt; " " &lt;&lt; a[1] &lt;&lt; " " &lt;&lt; a[2]
&lt;&lt; endl;</code></p><p><code>
//mostra o vetor</code></p><p><code>
}</code></p><p><code>
</code></p><p>
<b></b></p><hr><p>
<b>Resultado do programa:</b></p><p>
<b></b>1 2 3</p><p>
</p><p>
<b>Resumo da sintaxe de vetores:</b> <code><b></b></code></p><p><code>
<b></b>int a[3]; //cria um vetor de inteiros a com tres posicoes, indices uteis
de 0 ate 2</code></p><p><code>
float b[9]; //cria um vetor de float b com nove posicoes, indices uteis de 0
ate 8</code></p><p><code>
</code></p><p><code>
b[8]=3.14156295; //grava 3.1415... na ultima posicao do vetor b</code></p><p><code>
</code></p><p><code>
if (b[5]==2.17) { /*acao*/} ; //teste de igualdade</code></p><p><code>
</code></p><p>
<b>Diagrama do vetor:</b></p><p>
<b></b></p><p>
<b></b></p><p>
<b>	</b></p><p>
<b>	</b>Perceba que a faixa útil do vetor vai de 0 até (n-1) onde
n é o valor dado como tamanho do vetor no momento de sua
criação, no nosso caso 3. </p><p>
	Nada impede que você grave ou leia índices fora dessa área
útil, isso é muito perigoso, porque  fora dessa área, o
que você tem são outras variáveis de memória e
não o espaço reservado para seu vetor. É perfeitamente
aceitável, embora desastroso escrever em nosso programa<code>
a[4]=3;. </code> O compilador calcula o endereço de memória
da posição 4 com base na posição inicial do vetor e
o tamanho do tipo alocado. Após calculado o endereço da
posição 4 o valor 3 é copiado, apagando o conteúdo
anterior!</p><p>
</p><p>
<b>Comentários:</b> </p><p>
	Note que não estamos usando ponteiros neste exemplo e é por isso
que o vetor é alocado estaticamente, em tempo de
compilação, é também por este motivo que o
argumento que vai no lugar do 3 no código <code>int a[3];
</code>deve ser uma expressão constante e não uma
variável.</p><p>
<b></b>
</p><h4>
<a name="RTFToC24">1.5.3.3.
</a><a name="_Ref342371083"></a><a name="_Toc342736963"></a><a name="_Toc345838234"></a><a name="_Toc345942369"></a><a name="_Toc345949529"></a><a name="_Toc346168646"></a><a name="_Toc348417089"></a><a name="_Toc348931345"></a><a name="_Toc353900784"></a><a name="_Toc353946314">
COPIA DE OBJETOS COM VETORES ALOCADOS
ESTATICAMENTE.</a>
</h4>
<b>	</b><p>
<b>	</b>No primeiro exemplo do TAD fração vimos que o compilador
fornece cópia bit a bit para objetos, alertamos também sobre o
perigo de usar este tipo de cópia em conjunto com alocação
dinâmica. O exemplo seguinte mostra um caso onde esta cópia
oferecida pelo compilador é segura, o tópico seguinte 1.5.3.4
mostra um caso onde esta cópia não é segura, leia ambos
para ter uma visão geral do assunto: <code></code></p><p><code>
<b></b></code></p><hr><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
</code></p><p><code>
class vetor_tres</code></p><p><code>
{</code></p><p><code>
public:</code></p><p><code>
 int vet[3];</code></p><p><code>
//vetor alocado estaticamente numa classe.</code></p><p><code>
</code></p><p><code>
 vetor_tres(int a,int b,int c)</code></p><p><code>
 { vet[0]=a; vet[1]=b; vet[2]=c; }</code></p><p><code>
//construtor do vetor</code></p><p><code>
</code></p><p><code>
 void mostra(void)</code></p><p><code>
 { cout &lt;&lt; vet[0] &lt;&lt; " " &lt;&lt; vet[1] &lt;&lt; " " &lt;&lt;
vet[2] &lt;&lt; endl;}</code></p><p><code>
//funcao membro para mostrar o conteudo do vetor</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
void main()</code></p><p><code>
{</code></p><p><code>
vetor_tres v1(1,2,3);</code></p><p><code>
//criacao de um objeto vetor.</code></p><p><code>
</code></p><p><code>
vetor_tres v2(15,16,17);</code></p><p><code>
//criacao de um objeto vetor.</code></p><p><code>
</code></p><p><code>
v1.mostra();</code></p><p><code>
//mostrando o conteudo de v1.</code></p><p><code>
</code></p><p><code>
v2.mostra();</code></p><p><code>
//mostrando o conteudo de v2.</code></p><p><code>
</code></p><p><code>
v2=v1;</code></p><p><code>
//atribuindo objeto v1 ao objeto v2.</code></p><p><code>
</code></p><p><code>
v2.mostra();</code></p><p><code>
//mostrando v2 alterado.</code></p><p><code>
</code></p><p><code>
v1.vet[0]=44;</code></p><p><code>
</code></p><p><code>
v1.mostra();</code></p><p><code>
//mostrando o conteudo de v1.</code></p><p><code>
</code></p><p><code>
v2.mostra();</code></p><p><code>
//mostrando o conteudo de v2.</code></p><p><code>
}</code></p><p><code>
<b></b></code></p><hr><p><code>
</code></p><p>
<b>Resultado do programa:</b></p><p>
<b></b>1 2 3</p><p>
15 16 17</p><p>
1 2 3</p><p>
44 2 3</p><p>
1 2 3</p><p>
</p><p>
<b>Comentários:</b> </p><p>
	Perceba que no caso de alocação estática, quando o
tamanho do vetor é conhecido em tempo de compilação a
cópia é segura. Por cópia segura entenda: as
posições do vetor são copiadas uma a uma e os objetos
não ficam fazendo referência a um mesmo vetor, isto pode ser visto
no resultado do programa, quando alteramos a cópia de <code>v1,
v1</code> não se altera.</p><p>

</p><h4>
<a name="RTFToC25">1.5.3.4.
</a><a name="_Ref342353774"></a><a name="_Toc342736964"></a><a name="_Toc345838235"></a><a name="_Toc345942370"></a><a name="_Toc345949530"></a><a name="_Toc346168647"></a><a name="_Toc348417090"></a><a name="_Toc348931346"></a><a name="_Toc353900785"></a><a name="_Toc353946315">
VETORES CRIADOS DINAMICAMENTE</a>
</h4>
<b></b><p>
<b></b>	O exemplo a seguir é análogo ao de 1.5.3.2, mas os
vetores são alocados dinamicamente, ou seja, você determina em
tempo de execução qual o tamanho do vetor, Pascal não
permite isso.</p><p>
	<code></code></p><p><code>
<b></b></code></p><hr><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
</code></p><p><code>
void main()</code></p><p><code>
{</code></p><p><code>
int tamanho;</code></p><p><code>
//armazena o tamanho do vetor a criar.</code></p><p><code>
int* vet;</code></p><p><code>
//ponteiro para inteiro ou vetor de inteiro ainda nao criado</code></p><p><code>
</code></p><p><code>
cout &lt;&lt; "Entre com o tamanho do vetor a criar";</code></p><p><code>
cin &gt;&gt; tamanho;</code></p><p><code>
</code></p><p><code>
vet=new int[tamanho];</code></p><p><code>
//alocando vetor de "tamanho" posicoes comecando em a[0]</code></p><p><code>
</code></p><p><code>
for (int i=0;i&lt;tamanho;i++)</code></p><p><code>
{</code></p><p><code>
cout &lt;&lt; "Entre com o valor da posicao " &lt;&lt; i &lt;&lt; ":";</code></p><p><code>
cin &gt;&gt; vet[i];</code></p><p><code>
cout &lt;&lt; endl;</code></p><p><code>
}</code></p><p><code>
//loop de leitura no vetor</code></p><p><code>
</code></p><p><code>
for (int j=0;j&lt;tamanho;j++)</code></p><p><code>
{</code></p><p><code>
cout &lt;&lt; "Posicao " &lt;&lt; j &lt;&lt; ":" &lt;&lt; vet[j]&lt;&lt;endl;</code></p><p><code>
}</code></p><p><code>
//loop de impressao do vetor</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
}</code></p><p><code>
</code></p><p>
<b></b></p><hr><i></i><p>
<i></i><b>Resultado do programa:</b></p><p>
<b></b>Entre com o tamanho do vetor a criar3</p><p>
Entre com o valor da posicao 0:1</p><p>
</p><p>
Entre com o valor da posicao 1:2</p><p>
</p><p>
Entre com o valor da posicao 2:3</p><p>
</p><p>
Posicao 0:1</p><p>
Posicao 1:2</p><p>
Posicao 2:3</p><p>
</p><p>
<b>Comentários:</b> <code><b></b></code></p><p><code>
<b></b>int* a;</code></p><p><code>
</code></p><p><code>
Declara um ponteiro para inteiro.</code></p><p><code>
</code></p><p><code>
a=new int[10];</code></p><p><code>
</code></p><p>
Diferente de <code>new int(10); </code>os colchetes indicam que
é para ser criado um vetor de tamanho 10 e não uma
variável de valor 10 como em 1.5.3.1. Ao contrário de
alocação estática, o parâmetro que vai no lugar do
valor 10 não precisa ser uma expressão constante.</p><p>
<code><b></b></code></p><p><code>
<b></b>int* a;</code></p><p><code>
a=new int[10];</code></p><p><code>
</code></p><p>
equivale a forma abreviada:</p><p>
<code></code></p><p><code>
int* a=new int[10];</code></p><p><code>
</code></p><p>
A faixa de índices úteis do vetor novamente vai de 0 até
(10-1) ou (n-1).</p><p>
<b></b>
</p><h4>
<a name="RTFToC26">1.5.3.5.
</a><a name="_Ref342451473"></a><a name="_Toc342736965"></a><a name="_Toc345838236"></a><a name="_Toc345942371"></a><a name="_Toc345949531"></a><a name="_Toc346168648"></a><a name="_Toc348417091"></a><a name="_Toc348931347"></a><a name="_Toc353900786"></a><a name="_Toc353946316">
COPIA DE OBJETOS COM VETORES ALOCADOS
DINAMICAMENTE.</a>
</h4>
<p>
	Essa determinação do tamanho do vetor em tempo de
execução vai tornar a cópia de objetos feita pelo
compilador diferente, ele vai copiar o ponteiro para o vetor, ou seja os
objetos passam a compartilhar a estrutura na memória, o que nem sempre
pode ser desejável! Existem maneiras de redefinir esta cópia
feita pelo compilador o que veremos em 0.</p><p>
<code></code></p><p><code>
<b></b></code></p><hr><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
</code></p><p><code>
class vetor_tres</code></p><p><code>
{</code></p><p><code>
public:</code></p><p><code>
 int* vet;</code></p><p><code>
//vetor alocado estaticamente numa classe.</code></p><p><code>
</code></p><p><code>
 vetor_tres(int a,int b,int c)</code></p><p><code>
 {</code></p><p><code>
  vet=new int[3];</code></p><p><code>
  vet[0]=a;</code></p><p><code>
  vet[1]=b;</code></p><p><code>
  vet[2]=c;</code></p><p><code>
 }</code></p><p><code>
//construtor do vetor</code></p><p><code>
</code></p><p><code>
 void mostra(void)</code></p><p><code>
 { cout &lt;&lt; vet[0] &lt;&lt; " " &lt;&lt; vet[1] &lt;&lt; " " &lt;&lt;
vet[2] &lt;&lt; endl;}</code></p><p><code>
//funcao membro para mostrar o conteudo do vetor</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
void main()</code></p><p><code>
{</code></p><p><code>
vetor_tres v1(1,2,3);</code></p><p><code>
//criacao de um objeto vetor.</code></p><p><code>
</code></p><p><code>
vetor_tres v2(15,16,17);</code></p><p><code>
//criacao de um objeto vetor.</code></p><p><code>
</code></p><p><code>
v1.mostra();</code></p><p><code>
//mostrando o conteudo de v1.</code></p><p><code>
</code></p><p><code>
v2.mostra();</code></p><p><code>
//mostrando o conteudo de v2.</code></p><p><code>
</code></p><p><code>
v2=v1;</code></p><p><code>
//atribuindo objeto v1 ao objeto v2.</code></p><p><code>
</code></p><p><code>
v2.mostra();</code></p><p><code>
//mostrando v2 alterado.</code></p><p><code>
</code></p><p><code>
v1.vet[0]=44;</code></p><p><code>
</code></p><p><code>
v1.mostra();</code></p><p><code>
//mostrando o conteudo de v1.</code></p><p><code>
</code></p><p><code>
v2.mostra();</code></p><p><code>
//mostrando o conteudo de v2.</code></p><p><code>
}</code></p><p><code>
<b></b></code></p><hr><p><code>
</code></p><p>
<b>Resultado do programa:</b></p><p>
<b></b>1 2 3</p><p>
15 16 17</p><p>
1 2 3</p><p>
44 2 3</p><p>
44 2 3</p><p>
</p><p>
<b>Comentários: </b></p><p>
<b>	</b>Note que quando alteramos a cópia de v1, v1 se altera. Isto
ocorre porque  o vetor não é copiado casa a casa como em 1.5.3.3,
só se copia o ponteiro para a posição inicial do vetor,  a
partir do qual se calcula os endereços das posições
seguintes <code>v[3]==*(v+3). </code></p><p>
</p><p>
	Sobre o texto acima: "a partir do qual se calcula os endereços das
posições seguintes", veja o programa exemplo: <code></code></p><p><code>
<b></b></code></p><hr><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
</code></p><p><code>
void main()</code></p><p><code>
{</code></p><p><code>
int* v;</code></p><p><code>
v=new int[3];</code></p><p><code>
</code></p><p><code>
cout &lt;&lt; *(v+1)&lt;&lt;endl;</code></p><p><code>
//imprime o lixo contido na memoria de v[1]</code></p><p><code>
</code></p><p><code>
cout &lt;&lt; v[1] &lt;&lt;endl;</code></p><p><code>
//imprime o lixo contido na memoria de v[1]</code></p><p><code>
</code></p><p><code>
//*(v)==v[0] é uma expressao sempre verdadeira</code></p><p><code>
}</code></p><p><code>
<b></b></code></p><hr><p><code>
</code></p><p>
<b>Resultado do programa:</b></p><p>
<b></b>152</p><p>
152</p><p>
</p><p>
<b>Comentários:</b> </p><p>
	O que é importante deste exercício é que só se
armazena a posição inicial do vetor, as outras
posições são calculadas com base no tamanho do tipo
alocado e regras de aritmética de ponteiros. Não podemos nos
estender muito neste tema, leia sobre aritmética de ponteiros,
porém para este tutorial, basta usar os vetores de forma que esta
aritmética fique por conta da linguagem.</p><p>
	Vetores alocados dinamicamente e ponteiros são a mesma coisa, isto pode
ser visto nesse programa exemplo que mistura a sintaxe de vetores e de
ponteiros. </p><p>
 <b></b>
</p><h4>
<a name="RTFToC27">1.5.3.6.
</a><a name="_Ref342454699"></a><a name="_Toc342736966"></a><a name="_Toc345838237"></a><a name="_Toc345942372"></a><a name="_Toc345949532"></a><a name="_Toc346168649"></a><a name="_Toc348417092"></a><a name="_Toc348931348"></a><a name="_Toc353900787"></a><a name="_Toc353946317">
TAD E ALOCAÇÃO
DINÂMICA.</a>
</h4>
<p>
Tipo abstrato de dados vetor.</p><p>
</p><p>
	Um dos grandes problemas de trabalhar com vetores comuns de C++<code> (
int * a; a=new int[10]; a[22]=3; ) </code>é que
freqüentemente lemos índices inválidos, ou pior gravamos
encima deles.</p><p>
	Gravar encima de um índice fora dos limites de um vetor é um
erro freqüente em programação C++. Saiba que fazendo isso
você pode estar apagando instruções de outros programas na
memória e outras informações importantes! Em alguns casos
quando isso ocorre obtém-se inclusive mensagens do sistema operacional
avisando que algo está errado e que é necessário
reinicializar a máquina. </p><p>
</p><p>
<b>Curiosidade</b>:</p><p>
	Houve um caso de vírus na internet que se baseava no acesso a
índices fora de um vetor para gravar por cima de
instruções do sistema operacional, código que garantisse a
sua multiplicação.</p><p>
	Algumas linguagens de programação como Pascal e Módula-3
checam os índices para que não se acesse áreas
inválidas de um vetor. Módula-3 fornece inclusive os limites dos
vetores simples da linguagem através de chamadas<code> last(vetor)
ou first(vetor) </code> . Em C++ tal tipo de checagem pode ser
implementada pelo programador como faremos neste exemplo.</p><p>
</p><p>
<b>Dica de Programação:</b></p><p>
<b>	</b>Lembre-se: seu sucesso em programação vai depender em
muito de sua disciplina e organização tenha sempre em mente que
C++ é uma linguagem poderosa e que se não usada corretamente pode
criar transtornos e erros não perceptíveis em testes do programa.
</p><p>
	Não checar os índices de um vetor em programas grandes é
como instalar uma bomba relógio em seu código, é muito
provável que em algum instante você ou até mesmo outra
pessoa usando seu programa se distraia e acabe por escrever uma rotina que
acessa um índice inválido de um vetor, fazendo na maioria das
vezes o programa falhar.</p><p>
	A proposta deste exemplo é criar um tipo abstrato de dados vetor com
uma interface flexível que sirva para várias
aplicações e possa ser facilmente estendida. Este exemplo
é simples e vai ser reapresentado com  muitas melhorias no decorrer do
tutorial, dentre elas: "templates" 4.3, "exception handling" 4.5,  e a
criação de uma classe iterador para o vetor4.1 . A primeira vista
você pode achar que este programa não oferece muito mais que o uso
comum de vetores em C++, mas com as melhorias que apresentaremos, certamente
você vai preferir representar vetores como tipos abstratos de dados ou
TAD's.</p><p>
<code></code></p><p><code>
<b></b></code></p><hr><p><code>
//file exvet1.h</code></p><p><code>
//header file para classe vetor </code></p><p><code>
const int inicio=0;</code></p><p><code>
</code></p><p><code>
class vetor{</code></p><p><code>
private:</code></p><p><code>
int* v;            </code></p><p><code>
//este e' o vetor</code></p><p><code>
int tamanho;  </code></p><p><code>
//tamanho maximo do vetor,</code></p><p><code>
public:</code></p><p><code>
vetor (int tam); 			 </code></p><p><code>
//construtor, aloca memória para o vetor.</code></p><p><code>
void atribui(int index,int valor);    </code></p><p><code>
//altera uma posicao do vetor</code></p><p><code>
int conteudo(int index);               </code></p><p><code>
//retorna conteudo de posicao do vetor</code></p><p><code>
int maximo(void);                      </code></p><p><code>
//retorna o maior elemento do vetor</code></p><p><code>
int primeiro(void);                   </code></p><p><code>
 //primeiro  indice do vetor</code></p><p><code>
int ultimo(void);                      </code></p><p><code>
//ultimo indice do vetor</code></p><p><code>
~vetor() {delete v;}               </code></p><p><code>
//inline function ou use delete v[];</code></p><p><code>
};</code></p><p><code>
<b></b></code></p><hr><p><code>
//codigo, implementacao, para o header file</code></p><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
#include &lt;stdlib.h&gt;</code></p><p><code>
#include "exvet1.h"</code></p><p><code>
</code></p><p><code>
vetor::vetor (int tam)</code></p><p><code>
{v=new int[tam]; tamanho=tam;}</code></p><p><code>
</code></p><p><code>
void vetor::atribui(int index,int valor)</code></p><p><code>
{</code></p><p><code>
if (index&lt;tamanho &amp;&amp; index&gt;=inicio)</code></p><p><code>
v[index]=valor;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
int vetor::conteudo(int index)</code></p><p><code>
{</code></p><p><code>
 if (index&gt;=tamanho || index&lt;inicio) {cerr &lt;&lt; "Fora dos limites";
exit(1);}</code></p><p><code>
 return v[index];</code></p><p><code>
 }</code></p><p><code>
</code></p><p><code>
int vetor::primeiro(void)</code></p><p><code>
{ return inicio;}</code></p><p><code>
</code></p><p><code>
int vetor::ultimo(void)</code></p><p><code>
{ return tamanho-1;}</code></p><p><code>
</code></p><p><code>
int vetor:: maximo(void)</code></p><p><code>
{int candidato=inicio;  //candidato ao maximo</code></p><p><code>
 for (int i=inicio;i&lt;tamanho;i++)</code></p><p><code>
 if (v[i]&gt;v[candidato]) candidato=i;</code></p><p><code>
 return v[candidato];}</code></p><p><code>
<b></b></code></p><hr><p><code>
//programa pricipal</code></p><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
#include "exvet1.h"</code></p><p><code>
</code></p><p><code>
main()</code></p><p><code>
{</code></p><p><code>
int aux; </code></p><p><code>
//para ler valor a atribuir</code></p><p><code>
vetor meu(5);</code></p><p><code>
</code></p><p><code>
for (int i=meu.primeiro();i&lt;=meu.ultimo();i++)</code></p><p><code>
{</code></p><p><code>
 cout &lt;&lt; "Entre com valor da posicao:" &lt;&lt; i &lt;&lt; "\n";</code></p><p><code>
 cin &gt;&gt; aux;</code></p><p><code>
 meu.atribui(i,aux);</code></p><p><code>
}</code></p><p><code>
for (int j=meu.primeiro();j&lt;=meu.ultimo();j++) cout&lt;&lt;
meu.conteudo(j)&lt;&lt; " ";</code></p><p><code>
cout &lt;&lt;endl &lt;&lt; "Maximo:" &lt;&lt; meu.maximo();</code></p><p><code>
return 0;</code></p><p><code>
}</code></p><p><code>
</code></p><p>
<b></b></p><hr><p>
<b>Comentários:</b> </p><p>
	O método<b> </b><code><b></b></code></p><p><code>
<b></b>~vetor() {delete v;}               //use delete []v;depende do
compilador</code></p><p>
é um destrutor, assim como o construtor ele não tem valor de
retorno porque é chamado pelo sistema operacional quando o objeto sai de
escopo ou quando você desaloca memória de um  ponteiro para o
objeto. A única ação do destrutor é liberar a
memória ocupada pelo atributo vetor de inteiros<code> (int * v)
</code>da classe vetor. De um modo geral os destrutores servem para
"arrumar a casa" quando objetos são desalocados  ou saem de escopo. A
sintaxe dos métodos para deleção de vetores
<code>delete v; </code> ou <code>delete []v; </code>
podem variar de compilador para compilador, o usuário deve checar que
sintaxe seu compilador suporta.</p><p>
	Note que quando não dispúnhamos do destrutor o programador era
obrigado a deletar passo a passo todas as estruturas dinâmicas dos
objetos que saiam de escopo, existem técnicas avançadas para
obter coleta automática de lixo em C++ baseadas neste ponto.</p><p>
</p><p>
<b>Resultado do programa:</b></p><p>
<b></b>Entre com valor da posicao:0</p><p>
4</p><p>
Entre com valor da posicao:1</p><p>
5</p><p>
Entre com valor da posicao:2</p><p>
9</p><p>
Entre com valor da posicao:3</p><p>
2</p><p>
Entre com valor da posicao:4</p><p>
1</p><p>
4 5 9 2 1</p><p>
Maximo:9</p><p>
<b></b></p><p>
<b>Dica de programação: </b> </p><p>
	Saiba que uma prática bastante útil na fase de testes de um
programa é introduzir mensagens informativas em pontos convenientes.
Quando trabalhando com objetos tal prática pode ser usada de
vários modos, por exemplo pode-se inserir uma mensagem no destrutor de
uma classe para verificar quando os objetos são eliminados e se
são eliminados corretamente.</p><p>
</p><p>
<b>Exercícios:</b></p><p>
<b></b>1) Note que os métodos atribui e conteúdo  apresentam
estilos diferentes de lidar com índices fora dos limites do vetor. Um
apresenta uma mensagem de erro e termina o programa. Outro simplesmente
não executa a ação se os parâmetros não
estiverem corretos. Escolha um dos estilos e uniformize o programa. Quando
você estudar "exception handling" 4.5 verá maneiras melhores de
lidar com esses problemas.</p><p>
</p><p>
2) Implemente uma função membro chamada ordena para o tipo
abstrato de dados vetor definido acima. Use qualquer algoritmo de
ordenação.</p><p>
</p><p>
3)Crie destrutores para as classes que você já implementou, mesmo
que elas não tenham atributos que usem alocação
dinâmica. Introduza mensagens tipo <code>cout &lt;&lt;
"Goodbye..."; </code> nos destrutores destas classes . Como essas
mensagens podem ser úteis? Defina vários níveis de blocos
de código, fazendo assim com que objetos saiam de escopo em tempos
diferentes e teste seus destrutores.</p><p>
</p><p>
4)Melhore o exercício anterior introduzindo um nome para o objeto. Este
nome deve ir nas saídas de tela e é   nome dado para o
construtor como uma<code> string (char*). </code>Não
esqueça de deletar esta string no destrutor da classe depois de imprimir
a mensagem.</p><p>
</p><p>
5)Crie uma função membro de nome preenche, que inicializa todas
as posições de um vetor com o valor de um de seus argumentos.</p><p>
</p><p>
6)Defina um programa chamado grandes que implementa o tipo abstrato de dados
números grandes e inteiros, este tipo deve usar um vetor do tipo
numérico que você achar conveniente para representar os
algarismos. Talvez estudar circuitos lógicos como somadores, etc  o
ajude a implementar as quatro operações matemáticas
básicas para estes tipo em termos de "look ahead carrier" e outras
técnicas de performance para implementar as operações.</p><p>
</p><p>
7)Note que na alocação do vetor:</p><p>
<code></code></p><p><code>
 vetor::vetor (int tam)</code></p><p><code>
{v=new int[tam]; tamanho=tam;}</code></p><p><code>
</code></p><p>
, não é checado se o valor passado tam é maior que 0,
faça este teste.</p><p>
</p><p>
Quando explicarmos "exception handling" você terá métodos
melhores de lidar com esses erros.</p><p>
<b></b>
</p><h4>
<a name="RTFToC28">1.5.3.7.
</a><a name="_Toc342736967"></a><a name="_Toc345838238"></a><a name="_Toc345942373"></a><a name="_Toc345949533"></a><a name="_Toc346168650"></a><a name="_Toc348417093"></a><a name="_Toc348931349"></a><a name="_Toc353900788"></a><a name="_Toc353946318">
ALOCANDO OBJETOS</a>
</h4>
<p>
	Pula, em Modula-3 já são alocados.</p><p>
	Este exemplo mostra como trabalhar com ponteiros para objetos, new e delete,
como alocar memória e chamar corretamente os construtores.</p><p>
		</p><p>
<b>Comentários: </b></p><p>
<b>	</b>Perceba que agora não estamos alocando um vetor de inteiros com
três posições<code> (new int[3]), </code> mas
um inteiro que contém o valor 3. Você pode ler o código
<code> (*a) </code>como: "O apontado de a".</p><p>
	Se a fosse uma<code> struct </code>ou <code>class
</code>e tivesse um dado membro chamado dd, poderíamos obter o
valor de dd através de (*a).dd que pode ser todo abreviado em
<code>a-&gt;dd </code>onde <code>-&gt; </code>é
uma seta, ou flecha que você pode ler como "o apontado" novamente.</p><p>
	Os parênteses em <code> (*a).dd</code> são
necessários devido a precedência do operador<b> .</b> com
relação ao<code> *</code>.</p><p>
</p><p>
<a name="_Toc342736968"></a><a name="_Toc345409407"></a><a name="_Toc345810912"></a><a name="_Toc345838239"></a><a name="_Toc345942374"></a><a name="_Toc345949534"></a><a name="_Toc346168651"></a><a name="_Toc348417094"></a><a name="_Toc348931350"></a><a name="_Toc353900789"></a><a name="_Toc353946319">
</a></p><h3><a name="_Toc353946319">
</a><a name="RTFToC29">1.5.4.
REFERÊNCIA &amp;</a>
</h3>
	Aqui vou ensinar passagem por referência, lembre-se que objetos
são passados por referência, porque eles são
referência, ponteiros.<p>
	 Este tópico vai explicar como usar o operador<code> &amp;,
</code>também chamado de operador "endereço de...". Este
operador fornece o endereço, a posição na memória
de uma variável, de um argumento, etc.  Sua utilização
é muito simples, se a é uma variável inteira, <code>
&amp;a </code>retorna um ponteiro para a.</p><p>
</p><p>
O programa a seguir ilustra a sintaxe do operador: <code></code></p><p><code>
<b></b></code></p><hr><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
void main()</code></p><p><code>
{</code></p><p><code>
int a; </code></p><p><code>
a=10;</code></p><p><code>
int* p;</code></p><p><code>
p=&amp; a;</code></p><p><code>
(*p)=13;</code></p><p><code>
cout &lt;&lt; a;</code></p><p><code>
}</code></p><p><code>
<b></b></code></p><hr><p><code>
</code></p><p>
<b>Explicando o programa passo a passo:</b></p><p>
<code></code></p><p><code>
int a; </code></p><p><code>
</code></p><p>
Declara uma variável inteira com nome a.</p><p>
<code></code></p><p><code>
a=10;</code></p><p><code>
</code></p><p>
atribui valor 10 a variável a.</p><p>
<code></code></p><p><code>
int* p;</code></p><p><code>
</code></p><p>
Declara um ponteiro de variável inteira , o nome do ponteiro é
p.</p><p>
<code></code></p><p><code>
 p=&amp; a;</code></p><p><code>
</code></p><p>
Atribui o "endereço de a" , <code>"&amp; a" </code>ao
ponteiro p. </p><p>
<code></code></p><p><code>
(*p)=13;</code></p><p><code>
</code></p><p>
Atribui 13 ao "apontado de p", "<code>(*p) </code>", mas como
<code>p</code> aponta para <code>a</code>, a passa de
valor 10 para valor treze através de <code>p</code>.
<code>P</code> é um "alias" para a.</p><p>
<code></code></p><p><code>
cout &lt;&lt; a;</code></p><p><code>
</code></p><p>
Imprime o valor esperado que é treze.</p><p>
</p><p>
	O programa a seguir usa o operador "endereço de" para modificar
argumentos, parâmetros de uma função, ou seja utiliza
passagem por referência, equivalente ao VAR de Pascal. Lembre-se que
até agora os argumentos das nossas funções só eram
passados por valor.</p><p>
<code></code></p><p><code>
<b></b></code></p><hr><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
</code></p><p><code>
void incrementa(int&amp; a)</code></p><p><code>
{</code></p><p><code>
a++;</code></p><p><code>
}</code></p><p><code>
//primeira funcao que usa passagem por referencia</code></p><p><code>
</code></p><p><code>
void troca(int&amp; a,int&amp; b)</code></p><p><code>
{</code></p><p><code>
int aux=a;</code></p><p><code>
a=b;</code></p><p><code>
b=aux;</code></p><p><code>
}</code></p><p><code>
//segunda funcao que usa passagem por referencia</code></p><p><code>
</code></p><p><code>
void main()</code></p><p><code>
{</code></p><p><code>
int i1=10;</code></p><p><code>
int i2=20;</code></p><p><code>
incrementa(i1);</code></p><p><code>
cout &lt;&lt; i1 &lt;&lt; endl;</code></p><p><code>
troca(i1,i2);</code></p><p><code>
cout &lt;&lt; i1 &lt;&lt; endl;</code></p><p><code>
}</code></p><p><code>
<b></b></code></p><hr><p><code>
</code></p><p>
<b>Resultado do programa:</b></p><p>
<b></b>11</p><p>
20</p><p>
</p><p>
<b>Explicando passo a passo:</b></p><p>
<b>	</b>As funções criadas no programa, são como dissemos,
capazes de alterar seus parâmetros, <code>incrementa </code>,
incrementa seu único parâmetro e <code>troca</code>,
troca os dois parâmetros inteiros.</p><p>
<a name="_Toc342736969"></a><a name="_Toc345409408"></a><a name="_Toc345810913"></a><a name="_Toc345838240"></a><a name="_Toc345942375"></a><a name="_Toc345949535"></a><a name="_Toc346168652"></a><a name="_Toc348417095"></a><a name="_Toc348931351"></a><a name="_Toc353900790"></a><a name="_Toc353946320">
</a></p><h2><a name="_Toc353946320">
</a><a name="RTFToC30">1.6.
RECAPITULANDO</a>
</h2>
<b>	</b><p>
<b>	</b>Neste tópico apresentaremos programas que revisam todos
conceitos já vistos e acrescentam mais alguns detalhes da
linguagem.<b></b></p><p>
<b>
<a name="_Toc342736970"></a><a name="_Toc345409409"></a><a name="_Toc345810914"></a><a name="_Toc345838241"></a><a name="_Toc345942376"></a><a name="_Toc345949536"></a><a name="_Toc346168653"></a><a name="_Toc348417096"></a><a name="_Toc348931352"></a><a name="_Toc353900791"></a><a name="_Toc353946321"></a></b><a name="_Toc353946321">
</a></p><h3><a name="_Toc353946321">
</a><a name="RTFToC31">1.6.1.
ARGUMENTOS DE LINHA DE COMANDO.</a> 
</h3>
<b></b><p>
<b></b></p><p>
<b>	</b>Neste tópico vamos apresentar um exemplo que usa tudo o que foi
aprendido até agora e introduz mais alguns outros conceitos.<b> </b>Este
exemplo é um jogo de quebra cabeça. Provavelmente você
já viu um quebra cabeça deste tipo, ele é chamado quebra
cabeça de tijolos deslizantes. É composto de um tabuleiro
(matriz) quadrado preenchido com peças de 0 até (lado^2-1) onde
lado é a dimensão de um lado do tabuleiro. A
representação no programa é numérica, mas
normalmente esses quebra cabeças são vendidos com desenhos
pintados sobre as pecas. No lugar onde deveria estar a última
peça  deixa-se um espaço vazio para que se possa mover  as
peças do tabuleiro. O objetivo é colocar todos os tijolos em
ordem, como no esquema  abaixo:</p><p>
</p><p>
</p><p>
</p><p>
</p><center><img src="TUTORIAL_unicamp_c++_files/jogo.gif"></center>
Solucionado!
<p>
<b>	</b></p><p>
<b>	</b>O que um quebra cabeça tem a ver com encapsulamento? Simples o
jogador é obrigado a seguir as regras do jogo, portanto não pode
conhecer todas as operações que se aplicam ao quebra
cabeça, e também não pode acessar sua
representação interna. Vamos ver como isso é feito usando
as palavras reservadas <code>private e public </code>, conceitos de
agregação e reuso de código de uma classe matriz.<b>
</b>Além disso usamos const para garantir a integridade da matriz do
quebra-cabeça.</p><p>
<b></b></p><p>
<b>	</b>Veja também que  estamos abordando o tópico
representação, não raro você terá que modelar
objetos que representem algo do mundo real como motor, quebra-cabeça,
conta bancária, circuito elétrico e assim por diante. Outros
objetos podem ser mais abstratos, exemplo: árvore
binária.<b></b></p><p>
<b></b>	</p><p>
<b>Mais sobre as regras:</b></p><p>
<b>	</b>Você concorda que dada uma situação onde o
espaço vazio se encontra no meio do quebra-cabeça dado como
exemplo o usuário só tem 4 opções? São elas:
mover para cima (função membro
<code>movecima</code>), mover para baixo , mover para a esquerda ou
então para a direita. Note que essas funções membro
só trocam peças vizinhas, isso é importante pois é
provado matematicamente que algumas trocas de peças distantes  ("Odd
permutations") podem tornar o quebra-cabeça insolúvel. Isto
é facil de ser verificado para um quebra cabeça 2x2.<b></b></p><p>
<b></b>	Garantimos a solução do quebra-cabeça  pelo
caminho inverso do embaralhamento das peças, que parte do
quebra-cabeça solucionado e aplica aleatoriamente sequências de
movimentos iguais aos que o usuário usa para solucionar o jogo.<b></b></p><p>
<b>	</b>A matriz bidimensional é representada linearmente (vetor) e as
funções membro de conversão de índice linear para
colunas e/ou linhas e atribuições são fornecidas, mas
somente as necessárias para o jogo .</p><p>
</p><p>
<b>Recursos utilizados:</b></p><p>
<b>	</b>Argumentos de linha de comando, funções de
conversão da<code> stdlib, </code>
representação linear de uma matriz, <code>const.
</code><b></b></p><p>
<b></b></p><p>
<b>Argumentos de linha de comando:</b></p><p>
<b></b>	Você pode fazer programas que aceitem argumentos de linha de
comandos, resultando em algo equivalente a: <code></code></p><p><code>
dir /w   //dos</code></p><p><code>
format A: //dos</code></p><p><code>
ou ls -la   //unix</code></p><p><code>
</code><b></b></p><p>
<b></b>	Esses argumentos podem ficar disponíveis na chamada da
função main de seu programa como os parâmetros "argument
counter" e "argument values", veja  trecho de programa abaixo.</p><p>
<code>void main(int argc, char *argv[]) {.../*use argv e argc*/ ...}
</code></p><p>
<b></b></p><p>
<b></b><code>argc<b> </b></code>é um inteiro</p><p>
<code>argv</code><b> </b>é um vetor de<b>
</b><code>char* </code>contendo os argumentos passados. (/w
...)<b></b></p><p>
<b></b><code>argv [0]<b> </b></code>é o nome do programa
chamado.<b></b></p><p>
<b></b>A faixa útil de argvalues é :
<code>argv[1]...argv[argc-1] </code></p><p>
</p><p>
Portanto se <code>argc==2</code>, temos um único argumento
de linha de comando, disponível como string em <code>argv[1]
</code>. Faça alguns testes com o mesma main usada no programa
abaixo e alguns <code>cout's</code> imprimindo os argumentos para
entender melhor o assunto.</p><p>
</p><p>
<b>Const: </b></p><p>
<b>	</b>Já exemplificado em 1.5.1</p><p>
<b></b></p><p>
<b>Representação linear de uma matriz: </b></p><p>
</p><center><img src="TUTORIAL_unicamp_c++_files/matrixqc.html"></center>
<b>	</b>Pode-se representar uma matriz de qualquer dimensão em um vetor.
Veja o exemplo de uma matriz bidimensional de inteiros mostrada no formato
indicelinear:valor armazenado<p>
</p><p>
</p><p>
<b></b></p><p>
<b>	</b>Vantagem da representação linear (vetor): para
referenciar uma posição gasta-se somente um inteiro contra dois
da representação matriz (linha,coluna). Podemos agora considerar
posições que apontam para outras posições, basta
interpretar o conteúdo do vetor como um índice linear.<b></b></p><p>
<b>	</b>Desvantagem da representação linear (vetor): é
necessário criar funções de  conversão de
índice na forma (linha,coluna) para (índice linear) e de
(índice linear)  para (coluna) ou (linha). Veja as funções
<code>lin </code>e <code>col </code>e<code>
linear </code>do exemplo seguinte.</p><p>
</p><p>
<b>Funções de conversão da Stdlib:</b></p><p>
<b>	</b>A função<code> int atoi(char* a)
</code>converte uma string para um inteiro.</p><p>
<code></code></p><p><code>
<b></b></code></p><hr><p><code>
<b></b>#include &lt;stdlib.h&gt;</code></p><p><code>
</code></p><p><code>
class matriz  //quebra cabeca de tijolos deslizantes</code></p><p><code>
{</code></p><p><code>
private:</code></p><p><code>
int linhas;    //numero de linhas da matriz</code></p><p><code>
int colunas;  //numero de colunas na matriz</code></p><p><code>
int tam;     //=linhas*colunas</code></p><p><code>
int *lc;    //vetor de tamanho linha*colunas representando matriz:0..(tam-1)</code></p><p><code>
public:</code></p><p><code>
matriz(const int l,const int c); //cria matriz LxC</code></p><p><code>
</code></p><p><code>
//qualquer uma das funcoes abaixo retorna nil se nao conseguiu</code></p><p><code>
int* linear(const int lin,const int col)const ; //ind linear a partir de linha
e coluna</code></p><p><code>
int* col(const int indlin)const ;//coluna a partir do indice linear</code></p><p><code>
int* lin(const int indlin)const ; //linha a partir do indice linear</code></p><p><code>
</code></p><p><code>
int trocaindlin(const int i,const int j); //argumentos: 2 indices lineares</code></p><p><code>
//retorna 1 conseguiu, 0 nao conseguiu</code></p><p><code>
</code></p><p><code>
int atribuiindlin(const int i,const int v); //atribui v ao indice i</code></p><p><code>
//retorna 1 conseguiu, 0 nao conseguiu</code></p><p><code>
</code></p><p><code>
int* retornaindlin(const int i);  //retorna conteudo do indice i</code></p><p><code>
//retorna nil se nao conseguiu</code></p><p><code>
</code></p><p><code>
int getl(void);    //retorna numero de linhas</code></p><p><code>
int getc(void);   //retorna numero de colunas</code></p><p><code>
int gett(void); //retorna tamanho = linhas*colunas</code></p><p><code>
</code></p><p><code>
~matriz();</code></p><p><code>
};<b></b></code></p><p><code>
<b></b></code></p><hr><p><code>
<b></b>#include "matriz.h"</code></p><p><code>
</code></p><p><code>
matriz::matriz(const int l,const int c) //cria matriz</code></p><p><code>
{</code></p><p><code>
  lc=new int[l*c];  //l,c dimensoes ; lc vetor[l*c]</code></p><p><code>
  linhas=l;</code></p><p><code>
  colunas=c;</code></p><p><code>
  tam=linhas*colunas;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
int* matriz::linear(const int alin,const int acol) const</code></p><p><code>
//ind linear a partir de linha e coluna</code></p><p><code>
{</code></p><p><code>
int* result=new int;  //valor de retorno</code></p><p><code>
if ( (0&lt;alin) &amp;&amp; (alin&lt;=linhas) &amp;&amp; (0&lt;acol) &amp;&amp;
(acol&lt;=colunas) )</code></p><p><code>
 {</code></p><p><code>
  (*result)=(alin-1)*colunas+acol;</code></p><p><code>
  return result;</code></p><p><code>
 }</code></p><p><code>
else</code></p><p><code>
 return NULL;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
int* matriz::col(const int indlin)const //coluna a partir do indice linear</code></p><p><code>
{</code></p><p><code>
int* result=new int;</code></p><p><code>
if ( (0&lt;indlin) &amp;&amp; (indlin&lt;=tam) )</code></p><p><code>
 {</code></p><p><code>
  (*result)=(indlin % colunas);</code></p><p><code>
  if ((*result)==0) (*result)=colunas;</code></p><p><code>
  return result;</code></p><p><code>
 }</code></p><p><code>
else</code></p><p><code>
 return NULL;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
int* matriz::lin(const int indlin)const  //linha a partir do indice linear</code></p><p><code>
{</code></p><p><code>
int* result=new int;</code></p><p><code>
if ( (0&lt;indlin) &amp;&amp; (indlin&lt;=tam) )</code></p><p><code>
 {</code></p><p><code>
  (*result)=(int((indlin-1) / colunas)+1);</code></p><p><code>
  return result;</code></p><p><code>
 }</code></p><p><code>
else</code></p><p><code>
 return NULL;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
int matriz::trocaindlin(const int i,const int j) //argumentos: 2 indices
lineares</code></p><p><code>
//retorna 1 conseguiu, 0 nao conseguiu</code></p><p><code>
{</code></p><p><code>
int aux;</code></p><p><code>
if ( (0&lt;i) &amp;&amp; (i&lt;=tam) &amp;&amp; (0&lt;j) &amp;&amp; (j&lt;=tam)
)</code></p><p><code>
{ aux=lc[i-1];   //efetua a troca</code></p><p><code>
  lc[i-1]=lc[j-1]; //embora para usuario a matriz vai de 1 ate l*c</code></p><p><code>
						//para mim vai de o ate l*c-1</code></p><p><code>
  lc[j-1]=aux;</code></p><p><code>
  return 1; //sucesso</code></p><p><code>
}</code></p><p><code>
else return 0; //falhou</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
int matriz::atribuiindlin(const int i,const int v)</code></p><p><code>
//retorna 1 conseguiu, 0 nao conseguiu</code></p><p><code>
{</code></p><p><code>
if ( (0&lt;i) &amp;&amp; (i&lt;=tam) )</code></p><p><code>
 {</code></p><p><code>
  lc[i-1]=v;   //efetua a atribuicao</code></p><p><code>
  return 1;</code></p><p><code>
 }</code></p><p><code>
else return 0; //falhou</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
int* matriz::retornaindlin(const int indlin)</code></p><p><code>
//retorna nil se nao conseguiu</code></p><p><code>
{</code></p><p><code>
int* result=new int;</code></p><p><code>
if ( (0&lt;indlin) &amp;&amp; (indlin&lt;=tam) )</code></p><p><code>
 {</code></p><p><code>
 *result=lc[indlin-1];</code></p><p><code>
 return result;</code></p><p><code>
 }</code></p><p><code>
else</code></p><p><code>
 return NULL;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
int matriz::getl(void)    //retorna numero de linhas</code></p><p><code>
{</code></p><p><code>
return linhas;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
int matriz::getc(void)   //retorna numero de colunas</code></p><p><code>
{</code></p><p><code>
return colunas;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
int matriz::gett(void)   //retorna tamanho</code></p><p><code>
{</code></p><p><code>
return tam;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
matriz::~matriz()</code></p><p><code>
{</code></p><p><code>
delete lc;</code></p><p><code>
}<b></b></code></p><p><code>
<b></b></code></p><hr><p><code>
<b></b>//quebra cabecas de tijolos deslizantes</code></p><p><code>
#include &lt;iostream.h&gt;   //para cin cout</code></p><p><code>
#include &lt;iomanip.h&gt;   //formatar cout output com &gt;&gt; setwidth()</code></p><p><code>
#include &lt;stdlib.h&gt;   //uso rand() em embaralha</code></p><p><code>
#include &lt;string.h&gt;  //atoi() para converter argumentos de linha de
comando</code></p><p><code>
#include "matriz.h"</code></p><p><code>
</code></p><p><code>
const int min_lado=2; //minimo tamanho lateral do quebracab.</code></p><p><code>
const int tam_padrao=5; //tamanho padrao</code></p><p><code>
</code></p><p><code>
class quebracab  //quebra cabeca de tijolos deslizantes</code></p><p><code>
{</code></p><p><code>
private:</code></p><p><code>
</code></p><p><code>
int vazio;   //indice linear da casa vazia</code></p><p><code>
int mov;   //numero de movimentos</code></p><p><code>
matriz* mqc;  //matriz interna do quebra cabecas</code></p><p><code>
</code></p><p><code>
public:</code></p><p><code>
</code></p><p><code>
quebracab(const int ld=tam_padrao); //cria quebra cabeca, ld=lado</code></p><p><code>
void mostra() const;       //mostra quebra cabeca</code></p><p><code>
</code></p><p><code>
void movedir(); //move celula a esq de vazio  para direita.</code></p><p><code>
void moveesq(); //analogo</code></p><p><code>
void movebaixo(); //analogo</code></p><p><code>
void movecima(); //analogo</code></p><p><code>
</code></p><p><code>
void embaralha();  //embaralha quebracabeca</code></p><p><code>
int tstsolucao() const; //testa se quebracabeca esta solucionado</code></p><p><code>
int retorna_mov() { return mov; } //retorna numero de movimentos</code></p><p><code>
</code></p><p><code>
~quebracab();  //destroi quebra cabecas</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
quebracab::quebracab(const int ld) //argumento padrao desnessario, ja
declarado</code></p><p><code>
{</code></p><p><code>
   int ldc=abs(ld);  //ld copia = valor positivo de ld</code></p><p><code>
	if (ldc&lt;min_lado) ldc=min_lado;</code></p><p><code>
	mqc=new matriz(ldc,ldc); //inicializa objeto matriz</code></p><p><code>
	for(int i=1;i&lt;mqc-&gt;gett();i++)</code></p><p><code>
	mqc-&gt;atribuiindlin(i,i);           //initializa casas da matriz</code></p><p><code>
	mqc-&gt;atribuiindlin(mqc-&gt;gett(),0);//atribui zero a posicao da celula
vazia</code></p><p><code>
	vazio=mqc-&gt;gett();               //define posicao da celula vazia</code></p><p><code>
	mov=0;                          //sem nenhum movimento</code></p><p><code>
	embaralha();                   //embaralha quebracabeca</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
void quebracab::mostra() const       //mostra quebra cabeca</code></p><p><code>
{</code></p><p><code>
 int i,j;   //linha e coluna</code></p><p><code>
 int* ind;  //valor atual</code></p><p><code>
 for(i=1;i&lt;=mqc-&gt;getl();i++)   			 //loop das linhas</code></p><p><code>
 { //linhas</code></p><p><code>
	for(j=1;j&lt;=mqc-&gt;getc();j++) 			//loop das colunas</code></p><p><code>
	{  //colunas</code></p><p><code>
	  ind=mqc-&gt;linear(i,j);  				//resultado tambem e ponteiro</code></p><p><code>
	 if</code></p><p><code>
	  ((*ind)==vazio) cout &lt;&lt; setw(4)&lt;&lt;" "; //vazio=espaco</code></p><p><code>
	 else</code></p><p><code>
	  cout &lt;&lt; setw(4) &lt;&lt; (*mqc-&gt;retornaindlin(*ind)); //nao e o
vazio, mostra conteudo</code></p><p><code>
	} //colunas</code></p><p><code>
	cout &lt;&lt; endl; //mudanca de linha</code></p><p><code>
 } //linhas</code></p><p><code>
 cout &lt;&lt; endl;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
void quebracab::movedir() //move celula a esq de vazio  para direita</code></p><p><code>
									//espaco move para esquerda</code></p><p><code>
{</code></p><p><code>
if ( (*(mqc-&gt;col(vazio))) !=1) /*nao esta na borda esquerda*/</code></p><p><code>
 {</code></p><p><code>
 mqc-&gt;trocaindlin(vazio,vazio-1);</code></p><p><code>
 mov++;</code></p><p><code>
 vazio=vazio-1;</code></p><p><code>
 }</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
void quebracab::moveesq() //espaco move para direita</code></p><p><code>
{</code></p><p><code>
if (  (*(mqc-&gt;col(vazio)))!=mqc-&gt;getc()  ) /*nao esta na borda
direita*/</code></p><p><code>
 {</code></p><p><code>
 mqc-&gt;trocaindlin(vazio,vazio+1);</code></p><p><code>
 mov++;</code></p><p><code>
 vazio=vazio+1;</code></p><p><code>
 }</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
void quebracab::movebaixo()  //espaco move para cima</code></p><p><code>
{</code></p><p><code>
if ((*(mqc-&gt;lin(vazio)))!=1) /*nao esta no topo*/</code></p><p><code>
 {</code></p><p><code>
 mqc-&gt;trocaindlin(vazio,vazio-(mqc-&gt;getc()));  //chama funcao private</code></p><p><code>
 mov++;</code></p><p><code>
 vazio=vazio-(mqc-&gt;getc());</code></p><p><code>
 }</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
void quebracab::movecima()  //espaco move para baixo</code></p><p><code>
{</code></p><p><code>
if ((*mqc-&gt;lin(vazio))!=mqc-&gt;getl()) /*nao esta em baixo*/</code></p><p><code>
 {</code></p><p><code>
 mqc-&gt;trocaindlin(vazio,vazio+(mqc-&gt;getc()));</code></p><p><code>
 mov++;</code></p><p><code>
 vazio=vazio+(mqc-&gt;getc());</code></p><p><code>
 }</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
void quebracab::embaralha()  //embaralha quebracabeca</code></p><p><code>
{</code></p><p><code>
 int i,j; //loop principal, loop secundario</code></p><p><code>
 int r;  //r times</code></p><p><code>
 for(j=0;j&lt;mqc-&gt;gett();j++)</code></p><p><code>
 {</code></p><p><code>
 r=(rand()% mqc-&gt;getc());</code></p><p><code>
 for(i=0;i&lt;r;i++) {this-&gt;movedir();} //move r vezes</code></p><p><code>
 r=(rand()% mqc-&gt;getl());</code></p><p><code>
 for(i=0;i&lt;r;i++) {this-&gt;movebaixo();}</code></p><p><code>
 r=(rand()% mqc-&gt;getc());</code></p><p><code>
 for(i=0;i&lt;r;i++) {this-&gt;moveesq();}</code></p><p><code>
 r=(rand()% mqc-&gt;getl());</code></p><p><code>
 for(i=0;i&lt;r;i++) {this-&gt;movecima();}</code></p><p><code>
 }</code></p><p><code>
 mov=0; //inicializa movimentos</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
int quebracab::tstsolucao() const    //testa se quebracabeca esta solucionado</code></p><p><code>
{</code></p><p><code>
 int i=1,cont=1;</code></p><p><code>
 while(     cont &amp;&amp; (i&lt; (mqc-&gt;gett()) )     )</code></p><p><code>
 {</code></p><p><code>
  if ((*(mqc-&gt;retornaindlin(i)))==(i)) cont=1; else cont=0;</code></p><p><code>
  i++;</code></p><p><code>
 }</code></p><p><code>
 return (cont); //i=qctam esta solucionado 1 2 3... 24 0</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
quebracab::~quebracab()</code></p><p><code>
 {if (mqc!=NULL) delete mqc; cout &lt;&lt; " Quebra cabeca destruido!\n";}
//destroi quebracab</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
main(int argc,char *argv[])  //argumentos sao declarados aqui</code></p><p><code>
{ //main</code></p><p><code>
int ladocomp;</code></p><p><code>
char opcao; //usada em menu como variavel de opcao</code></p><p><code>
</code></p><p><code>
if (argc&gt;1) ladocomp=atoi(argv[1]);</code></p><p><code>
//convertendo argumento de linha de comando para inteiro</code></p><p><code>
else ladocomp=tam_padrao;  //valor default</code></p><p><code>
</code></p><p><code>
quebracab aquebracab(ladocomp);  //criando quebracab</code></p><p><code>
do {</code></p><p><code>
 aquebracab.mostra();</code></p><p><code>
 cout &lt;&lt;"\n";   //menu de opcoes</code></p><p><code>
 cout &lt;&lt;" Movimentos:" &lt;&lt; aquebracab.retorna_mov()&lt;&lt; "\n";</code></p><p><code>
 cout &lt;&lt;" 4&lt;-   6-&gt;   8Cima   2Baixo   SSair   Eembaralha  \n";</code></p><p><code>
 cout &lt;&lt;" Reconhece sequencias de comandos: 268624 &lt;Enter&gt;\n";</code></p><p><code>
 cout &lt;&lt;" Aceita argumento de linha de comando: quebracab 4 (cria
quebracabeca 4 x 4)\n";</code></p><p><code>
 cout &lt;&lt;" Entre comando:";</code></p><p><code>
 cin &gt;&gt; opcao; //le opcao do usuario</code></p><p><code>
 cout &lt;&lt;"\n";</code></p><p><code>
 switch(opcao) //executa opcao do usuario</code></p><p><code>
 {</code></p><p><code>
  case 'E':</code></p><p><code>
  case 'e':</code></p><p><code>
				aquebracab.embaralha();</code></p><p><code>
				break;</code></p><p><code>
  case '8': aquebracab.movecima();</code></p><p><code>
				break;</code></p><p><code>
  case '2': aquebracab.movebaixo();</code></p><p><code>
				break;</code></p><p><code>
  case '4': aquebracab.moveesq();</code></p><p><code>
				break;</code></p><p><code>
  case '6': aquebracab.movedir();</code></p><p><code>
				break;</code></p><p><code>
  default:  ;</code></p><p><code>
 }  //fim do bloco de codigo do switch-case</code></p><p><code>
 if (aquebracab.tstsolucao()) opcao='s'; //sai do loop de menu</code></p><p><code>
} while ((opcao!='S') &amp;&amp; (opcao!='s')); //loop menu</code></p><p><code>
</code></p><p><code>
if (aquebracab.tstsolucao()) {aquebracab.mostra(); cout &lt;&lt; "
Parabens!\n";}</code></p><p><code>
else  cout &lt;&lt; " Quebra cabeca nao solucionado. Tente novamente!\n";</code></p><p><code>
return 0;</code></p><p><code>
}  //bloco de codigo principal</code></p><p><code>
</code></p><p>
<b></b></p><hr><p>
<b>Comentários: </b></p><p>
<b>	</b><code>delete []qc; </code>Este destrutor adota uma
técnica diferente para deleção de vetores, cheque que
técnicas seu compilador suporta.</p><p>
<b></b></p><p>
<b>Exercícios</b><b>:	</b></p><p>
<b></b>1) Se você implementou o jogo de quebra-cabeça
notará que não existe apagamento da tela, somente "scroll". Isto
torna o jogo um pouco cansativo porque dá para ver o quebra
cabeça sendo empurrado para o alto da tela e a nova
representação sendo criada na parte de baixo do "display". A
razão de tal escolha é simples: a função de
apagamento de tela do DOS não é portável para o UNIX e
vice versa. Descubra a função de CLS (Clear Screen) do seu
ambiente de programação e use-a no programa. Numa segunda etapa
introduza cores no programa, você pode usar a função
módulo (número da peça ,número de cores) para
determinar a cor de uma peça.</p><p>
</p><p>
2) Implemente outros jogos simples. Pense em jogos compatíveis com a sua
experiência. Aqui vão algumas sugestões:</p><p>
<b></b></p><p>
<b></b>	Senha: Jogo bastante conhecido, o programa cria um código de n
dígitos e m símbolos. Através de chutes o jogador tenta
acertar o código na seqüência. A cada chute o programa da
dicas dos acertos sendo elas de dois tipos: Acertou o símbolo X vezes ou
acertou o símbolo e a posição Y vezes. Você
terá que usar uma função para obter números
aleatórios, provavelmente rand da "library"
<code>&lt;math.h&gt;.</code><b></b></p><p>
<b></b>	Jogo da velha.</p><p>
	 Se você não conhece os jogos procure obter mais
informações antes de começar a implementa-los.</p><p>
<b></b></p><p>
<b></b>5)Melhore a classe matriz para aceitar nas suas funções
argumentos do tipo (linha,coluna) e não só índices
lineares.</p><p>
<b></b></p><p>
<b></b>4) Construa um programa simples que recebe argumentos da linha de
comando e os imprime através de <code>cout. </code>
Normalmente é isso que deve ser feito antes de usar um recurso da
linguagem pela primeira vez, experimenta-lo em programas simples.
<a name="_Toc342736971"></a><a name="_Toc345409410"></a><a name="_Toc345810915"></a><a name="_Toc345838242"></a><a name="_Toc345942377"></a><a name="_Toc345949537"></a><a name="_Toc346168654"></a><a name="_Toc348417097"></a><a name="_Toc348931353"></a><a name="_Toc353900792"></a><a name="_Toc353946322">
</a></p><h1><a name="_Toc353946322">
</a><a name="RTFToC32">2.
HERANÇA</a>
</h1>
<a name="_Ref342218812"></a><a name="_Toc342736972"></a><a name="_Toc345409411"></a><a name="_Toc345810916"></a><a name="_Toc345838243"></a><a name="_Toc345942378"></a><a name="_Toc345949538"></a><a name="_Toc346168655"></a><a name="_Toc348417098"></a><a name="_Toc348931354"></a><a name="_Toc353900793"></a><a name="_Toc353946323">
</a><h2><a name="_Toc353946323">
</a><a name="RTFToC33">2.1.
HIERARQUIAS DE TIPOS</a> 
</h2>
<p>
	Neste tópico mostraremos como construir hierarquias de tipo por
generalização / especialização.
<a name="_Toc342736973"></a><a name="_Toc345409412"></a><a name="_Toc345810917"></a><a name="_Toc345838244"></a><a name="_Toc345942379"></a><a name="_Toc345949539"></a><a name="_Toc346168656"></a><a name="_Toc348417099"></a><a name="_Toc348931355"></a><a name="_Toc353900794"></a><a name="_Toc353946324">
</a></p><h3><a name="_Toc353946324">
</a><a name="RTFToC34">2.1.1.
UMA HIERARQUIA SIMPLES.</a> 
</h3>
<b></b><p>
<b>	</b>Construiremos uma hierarquia de tipos simples para demonstrar
herança pública em C++.</p><p>
</p><p>
<b></b></p><p>
<b>Comentários: </b></p><p>
</p><center><img src="TUTORIAL_unicamp_c++_files/casehera.gif"></center>


<b></b>	O diagrama acima representa a hierarquia de classes implementada e foi
obtido a partir da janela de edição de uma ferramenta case para
programação orientada a objetos.<p>
	A classe<code> ponto </code>que está no topo da hierarquia
é chamada de classe base, enquanto que as classes
<code>ponto_reflete</code> e<code> ponto_move</code>
são chamadas classes filhas ou herdeiras.<b> </b>As classes da
hierarquia são simples, <code> ponto_move </code>apresenta a
função membro <code>move</code>, já vista
neste tutorial em 1.2.6, <code>ponto_reflete </code>apresenta a
função membro <code> (reflete) </code>que inverte o
sinal das coordenadas.  </p><p>
	Dada a simplicidade das classes o leitor poderia se perguntar, porque
não juntar</p><p>
as três  em uma só . A pergunta faz sentido, mas  e se
quiséssemos criar uma classe ponto que não se movesse, apenas
refletisse e outra que só se movesse? E se quiséssemos projetar
nosso programa segundo uma hierarquia de especialização /
generalização da classe ponto? O exemplo mostra como
fazê-lo.</p><p>
</p><p>
<b>Herança Pública:</b></p><p>
<b> 	</b>Na herança pública as classes filhas passam a ter as
mesmas funções membro<code> public </code>da classe
pai, as classes filhas podem acrescentar funções membro, dados
membro e até redefinir funções membro herdadas (veremos
mais tarde). Os atributos da classe pai não são acessíveis
diretamente na classe filha a não ser que sejam qualificados como
<code>protected, </code> veja 2.1.2. Por isso é que se diz
que as classes filhas garantem pelo menos o comportamento "behaviour" da classe
pai, podendo acrescentar mais características.</p><p>

     Diagrama de acesso, visibilidade, de                                                     
dados membro e funções  membro de uma classe                                                  
pai  para uma classe filha ou herdeira  por                                                   
herança pública:            
</p><center><img src="TUTORIAL_unicamp_c++_files/pvpxpv.html"></center>

                                                                  

<p>
<b>Construtores e herança:</b></p><p>
<b>	</b>No construtor de uma classe filha o programador pode incluir a chamada
do construtor da classe pai.</p><p>
<b></b></p><p>
<b>Destrutores e herança: </b></p><p>
<b>	</b>Quando um objeto da classe derivada é destruído, o
destrutor da classe pai também é chamado dando a oportunidade de
liberar a memória ocupada pelos atributos <code>private
</code>da classe pai.</p><p>
<code></code></p><p><code>
<b></b></code></p><hr><p><code>
<b></b>//header file</code></p><p><code>
class ponto</code></p><p><code>
{</code></p><p><code>
private:</code></p><p><code>
float x;   //sao ocultos por default</code></p><p><code>
float y;   //sao ocultos por default</code></p><p><code>
public:  //daqui em diante tudo e acessivel.</code></p><p><code>
ponto(float a,float b);</code></p><p><code>
void inicializa(float a,float b);</code></p><p><code>
float retorna_x(void);</code></p><p><code>
float retorna_y(void);</code></p><p><code>
void altera_x(float a);</code></p><p><code>
void altera_y(float b);</code></p><p><code>
void mostra(void);</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
class ponto_reflete:public ponto   //classe filha</code></p><p><code>
{</code></p><p><code>
private: //se voce quer adicionar atributos...</code></p><p><code>
public:</code></p><p><code>
ponto_reflete(float a, float b);</code></p><p><code>
void reflete(void); </code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
class ponto_move:public ponto</code></p><p><code>
{</code></p><p><code>
public:</code></p><p><code>
ponto_move(float a,float b);</code></p><p><code>
void move(float dx,float dy);</code></p><p><code>
};</code></p><p><code>
<b></b></code></p><p><code>
<b></b></code></p><hr><p><code>
<b></b></code></p><p><code>
<b></b>//implementation file</code></p><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
#include "pontos.h"</code></p><p><code>
</code></p><p><code>
ponto::ponto(float a,float b)</code></p><p><code>
{</code></p><p><code>
 inicializa(a,b);</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
void ponto::inicializa(float a,float b)</code></p><p><code>
{</code></p><p><code>
 x=a;</code></p><p><code>
 y=b;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
float ponto::retorna_x(void)</code></p><p><code>
{ return x; }</code></p><p><code>
</code></p><p><code>
float ponto::retorna_y(void)</code></p><p><code>
{ return y; }</code></p><p><code>
</code></p><p><code>
void ponto::altera_x(float a)</code></p><p><code>
{ x=a; }</code></p><p><code>
</code></p><p><code>
void ponto::altera_y(float b)</code></p><p><code>
{ y=b; }</code></p><p><code>
</code></p><p><code>
void ponto::mostra(void)</code></p><p><code>
{</code></p><p><code>
cout &lt;&lt; "(" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; ")"
&lt;&lt;endl;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
ponto_reflete::ponto_reflete(float a,float b):ponto(a,b)</code></p><p><code>
{ }</code></p><p><code>
</code></p><p><code>
void ponto_reflete::reflete(void)</code></p><p><code>
{</code></p><p><code>
 altera_x(-retorna_x());</code></p><p><code>
 altera_y(-retorna_y());</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
ponto_move::ponto_move(float a,float b):ponto(a,b)</code></p><p><code>
{ }</code></p><p><code>
</code></p><p><code>
void ponto_move::move(float dx,float dy)</code></p><p><code>
{</code></p><p><code>
 altera_x(retorna_x()+dx);</code></p><p><code>
 altera_y(retorna_y()+dy);</code></p><p><code>
}</code></p><p><code>
<b></b></code></p><p><code>
<b></b></code></p><hr><p><code>
<b></b></code></p><p><code>
<b></b>#include &lt;iostream.h&gt;</code></p><p><code>
#include "pontos.h"</code></p><p><code>
</code></p><p><code>
void main()</code></p><p><code>
{</code></p><p><code>
 ponto_reflete p1(3.14,2.17);</code></p><p><code>
 p1.reflete();</code></p><p><code>
 cout &lt;&lt; "P1";</code></p><p><code>
 p1.mostra();</code></p><p><code>
</code></p><p><code>
 ponto_move p2(1.0,1.0);</code></p><p><code>
 p2.move(.5,.5);</code></p><p><code>
 cout &lt;&lt; "P2";</code></p><p><code>
 p2.mostra();</code></p><p><code>
}</code></p><p><code>
<b></b></code></p><hr><p><code>
</code><b></b></p><p>
<b>Resultado do programa:</b></p><p>
<b></b>P1(-3.14,-2.17)</p><p>
P2(1.5,1.5)</p><p>
<b></b></p><p>
<b>Herança Private:</b></p><p>
<b>	</b>Ainda não foi inserido no tutorial nenhum exemplo com este tipo
de herança, mas o leitor pode experimentar mais tarde especificar uma
classe herdeira por heranca private como: <code>class herdeira: private
nome_classe_base; </code> , e notará que as funções
membro desta classe base só são acessíveis dentro das
declarações da classe filha, ou seja a classe filha não
atende por essas funções membro, mas pode usá-las em seu
código.</p><p>
	Herança<code> private </code>é um recurso que
você precisa tomar cuidado quando usar. Normalmente, quando usamos
herança dizemos que a classe filha garante no mínimo o
comportamento da classe pai (em termos de funções membro) , a
herança<code> private </code>pode invalidar esta premissa.
</p><p>
	Muitos programadores usam herança<code> private
</code>quando ficaria mais elegante, acadêmico, trabalhar com
agregação. Uma classe pilha pode ser construída a partir
de uma classe que implementa uma lista ligada por agregação ou
por herança<code> private. </code>Na agregação
(a escolhida em <i>hierarquias de implementação</i>) a classe
pilha possui um dado membro que é uma lista ligada.</p><p>
<b></b>
</p><h3>
<a name="RTFToC35">2.1.2.
</a><a name="_Ref342314630"></a><a name="_Toc342736974"></a><a name="_Toc345409413"></a><a name="_Toc345810918"></a><a name="_Toc345838245"></a><a name="_Toc345942380"></a><a name="_Toc345949540"></a><a name="_Toc346168657"></a><a name="_Toc348417100"></a><a name="_Toc348931356"></a><a name="_Toc353900795"></a><a name="_Toc353946325">
PROTECTED</a>
</h3>
<b></b><p>
<b>	</b>Igual ao exemplo um, mas agora tornando os atributos da classe pai
acessíveis para as classes filhas através do uso de<code>
protected.  Protected </code>deixa os atributos da classe pai
visíveis, acessíveis "hierarquia abaixo".</p><p>
<b>	</b>Diagramas de acesso, visibilidade, de dados membro e
funções membro de uma classe pai para uma classe filha ou
herdeira:<b></b></p><p>
<b></b>

</p><pre>           Para uma classe filha por herança                         <img src="TUTORIAL_unicamp_c++_files/pvpxpv.html">                        
pública:                                                                                      

</pre>
<b></b>

<pre>           Visibilidade da classe herdeira                           <img src="TUTORIAL_unicamp_c++_files/pvpxpx.html">                        
para o restante do programa:                                                                  

</pre>
<code><p>
<b></b></p><hr><p>
<b></b>//header file</p><p>
class ponto</p><p>
{</p><p>
protected:   </p><p>
//*****aqui  esta a diferenca ******</p><p>
float x;   </p><p>
//visiveis hierarquia abaixo</p><p>
float y;   </p><p>
//visiveis hierarquia abaixo</p><p>
public:  </p><p>
//daqui em diante tudo e acessivel.</p><p>
ponto(float a,float b);</p><p>
void inicializa(float a,float b);</p><p>
float retorna_x(void);</p><p>
float retorna_y(void);</p><p>
void altera_x(float a);</p><p>
void altera_y(float b);</p><p>
void mostra(void);</p><p>
};</p><p>
</p><p>
</p><p>
class ponto_reflete:public ponto</p><p>
{</p><p>
private: </p><p>
//se voce quer adicionar dados membro encapsulados...</p><p>
public:</p><p>
ponto_reflete(float a, float b);</p><p>
void reflete(void); </p><p>
};</p><p>
</p><p>
class ponto_move:public ponto</p><p>
{</p><p>
public:</p><p>
ponto_move(float a,float b);</p><p>
void move(float dx,float dy);</p><p>
};</p><p>
<b></b></p><p>
<b></b></p><hr><p>
<b></b></p><p>
<b></b>//implementation file</p><p>
#include &lt;iostream.h&gt;</p><p>
#include "pontos.h"</p><p>
</p><p>
ponto::ponto(float a,float b)</p><p>
{</p><p>
 inicializa(a,b);</p><p>
}</p><p>
</p><p>
void ponto::inicializa(float a,float b)</p><p>
{</p><p>
 x=a;</p><p>
 y=b;</p><p>
}</p><p>
</p><p>
float ponto::retorna_x(void)</p><p>
{ return x; }</p><p>
</p><p>
float ponto::retorna_y(void)</p><p>
{ return y; }</p><p>
</p><p>
void ponto::altera_x(float a)</p><p>
{ x=a; }</p><p>
</p><p>
void ponto::altera_y(float b)</p><p>
{ y=b; }</p><p>
</p><p>
void ponto::mostra(void)</p><p>
{</p><p>
cout &lt;&lt; "(" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; ")"
&lt;&lt;endl;</p><p>
}</p><p>
</p><p>
ponto_reflete::ponto_reflete(float a,float b):ponto(a,b)</p><p>
{ }</p><p>
</p><p>
void ponto_reflete::reflete(void)</p><p>
{</p><p>
 x=-x; </p><p>
//*** protected da esse tipo de acesso aos atributos da classe pai</p><p>
 y=-y;</p><p>
}</p><p>
</p><p>
ponto_move::ponto_move(float a,float b):ponto(a,b)</p><p>
{ }</p><p>
</p><p>
void ponto_move::move(float dx,float dy)</p><p>
{</p><p>
 x=x+dx; </p><p>
//acesso so na hierarquia, no resto do programa nao.</p><p>
 y=y+dy;</p><p>
}</p><p>
<b></b></p><p>
<b></b></p><hr><p>
<b></b></p><p>
<b></b>#include &lt;iostream.h&gt;</p><p>
#include "pontos.h"</p><p>
</p><p>
void main()</p><p>
{</p><p>
 ponto_reflete p1(3.14,2.17);</p><p>
 p1.reflete();</p><p>
 cout &lt;&lt; "P1";</p><p>
 p1.mostra();</p><p>
</p><p>
 ponto_move p2(1.0,1.0);</p><p>
 p2.move(.5,.5);</p><p>
 cout &lt;&lt; "P2";</p><p>
 p2.mostra();</p><p>
</p><p>
}</p><p>
<b></b></p><hr></code><p><code>
</code><b>
<a name="_Ref342722424"></a><a name="_Toc342736975"></a><a name="_Toc345409414"></a><a name="_Toc345810919"></a><a name="_Toc345838246"></a><a name="_Toc345942381"></a><a name="_Toc345949541"></a><a name="_Toc346168658"></a><a name="_Toc348417101"></a><a name="_Toc348931357"></a><a name="_Toc353900796"></a><a name="_Toc353946326"></a></b><a name="_Toc353946326">
</a></p><h3><a name="_Toc353946326">
</a><a name="RTFToC36">2.1.3.
REDEFINIÇÃO DE FUNÇÕES MEMBRO
HERDADAS</a>
</h3>
<p>
<b>	</b>. Igual ao exemplo anterior, mas agora redefinindo a
função membro<code> mostra</code> para a classe filha
<code>ponto reflete</code>.</p><p>
</p><p>
<b>Comentários:</b> </p><p>
	Na verdade este exemplo deveria pertencer  ao tópico de polimorfismo,
contudo, nos exemplos seguintes usaremos também
redefinições de funções membro, portanto faz-se
necessário introduzi-lo agora. Teremos mais explicações
sobre o assunto.</p><p>
	Uma classe filha pode fornecer uma outra implementação para uma
função membro herdada, caracterizando uma
redefinição "overriding" de função membro.
Importante: a função membro deve ter a mesma assinatura (nome,
argumentos e valor de retorno), senão não se trata de uma
redefinição e sim sobrecarga "overloading".	</p><p>
	No nosso exemplo a classe<code> ponto_reflete</code> redefine a
função membro<code> mostra </code>da classe pai,
enquanto que a classe herdeira<code> ponto_move </code>aceita a
definição da função membro<code>
mostra</code> dada pela classe<code> ponto </code>que
é sua classe pai.</p><p>
<code></code></p><p><code>
<b></b></code></p><hr><p><code>
//header file</code></p><p><code>
class ponto</code></p><p><code>
{</code></p><p><code>
private:</code></p><p><code>
float x;  </code></p><p><code>
//sao ocultos por default</code></p><p><code>
float y;   </code></p><p><code>
//sao ocultos por default</code></p><p><code>
public:  </code></p><p><code>
//daqui em diante tudo e acessivel.</code></p><p><code>
ponto(float a,float b);</code></p><p><code>
void inicializa(float a,float b);</code></p><p><code>
float retorna_x(void);</code></p><p><code>
float retorna_y(void);</code></p><p><code>
void altera_x(float a);</code></p><p><code>
void altera_y(float b);</code></p><p><code>
void mostra(void);</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
class ponto_reflete:public ponto</code></p><p><code>
{</code></p><p><code>
private: </code></p><p><code>
//se voce quer adicionar dados membro</code></p><p><code>
public:</code></p><p><code>
ponto_reflete(float a, float b);</code></p><p><code>
void reflete(void);</code></p><p><code>
void mostra(void); </code></p><p><code>
//redefinicao</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
class ponto_move:public ponto</code></p><p><code>
{</code></p><p><code>
public:</code></p><p><code>
ponto_move(float a,float b);</code></p><p><code>
void move(float dx,float dy);</code></p><p><code>
//esta classe filha nao redefine mostra</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
<b></b></code></p><hr><p><code>
</code></p><p><code>
//implementation file</code></p><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
#include "pontos.h"</code></p><p><code>
</code></p><p><code>
ponto::ponto(float a,float b)</code></p><p><code>
{</code></p><p><code>
 inicializa(a,b);</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
void ponto::inicializa(float a,float b)</code></p><p><code>
{</code></p><p><code>
 x=a;</code></p><p><code>
 y=b;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
float ponto::retorna_x(void)</code></p><p><code>
{ return x; }</code></p><p><code>
</code></p><p><code>
float ponto::retorna_y(void)</code></p><p><code>
{ return y; }</code></p><p><code>
</code></p><p><code>
void ponto::altera_x(float a)</code></p><p><code>
{ x=a; }</code></p><p><code>
</code></p><p><code>
void ponto::altera_y(float b)</code></p><p><code>
{ y=b; }</code></p><p><code>
</code></p><p><code>
void ponto::mostra(void)</code></p><p><code>
{</code></p><p><code>
cout &lt;&lt; "(" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; ")"
&lt;&lt;endl;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
ponto_reflete::ponto_reflete(float a,float b):ponto(a,b)</code></p><p><code>
{ }</code></p><p><code>
</code></p><p><code>
void ponto_reflete::reflete(void)</code></p><p><code>
{</code></p><p><code>
 altera_x(-retorna_x());</code></p><p><code>
 altera_y(-retorna_y());</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
void ponto_reflete::mostra(void)</code></p><p><code>
{</code></p><p><code>
cout &lt;&lt; "X:" &lt;&lt; retorna_x() &lt;&lt; " Y:";</code></p><p><code>
cout &lt;&lt; retorna_y() &lt;&lt; endl; </code></p><p><code>
}</code></p><p><code>
//somente altera o formato de impressao</code></p><p><code>
</code></p><p><code>
ponto_move::ponto_move(float a,float b):ponto(a,b)</code></p><p><code>
{ }</code></p><p><code>
</code></p><p><code>
void ponto_move::move(float dx,float dy)</code></p><p><code>
{</code></p><p><code>
 altera_x(retorna_x()+dx);</code></p><p><code>
 altera_y(retorna_y()+dy);</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
<b></b></code></p><hr><p><code>
</code></p><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
#include "pontos.h"</code></p><p><code>
</code></p><p><code>
void main()</code></p><p><code>
{</code></p><p><code>
 ponto_reflete p1(3.14,2.17);</code></p><p><code>
 p1.reflete();</code></p><p><code>
 cout &lt;&lt; "P1";</code></p><p><code>
 p1.mostra();</code></p><p><code>
</code></p><p><code>
 ponto_move p2(1.0,1.0);</code></p><p><code>
 p2.move(.5,.5);</code></p><p><code>
 cout &lt;&lt; "P2";</code></p><p><code>
 p2.mostra();</code></p><p><code>
</code></p><p><code>
}</code></p><p><code>
<b></b></code></p><hr><p><code>
</code></p><p>
</p><p>
<b>Resultado do programa:</b></p><p>
<b></b>P1X:-3.14 Y:-2.17</p><p>
P2(1.5,1.5)</p><p>
</p><p>
<b>Exercícios:</b> </p><p>
1)Teste redefinição de função membro colocando
"cout's" em funções membro da hierarquia, tais como:
<code>cout &lt;&lt; "Redefinido!"; cout &lt;&lt; "Original!";
</code></p><p>
<b>
<a name="_Ref342699816"></a><a name="_Toc342736976"></a><a name="_Toc345409415"></a><a name="_Toc345810920"></a><a name="_Toc345838247"></a><a name="_Toc345942382"></a><a name="_Toc345949542"></a><a name="_Toc346168659"></a><a name="_Toc348417102"></a><a name="_Toc348931358"></a><a name="_Toc353900797"></a><a name="_Toc353946327"></a></b><a name="_Toc353946327">
</a></p><h3><a name="_Toc353946327">
</a><a name="RTFToC37">2.1.4.
UMA HIERARQUIA DE LISTAS LIGADAS</a>
</h3>
<b></b><p>
<b>	</b>. Construiremos sem importar nenhum outro código, uma hierarquia
de listas ligadas especializadas. Um dos objetivos é obter uma
implementação de lista que possa ser reutilizada para
criação de pilhas e filas.</p><p>
</p><p>
</p><center><img src="TUTORIAL_unicamp_c++_files/lista.gif"></center>


<b>	</b>O desenho acima foi elaborado segundo  metodologia descrita no livro
"Object Oriented Modeling and Design" . A associação entre as
classes lista e nó é uma associação do tipo "has
many" enquanto que a associação entre a classe lista e as classes
<code>lista ultimo e lista ordenada </code>indica herança,
é uma associação do tipo "is a". Algumas
simplificações foram feitas do diagrama original.<b></b><p>
<b>	</b>No tópico sobre templates 0 modificaremos este exemplo para
suportar tipos parametrizados. No tópico sobre hierarquias de
implementação 2.2 usamos a versão de lista descrita aqui
para criar uma classe que implementa uma fila.</p><p>
<code></code></p><p><code>
<b></b></code></p><hr><p><code>
#ifndef MLISTH_H</code></p><p><code>
#define MLISTH_H</code></p><p><code>
#include &lt;stdlib.h&gt;</code></p><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
//Criacao de uma hierarquia de listas ligadas.</code></p><p><code>
//O elemento da lista e' um inteiro</code></p><p><code>
enum Boolean{FALSE,TRUE};</code></p><p><code>
</code></p><p><code>
class no{ //este e' o no da lista ligada, so e' usado por ela</code></p><p><code>
private:</code></p><p><code>
 int info; //informacao</code></p><p><code>
 no* prox; //ponteiro para o proximo</code></p><p><code>
public:</code></p><p><code>
 no();</code></p><p><code>
 no(int i,no* p);</code></p><p><code>
 no* get_prox(void);</code></p><p><code>
 void set_prox(no* p);</code></p><p><code>
 int get_info(void);</code></p><p><code>
 void set_info(int i);</code></p><p><code>
 no* dobra(void);</code></p><p><code>
 ~no(void);</code></p><p><code>
} ;</code></p><p><code>
</code></p><p><code>
class lista{ //esta e' a lista ligada comum.</code></p><p><code>
protected: //"visivel hierarquia abaixo"</code></p><p><code>
	no* primeiro; //primeiro no da lista, aqui eu insiro e removo.</code></p><p><code>
public:</code></p><p><code>
lista(void);</code></p><p><code>
Boolean vazia(void)const;</code></p><p><code>
Boolean contem(int el)const;</code></p><p><code>
void insere_primeiro(int elem);</code></p><p><code>
int* remove_primeiro();</code></p><p><code>
void mostra()const;</code></p><p><code>
~lista(void);</code></p><p><code>
}; //fim classe lista</code></p><p><code>
</code></p><p><code>
class listaultimo:public lista { //essa e a lista util para</code></p><p><code>
//implementar pilhas e filas.</code></p><p><code>
protected: //protected e uma opcao outra e' get_ultimo() e set_...</code></p><p><code>
  no* ultimo;</code></p><p><code>
public:</code></p><p><code>
listaultimo(void);</code></p><p><code>
void insere_ultimo(int elem); //nova</code></p><p><code>
void insere_primeiro(int elem); //redefinicao</code></p><p><code>
int* remove_primeiro();//redefinicao</code></p><p><code>
~listaultimo(void);</code></p><p><code>
//as operacoes nao redefinidas sao validas.</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
class listaordenada:public lista {</code></p><p><code>
//essa e' a lista comum com aprimoramentos/especializacoes</code></p><p><code>
public:</code></p><p><code>
listaordenada(void);</code></p><p><code>
Boolean contem(int el)const;</code></p><p><code>
void insere_primeiro(int elem);</code></p><p><code>
//insere em ordem</code></p><p><code>
int* remove_elemento(int el);</code></p><p><code>
//remove elemento el se existir</code></p><p><code>
~listaordenada(void);</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
#endif</code></p><p><code>
<b></b></code></p><p><code>
<b></b></code></p><hr><p><code>
<b></b></code></p><p><code>
<b></b>#include "mlisth.h"</code></p><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
#include &lt;stdlib.h&gt;</code></p><p><code>
no::no()</code></p><p><code>
{prox=NULL;cout &lt;&lt; "Hi";}</code></p><p><code>
no::no(int i,no* p)</code></p><p><code>
{info=i;prox=p;cout &lt;&lt; "Hi";}</code></p><p><code>
no* no::get_prox(void){return prox;}</code></p><p><code>
void no::set_prox(no* p) {prox=p;}</code></p><p><code>
int no::get_info(void) {return info;}</code></p><p><code>
void no::set_info(int i) {info=i;}</code></p><p><code>
no* no::dobra(void)</code></p><p><code>
{</code></p><p><code>
if (get_prox()==NULL) return new no(get_info(),NULL);</code></p><p><code>
else return new no(get_info(),this-&gt;get_prox()-&gt;dobra());</code></p><p><code>
//recursividade para duplicacao da lista</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
no::~no(void) {cout &lt;&lt; "bye";}</code></p><p><code>
</code></p><p><code>
lista::lista(void):primeiro(NULL) {}</code></p><p><code>
//bloco de codigo vazio</code></p><p><code>
</code></p><p><code>
Boolean lista::vazia(void)const</code></p><p><code>
{</code></p><p><code>
return Boolean(primeiro==NULL);</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
Boolean lista::contem(int el) const//mais rapido que iterador</code></p><p><code>
{</code></p><p><code>
 no* curr;</code></p><p><code>
 int Conti;</code></p><p><code>
 curr=primeiro;</code></p><p><code>
 Conti=TRUE;</code></p><p><code>
 while ((curr!=NULL) &amp;&amp; Conti )</code></p><p><code>
 {</code></p><p><code>
  if (curr-&gt;get_info()!=el)</code></p><p><code>
	 {if (curr-&gt;get_prox()==NULL) Conti=FALSE; else
curr=curr-&gt;get_prox();}</code></p><p><code>
  else</code></p><p><code>
	Conti=FALSE;</code></p><p><code>
 };  //while</code></p><p><code>
  return Boolean(curr-&gt;get_info()==el);</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
void lista::insere_primeiro(int elem)</code></p><p><code>
{</code></p><p><code>
no* insirame;</code></p><p><code>
 if (primeiro==NULL) //lista vazia</code></p><p><code>
	 primeiro=new no(elem,NULL);</code></p><p><code>
 else {</code></p><p><code>
		 insirame=new no(elem,primeiro);</code></p><p><code>
		 primeiro=insirame;</code></p><p><code>
		};</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
int* lista::remove_primeiro()</code></p><p><code>
 {</code></p><p><code>
 int* devolvame=new int; //return</code></p><p><code>
 no* temp;     //to delete</code></p><p><code>
 if (primeiro==NULL)  return NULL; //lista vazia</code></p><p><code>
 else {</code></p><p><code>
		 (*devolvame)=primeiro-&gt;get_info();</code></p><p><code>
		 temp=primeiro;</code></p><p><code>
		 primeiro=primeiro-&gt;get_prox();</code></p><p><code>
		 delete temp;</code></p><p><code>
		 return devolvame;</code></p><p><code>
		};</code></p><p><code>
 };</code></p><p><code>
</code></p><p><code>
void lista::mostra() const</code></p><p><code>
{</code></p><p><code>
no* curr;</code></p><p><code>
cout &lt;&lt; "=";</code></p><p><code>
curr=primeiro;</code></p><p><code>
while (curr!=NULL)</code></p><p><code>
 {</code></p><p><code>
  cout &lt;&lt;"("&lt;&lt;curr-&gt;get_info()&lt;&lt;")"&lt;&lt;"-";</code></p><p><code>
  curr=curr-&gt;get_prox();</code></p><p><code>
 };</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
lista::~lista(void)</code></p><p><code>
{</code></p><p><code>
 no* temp;</code></p><p><code>
  while (primeiro!=NULL)</code></p><p><code>
  {</code></p><p><code>
  temp=primeiro;</code></p><p><code>
  primeiro=primeiro-&gt;get_prox();</code></p><p><code>
  delete temp;</code></p><p><code>
  };</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
listaordenada::listaordenada(void):lista()</code></p><p><code>
{};</code></p><p><code>
</code></p><p><code>
Boolean listaordenada::contem(int el)const</code></p><p><code>
{</code></p><p><code>
no* curr;</code></p><p><code>
Boolean conti=TRUE;</code></p><p><code>
 curr=primeiro;</code></p><p><code>
 while ((curr!=NULL) &amp;&amp; conti)</code></p><p><code>
 {</code></p><p><code>
  if (curr-&gt;get_info()&lt;el)</code></p><p><code>
  curr=curr-&gt;get_prox();</code></p><p><code>
  else conti=FALSE;</code></p><p><code>
 };</code></p><p><code>
 if (curr==NULL) return FALSE;</code></p><p><code>
 else return Boolean(curr-&gt;get_info()==el);</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
void listaordenada::insere_primeiro(int elem)</code></p><p><code>
{</code></p><p><code>
no* curr=primeiro;</code></p><p><code>
no* prev=NULL;</code></p><p><code>
no* insirame;</code></p><p><code>
Boolean conti=TRUE;</code></p><p><code>
 while ((curr!=NULL) &amp;&amp; conti)</code></p><p><code>
 {</code></p><p><code>
  if (curr-&gt;get_info()&lt;elem)</code></p><p><code>
  {prev=curr; curr=curr-&gt;get_prox();}</code></p><p><code>
  else conti=FALSE;</code></p><p><code>
 };</code></p><p><code>
 insirame=new no(elem,curr);</code></p><p><code>
 if (prev==NULL) primeiro=insirame;</code></p><p><code>
  else prev-&gt;set_prox(insirame);</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
int* listaordenada::remove_elemento(int el)</code></p><p><code>
{</code></p><p><code>
int* devolvame=new int;</code></p><p><code>
no* curr=primeiro;</code></p><p><code>
no* prev=NULL;</code></p><p><code>
no* deleteme;</code></p><p><code>
Boolean conti=TRUE;</code></p><p><code>
 while ((curr!=NULL) &amp;&amp; conti) //acha lugar onde pode estar el</code></p><p><code>
 {</code></p><p><code>
  if (curr-&gt;get_info()&lt;el)</code></p><p><code>
  {prev=curr; curr=curr-&gt;get_prox();} //anda</code></p><p><code>
  else conti=FALSE;</code></p><p><code>
 };</code></p><p><code>
 if (curr==NULL) return NULL; //fim de lista ou vazia</code></p><p><code>
 else //pode ser o elemento ou ele nao existe</code></p><p><code>
  {</code></p><p><code>
	 if (curr-&gt;get_info()==el)</code></p><p><code>
	  {</code></p><p><code>
		deleteme=curr;</code></p><p><code>
		if (prev==NULL) //lista so com um elemento ou primeiro el</code></p><p><code>
		  primeiro=curr-&gt;get_prox();</code></p><p><code>
		else</code></p><p><code>
		 {</code></p><p><code>
		  prev-&gt;set_prox(curr-&gt;get_prox());</code></p><p><code>
		 }</code></p><p><code>
		(*devolvame)=deleteme-&gt;get_info(); //so para verificar</code></p><p><code>
		delete deleteme;</code></p><p><code>
		return devolvame;</code></p><p><code>
	  }</code></p><p><code>
	 else return NULL;</code></p><p><code>
  }</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
listaordenada::~listaordenada(void)</code></p><p><code>
{cout &lt;&lt; "Lista destruida.";};</code></p><p><code>
</code></p><p><code>
listaultimo::listaultimo(void):lista()</code></p><p><code>
{</code></p><p><code>
ultimo=NULL;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
void listaultimo::insere_ultimo(int elem)</code></p><p><code>
{</code></p><p><code>
no* insirame;</code></p><p><code>
insirame=new no(elem,NULL);</code></p><p><code>
if (ultimo==NULL) ultimo=insirame; //lista vazia</code></p><p><code>
else {</code></p><p><code>
		ultimo-&gt;set_prox(insirame);</code></p><p><code>
		ultimo=insirame;</code></p><p><code>
		};</code></p><p><code>
if (primeiro==NULL) primeiro=ultimo; //lista vazia</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
void listaultimo::insere_primeiro(int elem) //redefinicao</code></p><p><code>
{</code></p><p><code>
no* insirame;</code></p><p><code>
 if (primeiro==NULL) //lista vazia</code></p><p><code>
	{</code></p><p><code>
	 primeiro=new no(elem,ultimo);</code></p><p><code>
	 ultimo=primeiro;</code></p><p><code>
	}//lista vazia</code></p><p><code>
 else {</code></p><p><code>
		 insirame=new no(elem,primeiro);</code></p><p><code>
		 primeiro=insirame;</code></p><p><code>
		};</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
int* listaultimo::remove_primeiro()//redefinicao</code></p><p><code>
{</code></p><p><code>
int* devolvame=new int; //return</code></p><p><code>
 no* temp;     //to delete</code></p><p><code>
 if (primeiro==NULL)  return NULL; //lista vazia</code></p><p><code>
 else {</code></p><p><code>
		 (*devolvame)=primeiro-&gt;get_info();</code></p><p><code>
		 temp=primeiro;</code></p><p><code>
		 primeiro=primeiro-&gt;get_prox();</code></p><p><code>
		 delete temp;</code></p><p><code>
		 if (primeiro==NULL) ultimo=NULL; //volta lista vazia</code></p><p><code>
		 return devolvame;</code></p><p><code>
		};</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
listaultimo::~listaultimo(void)</code></p><p><code>
{</code></p><p><code>
 no* temp;</code></p><p><code>
  while (primeiro!=NULL)</code></p><p><code>
  {</code></p><p><code>
  temp=primeiro;</code></p><p><code>
  primeiro=primeiro-&gt;get_prox();</code></p><p><code>
  delete temp;</code></p><p><code>
  };</code></p><p><code>
  delete ultimo;</code></p><p><code>
}</code></p><p><code>
<b></b></code></p><p><code>
<b></b></code></p><hr><p><code>
<b></b></code></p><p><code>
<b></b>#include "mlisth.h"</code></p><p><code>
main()</code></p><p><code>
{</code></p><p><code>
listaordenada minha;</code></p><p><code>
char option; //use in menu as option variable</code></p><p><code>
int el; //elemento a inserir</code></p><p><code>
int* receptor;</code></p><p><code>
do {</code></p><p><code>
 cout &lt;&lt;"\n";   //menu options display</code></p><p><code>
 cout &lt;&lt;"P:Insere no primeiro.\n";</code></p><p><code>
 cout &lt;&lt;"R:Remove no primeiro.\n";</code></p><p><code>
 cout &lt;&lt;"D:Remove elemento.\n";</code></p><p><code>
 cout &lt;&lt;"E:Existe elemento?\n";</code></p><p><code>
 cout &lt;&lt;"V:Vazia?\n";</code></p><p><code>
 cout &lt;&lt;"M:Mostra lista.\n";</code></p><p><code>
 cout &lt;&lt;"Q:Quit teste lista.\n";</code></p><p><code>
 cout &lt;&lt;"Entre comando:";</code></p><p><code>
 cin &gt;&gt; option; //reads user option</code></p><p><code>
 switch(option) //executes user option</code></p><p><code>
 {</code></p><p><code>
  case 'D':</code></p><p><code>
  case 'd':</code></p><p><code>
				cout &lt;&lt; "Entre elemento:";</code></p><p><code>
				cin &gt;&gt;el;</code></p><p><code>
				receptor=minha.remove_elemento(el);</code></p><p><code>
				if (receptor==NULL) cout &lt;&lt; "NULL" &lt;&lt; endl;</code></p><p><code>
				else cout &lt;&lt; (*receptor) &lt;&lt; endl;</code></p><p><code>
				break;</code></p><p><code>
  case 'P':</code></p><p><code>
  case 'p':</code></p><p><code>
				cout &lt;&lt; "Entre elemento:";</code></p><p><code>
				cin &gt;&gt; el;</code></p><p><code>
				minha.insere_primeiro(el);</code></p><p><code>
				break;</code></p><p><code>
  case 'R':</code></p><p><code>
  case 'r':</code></p><p><code>
				if (!minha.vazia())</code></p><p><code>
				cout &lt;&lt; (*minha.remove_primeiro()) &lt;&lt;endl;</code></p><p><code>
				else cout &lt;&lt; "NULL, Lista vazia." &lt;&lt;endl;</code></p><p><code>
				break;</code></p><p><code>
  case 'M':</code></p><p><code>
  case 'm':</code></p><p><code>
				minha.mostra();</code></p><p><code>
				break;</code></p><p><code>
  case 'E':</code></p><p><code>
  case 'e':</code></p><p><code>
				cout &lt;&lt; "Entre elemento:";</code></p><p><code>
				cin &gt;&gt;el;</code></p><p><code>
				cout &lt;&lt; minha.contem(el);</code></p><p><code>
				break;</code></p><p><code>
  case 'V':</code></p><p><code>
  case 'v':</code></p><p><code>
				cout &lt;&lt; minha.vazia();</code></p><p><code>
				break;</code></p><p><code>
  default:  ;</code></p><p><code>
 }  //switch-case code block</code></p><p><code>
} while ((option!='Q') &amp;&amp; (option!='q'));  //menu loop code block</code></p><p><code>
</code></p><p><code>
return 0;</code></p><p><code>
}  //main code block</code></p><p><code>
<b></b></code></p><hr><p><code>
</code><b>Comentários: </b></p><p>
<b>	</b>Note que o programa principal só testa a lista ordenada, em
outros programas exemplo baseados neste veremos testes para a<code>
lista_ultimo. </code></p><p>
<b></b></p><p>
<b>Exercícios:</b></p><p>
<b></b>1)Experimente derivar (criar classes herdeiras) outras classes lista com
propriedades de seu interesse tais como obtenção de sublista.</p><p>
</p><p>
2)Introduza na classe lista a contagem do número de elementos numa
lista.</p><p>
</p><p>
3)Crie uma função membro chamado<code> void
remove_todos(void); </code>que simplesmente deixa a lista vazia.</p><p>
</p><p>
*4)Suponha que você é um programador de uma empresa e teve que
implementar a hierarquia de listas para seu  grupo de desenvolvimento, segundo
uma especificação dada pelo seu chefe. </p><p>
	Você introduziria as mudanças sugeridas nos exercícios
anteriores, mesmo sabendo que elas não estavam na
especificação? Que dificuldade um usuário de sua classe
lista teria para introduzi-las caso surgisse a necessidade e você
não tivesse feito? </p><p>
	Discuta as seguintes maneiras de um programador de seu grupo conseguir o
efeito desejado de adicionar as sugestões dos exercícios
anteriores a hierarquia: usar herança (derivar uma classe com
<code>void remove_todos(void) </code>), alterar o código
original, pedir para você o programador do código original mudar a
implementação. Lembre-se que pode existir mais de um programador
usando a versão original da hierarquia de listas.</p><p>
<b>
<a name="_Ref342315645"></a><a name="_Toc342736977"></a><a name="_Toc345409416"></a><a name="_Toc345810921"></a><a name="_Toc345838248"></a><a name="_Toc345942383"></a><a name="_Toc345949543"></a><a name="_Toc346168660"></a><a name="_Toc348417103"></a><a name="_Toc348931359"></a><a name="_Toc353900798"></a><a name="_Toc353946328"></a></b><a name="_Toc353946328">
</a></p><h2><a name="_Toc353946328">
</a><a name="RTFToC38">2.2.
HIERARQUIAS DE
IMPLEMENTAÇÃO</a>
</h2>
<b></b><p>
<b></b>	Nossas hierarquias de implementação em termos de
código (herança) não são hierarquias, usamos
delegação para obter pilhas a partir listas. Agregamos uma lista
em nossas classes e usamos esta lista de acordo com a lógica envolvida.
Tudo o que fizemos poderia ser feito usando herança<code> private,
</code>o que justificaria o título "hierarquias de
implementação", embora tornasse o nosso texto menos
acadêmico.</p><p>
<a name="_Toc342736978"></a><a name="_Toc345409417"></a><a name="_Toc345810922"></a><a name="_Toc345838249"></a><a name="_Toc345942384"></a><a name="_Toc345949544"></a><a name="_Toc346168661"></a><a name="_Toc348417104"></a><a name="_Toc348931360"></a><a name="_Toc353900799"></a><a name="_Toc353946329">
</a></p><h3><a name="_Toc353946329">
</a><a name="RTFToC39">2.2.1.
FILA A PARTIR DE UMA LISTA</a>
</h3>
<b></b><p>
<b>	</b>Reuso  de código de uma lista ligada 2.1  para a
implementação de uma fila através de
agregação.  Para podermos declarar e usar um objeto lista na
nossa classe fila precisamos conhecer sua interface. Sabemos que nosso objeto
lista permite inserir em ambas extremidades, inicio e fim da lista, mas
só permite remoções em um extremo, o inicio. Como uma fila
permite inserções somente num extremo e remoções
nos extremo oposto, precisaremos usar nossa lista da seguinte forma:
inserção no final da lista e remoções no
começo.<b></b></p><p>
<b>	</b>Seguem abaixo exemplos de chamadas de funções membro da
classe lista implementada em 2.1 para trabalhar com números inteiros.</p><p>
<b></b></p><p>
<b></b>Consideremos uma lista al, são válidas as seguintes
operações:</p><p>
<code><b></b></code></p><p><code>
<b></b>al.vazia(); //retorna se a lista (fila agora) esta vazia.</code></p><p><code>
al.contem(el); //retorna 1 se el pertence a lista e 0 se el nao pertence a
lista.</code></p><p><code>
al.insere_ultimo(el);     //insere no final da lista (entrada da fila).</code></p><p><code>
al.insere_primeiro(el); //nao usaremos na implementacao de fila, usariamos se
//implementassemos uma pilha.</code></p><p><code>
al.remove_primeiro(); //remove no comeco da lista (saida da fila).</code></p><p><code>
al.mostra(); //mostra lista (mostra fila em ordem contraria de insercao)</code></p><p><code>
</code><b></b></p><p>
<b></b>	Para maiores informações consulte tópico anterior
onde definimos esta lista. Por este motivo não vamos incluir sua
definição a seguir.
<a name="_Ref342134189"></a><a name="_Toc342736979"></a><a name="_Toc345409418"></a></p><p><a name="_Toc345409418">
<code></code></a></p><p><a name="_Toc345409418"><code>
<b></b></code></a></p><hr><p><a name="_Toc345409418"><code>
//header file para a classe fila</code></a></p><p><a name="_Toc345409418"><code>
#include "mlisth.h"</code></a></p><p><a name="_Toc345409418"><code>
class fila { //agregacao de uma lista de</code></a></p><p><a name="_Toc345409418"><code>
private:</code></a></p><p><a name="_Toc345409418"><code>
 listaultimo al;  //a lista</code></a></p><p><a name="_Toc345409418"><code>
public:</code></a></p><p><a name="_Toc345409418"><code>
 fila();</code></a></p><p><a name="_Toc345409418"><code>
 Boolean vazia();</code></a></p><p><a name="_Toc345409418"><code>
 Boolean contem(int el);</code></a></p><p><a name="_Toc345409418"><code>
 void insere(int el);</code></a></p><p><a name="_Toc345409418"><code>
 int* remove();</code></a></p><p><a name="_Toc345409418"><code>
 void mostra();</code></a></p><p><a name="_Toc345409418"><code>
};</code></a></p><p><a name="_Toc345409418"><code>
</code></a></p><p><a name="_Toc345409418"><code>
</code></a></p><p><a name="_Toc345409418"><code>
<b></b></code></a></p><hr><p><a name="_Toc345409418"><code>
<b></b></code></a></p><p><a name="_Toc345409418"><code>
//implementacao para a classe fila</code></a></p><p><a name="_Toc345409418"><code>
#include "mqueue.h"</code></a></p><p><a name="_Toc345409418"><code>
#include "mlisth.h"</code></a></p><p><a name="_Toc345409418"><code>
fila::fila(){};</code></a></p><p><a name="_Toc345409418"><code>
</code></a></p><p><a name="_Toc345409418"><code>
Boolean fila::vazia()</code></a></p><p><a name="_Toc345409418"><code>
	{return al.vazia();}</code></a></p><p><a name="_Toc345409418"><code>
</code></a></p><p><a name="_Toc345409418"><code>
Boolean fila::contem(int el)</code></a></p><p><a name="_Toc345409418"><code>
	{return al.contem(el);}</code></a></p><p><a name="_Toc345409418"><code>
</code></a></p><p><a name="_Toc345409418"><code>
void fila::insere(int el)</code></a></p><p><a name="_Toc345409418"><code>
	{al.insere_ultimo(el);}</code></a></p><p><a name="_Toc345409418"><code>
</code></a></p><p><a name="_Toc345409418"><code>
int* fila::remove()</code></a></p><p><a name="_Toc345409418"><code>
	{return al.remove_primeiro();}</code></a></p><p><a name="_Toc345409418"><code>
</code></a></p><p><a name="_Toc345409418"><code>
void fila::mostra()</code></a></p><p><a name="_Toc345409418"><code>
	{al.mostra();}</code></a></p><p><a name="_Toc345409418"><code>
</code></a></p><p><a name="_Toc345409418"><code>
<b></b></code></a></p><hr><p><a name="_Toc345409418"><code>
<b></b></code></a></p><p><a name="_Toc345409418"><code>
//programa principal, testes da classe fila</code></a></p><p><a name="_Toc345409418"><code>
#include "mqueue.h"</code></a></p><p><a name="_Toc345409418"><code>
main()</code></a></p><p><a name="_Toc345409418"><code>
{</code></a></p><p><a name="_Toc345409418"><code>
fila minha;</code></a></p><p><a name="_Toc345409418"><code>
char option; //usada em menu como variavel de opcao</code></a></p><p><a name="_Toc345409418"><code>
int el; //elemento a inserir</code></a></p><p><a name="_Toc345409418"><code>
do {</code></a></p><p><a name="_Toc345409418"><code>
 cout &lt;&lt;"\n";   //opcoes do menu</code></a></p><p><a name="_Toc345409418"><code>
 cout &lt;&lt;"I:Insere.\n";</code></a></p><p><a name="_Toc345409418"><code>
 cout &lt;&lt;"R:Remove.\n";</code></a></p><p><a name="_Toc345409418"><code>
 cout &lt;&lt;"M:Mostra fila.\n";</code></a></p><p><a name="_Toc345409418"><code>
 cout &lt;&lt;"Q:Quit fila test.\n";</code></a></p><p><a name="_Toc345409418"><code>
 cout &lt;&lt;"V:Vazia?\n";</code></a></p><p><a name="_Toc345409418"><code>
 cout &lt;&lt;"C:Contem?\n";</code></a></p><p><a name="_Toc345409418"><code>
 cout &lt;&lt;"Entre comando:";</code></a></p><p><a name="_Toc345409418"><code>
 cin &gt;&gt; option; //le opcao do usuario</code></a></p><p><a name="_Toc345409418"><code>
 switch(option) //executa opcao do usuario</code></a></p><p><a name="_Toc345409418"><code>
 {</code></a></p><p><a name="_Toc345409418"><code>
  case 'I':</code></a></p><p><a name="_Toc345409418"><code>
  case 'i':</code></a></p><p><a name="_Toc345409418"><code>
				cout &lt;&lt; "Entre elemento:";</code></a></p><p><a name="_Toc345409418"><code>
				cin &gt;&gt;el;</code></a></p><p><a name="_Toc345409418"><code>
				minha.insere(el);</code></a></p><p><a name="_Toc345409418"><code>
				break;</code></a></p><p><a name="_Toc345409418"><code>
  case 'R':</code></a></p><p><a name="_Toc345409418"><code>
  case 'r':</code></a></p><p><a name="_Toc345409418"><code>
				if (!minha.vazia())</code></a></p><p><a name="_Toc345409418"><code>
				cout &lt;&lt; (*minha.remove()) &lt;&lt;endl;</code></a></p><p><a name="_Toc345409418"><code>
				else cout &lt;&lt; "NULL, fila vazia." &lt;&lt;endl;</code></a></p><p><a name="_Toc345409418"><code>
				break;</code></a></p><p><a name="_Toc345409418"><code>
  case 'C':</code></a></p><p><a name="_Toc345409418"><code>
  case 'c':</code></a></p><p><a name="_Toc345409418"><code>
				cout &lt;&lt; "Entre elemento:";</code></a></p><p><a name="_Toc345409418"><code>
				cin &gt;&gt;el;</code></a></p><p><a name="_Toc345409418"><code>
				cout &lt;&lt; minha.contem(el);</code></a></p><p><a name="_Toc345409418"><code>
				break;</code></a></p><p><a name="_Toc345409418"><code>
  case 'M':</code></a></p><p><a name="_Toc345409418"><code>
  case 'm':</code></a></p><p><a name="_Toc345409418"><code>
				minha.mostra();</code></a></p><p><a name="_Toc345409418"><code>
				break;</code></a></p><p><a name="_Toc345409418"><code>
  case 'V':</code></a></p><p><a name="_Toc345409418"><code>
  case 'v':</code></a></p><p><a name="_Toc345409418"><code>
				cout &lt;&lt; "Resultado:" &lt;&lt; minha.vazia() &lt;&lt;endl;</code></a></p><p><a name="_Toc345409418"><code>
				break;</code></a></p><p><a name="_Toc345409418"><code>
  default:  ;</code></a></p><p><a name="_Toc345409418"><code>
 }  //switch-case bloco de codigo</code></a></p><p><a name="_Toc345409418"><code>
} while ((option!='Q') &amp;&amp; (option!='q'));  //loop do menu fim</code></a></p><p><a name="_Toc345409418"><code>
</code></a></p><p><a name="_Toc345409418"><code>
return 0;</code></a></p><p><a name="_Toc345409418"><code>
}  // bloco de codigo principal</code></a></p><p><a name="_Toc345409418"><code>
<b></b></code></a></p><hr><p><a name="_Toc345409418"><code>
</code></a></p><p><a name="_Toc345409418">
</a><a name="_Toc345810923"></a><a name="_Toc345838250"></a><a name="_Toc345942385"></a><a name="_Toc345949545"></a><a name="_Toc346168662"></a><a name="_Toc348417105"></a><a name="_Ref348536485"></a><a name="_Toc348931361"></a><a name="_Toc353900800"></a><a name="_Toc353946330">
</a></p><h1><a name="_Toc353946330">
</a><a name="RTFToC40">3.
POLIMORFISMO, FUNÇÕES
VIRTUAIS</a>
</h1>
<b></b><p>
<b>	</b>.Existem vários tipos de polimorfismo. No que se refere a
objetos, Modula-3 apresenta polimorfismos classificados como universais,
exemplos de  polimorfismos do tipo "ad-hoc" e objetos podem ser encontrados em
outras linguagens como C++.</p><p>
<b>
<a name="_Toc342736980"></a><a name="_Toc345409419"></a><a name="_Toc345810924"></a><a name="_Toc345838251"></a><a name="_Toc345942386"></a><a name="_Toc345949546"></a><a name="_Toc346168663"></a><a name="_Toc348417106"></a><a name="_Toc348931362"></a><a name="_Toc353900801"></a><a name="_Toc353946331"></a></b><a name="_Toc353946331">
</a></p><h2><a name="_Toc353946331">
</a><a name="RTFToC41">3.1.
O QUE SIGNIFICA POLIMORFISMO</a>
</h2>
<b></b><p>
<b></b>	Polimorfismo, do grego: muitas formas. Polimorfismo é a
capacidade de um operador executar a ação apropriada dependendo
do tipo do operando. Aqui operando e operador estão definidos num
sentido mais geral: operando pode significar argumentos atuais de um
procedimento e operador o procedimento, operando pode significar um objeto e
operador um método, operando pode significar um tipo e operador um
objeto deste tipo.
<a name="_Toc342736981"></a><a name="_Toc345409420"></a><a name="_Toc345810925"></a><a name="_Toc345838252"></a><a name="_Toc345942387"></a><a name="_Toc345949547"></a><a name="_Toc346168664"></a><a name="_Toc348417107"></a><a name="_Toc348931363"></a><a name="_Toc353900802"></a><a name="_Toc353946332">
</a></p><h3><a name="_Toc353946332">
</a><a name="RTFToC42">3.1.1.
SOBRECARGA DE</a> MÉTODOS
</h3>
<p>
	Modula-3 não oferece este tipo de polimorfismo que pode ser considerado
com "ad-hoc". Este tipo de polimorfismo permitiria a existência de
vários procedimentos e métodos de mesmo nome, porém com
assinaturas levemente diferentes, variando no número e tipo de
argumentos. Ficaria a cargo do compilador escolher de acordo com as listas de
argumentos os procedimentos ou métodos a serem executados.</p><p>
<a name="_Toc342736982"></a><a name="_Toc345409421"></a><a name="_Toc345810926"></a><a name="_Toc345838253"></a><a name="_Toc345942388"></a><a name="_Toc345949548"></a><a name="_Toc346168665"></a><a name="_Toc348417108"></a><a name="_Toc348931364"></a><a name="_Toc353900803"></a><a name="_Toc353946333">
</a></p><h3><a name="_Toc353946333">
</a><a name="RTFToC43">3.1.2.
REDEFINIÇÃO DE UMA FUNÇÃO MEMBRO PARA UMA
CLASSE HERDEIRA</a>
</h3>
<p>
	.Este exemplo já foi apresentado em 2.1.3. Também trata-se de um
polimorfismo, pode ser classificado como polimorfismo de inclusão.
<a name="_Toc342736983"></a><a name="_Toc345409422"></a><a name="_Toc345810927"></a><a name="_Toc345838254"></a><a name="_Toc345942389"></a><a name="_Toc345949549"></a><a name="_Toc346168666"></a><a name="_Toc348417109"></a><a name="_Toc348931365"></a><a name="_Toc353900804"></a><a name="_Toc353946334">
</a></p><h3><a name="_Toc353946334">
</a><a name="RTFToC44">3.1.3.
"COPY CONSTRUCTOR"</a>
</h3>
<b>	</b><p>
<b></b>	A função membro<code> ponto(ponto&amp; a);
</code>é um copy constructor, além disso tem o mesmo nome
que  <code>ponto(float dx,float dy);. </code>Tal
duplicação de nomes pode parecer estranha, porém C++
permite que eles coexistam para uma classe porque não tem a mesma
assinatura (nome+argumentos). Isto se chama  sobrecarga de função
membro, o compilador sabe distinguir entre esses dois construtores. Outras
funções membro, não só construtores poderão
ser redefinidas, ou sobrecarregadas para vários argumentos diferentes,
esse recurso é um  polimorfismo do tipo "ad-hoc".</p><p>
</p><p>
	O que é interessante para nós é o fato de o argumento do
construtor<code> <b>ponto</b>(<b>ponto</b>&amp; a); </code> ser da
mesma classe para qual o  construtor foi implementado, esse é o chamado
"copy  constructor". Ele usa um objeto de seu tipo para se inicializar. Outros
métodos semelhantes seriam: <code>circulo(circulo&amp; a);
mouse(mouse&amp; d);. </code>Implementar copy constructor pode ser muito
importante, lembre-se dos problemas com cópias de objetos apresentados
em 1.5.3.5.</p><p>
<code></code></p><p><code>
<b></b></code></p><hr><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
</code></p><p><code>
struct ponto</code></p><p><code>
{</code></p><p><code>
float x;</code></p><p><code>
float y;</code></p><p><code>
</code></p><p><code>
ponto(float a,float b);</code></p><p><code>
//construtor tambem pode ser inline ou nao</code></p><p><code>
</code></p><p><code>
ponto(ponto&amp; a); //copy constructor</code></p><p><code>
void mostra(void);</code></p><p><code>
void move(float dx,float dy);</code></p><p><code>
</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
ponto::ponto(float a,float b)</code></p><p><code>
{</code></p><p><code>
 x=a;</code></p><p><code>
 y=b;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
ponto::ponto(ponto&amp; a)</code></p><p><code>
{</code></p><p><code>
x=a.x;</code></p><p><code>
y=a.y;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
void ponto::mostra(void)</code></p><p><code>
{cout &lt;&lt; "X:" &lt;&lt; x &lt;&lt; " , Y:" &lt;&lt; y &lt;&lt; endl;}</code></p><p><code>
</code></p><p><code>
void ponto::move(float dx,float dy)</code></p><p><code>
{</code></p><p><code>
 x+=dx;</code></p><p><code>
 y+=dy;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
void main()</code></p><p><code>
{</code></p><p><code>
ponto ap(0.0,0.0);</code></p><p><code>
ap.mostra();</code></p><p><code>
ap.move(1.0,1.0);</code></p><p><code>
ap.mostra();</code></p><p><code>
ponto ap2(ap);</code></p><p><code>
ap2.mostra();</code></p><p><code>
}</code></p><p><code>
<b></b></code></p><hr><p><code>
</code></p><p>
<b>Comentários:</b> </p><p>
	Observe o código: <code></code></p><p><code>
ponto::ponto(ponto&amp; a)</code></p><p><code>
{</code></p><p><code>
x=a.x;</code></p><p><code>
y=a.y;</code></p><p><code>
}</code></p><p><code>
</code></p><p>
	Essa função membro, esse método, pertence a outro objeto
que não o argumento a, então para distinguir o
atributo<code> x </code>deste objeto, do atributo
<code>x</code> de a usamos <code>a.x</code> e
simplesmente<code> x </code>para o objeto local (dono da
função membro).</p><p>
</p><p>
<b>Exercícios:</b></p><p>
1)O copy constructor usa passagem por referência, construa uma
função que troca duas variáveis inteiras usando passagem
por referência. Analise esse recurso sob a ótica do assunto
encapsulamento. Em que casos você pode afirmar ser seguro usar esse
recurso?</p><p>
</p><p>
2) Defina um copy constructor para o tipo abstrato de dados
fração apresentado em: 1.4.
</p><h3>
<a name="RTFToC45">3.1.4.
</a><a name="_Toc342736984"></a><a name="_Toc345409423"></a><a name="_Toc345810928"></a><a name="_Toc345838255"></a><a name="_Toc345942390"></a><a name="_Toc345949550"></a><a name="_Toc346168667"></a><a name="_Toc348417110"></a><a name="_Toc348931366"></a><a name="_Toc353900805"></a><a name="_Toc353946335">
SOBRECARGA DE FUNÇÃO EM
C++.</a>
</h3>
<b></b><p>
<b>	</b>Este tópico apresenta exemplos importantes para o estudo do
restante do tutorial.<b></b></p><p>
<b>	</b>Sobrecarga "Overloading" de função é um tipo de
polimorfismo classificável como ad-hoc. C++ permite que
funções de mesmo nome tenham parâmetros distintos. Este
exemplo mostra a sobrecarga da função abs que calcula o valor
absoluto  de um número: <code></code></p><p><code>
<b></b></code></p><hr><p><code>
<b></b>//header file funcover.h</code></p><p><code>
float abs(float a);</code></p><p><code>
int abs(int a);</code></p><p><code>
<b></b></code></p><p><code>
<b></b></code></p><hr><p><code>
<b></b></code></p><p><code>
<b></b>//implementation file</code></p><p><code>
#include "funcover.h"</code></p><p><code>
</code></p><p><code>
float abs(float a)</code></p><p><code>
{</code></p><p><code>
 if (a&gt;0.0) return a;</code></p><p><code>
 else return -a;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
int abs(int a)</code></p><p><code>
{</code></p><p><code>
 if (a&gt;0) return a;</code></p><p><code>
 else return -a;</code></p><p><code>
}</code></p><p><code>
<b></b></code></p><p><code>
<b></b></code></p><hr><p><code>
<b></b></code></p><p><code>
<b></b>#include &lt;iostream.h&gt;</code></p><p><code>
#include "funcover.h"</code></p><p><code>
</code></p><p><code>
void main()</code></p><p><code>
{</code></p><p><code>
int i1;</code></p><p><code>
float f1;</code></p><p><code>
cout &lt;&lt; abs(int(-10))&lt;&lt;endl;</code></p><p><code>
cout &lt;&lt; abs(float(-10.1))&lt;&lt;endl;</code></p><p><code>
f1=-9.1;</code></p><p><code>
i1=8.0;</code></p><p><code>
cout &lt;&lt; abs(f1) &lt;&lt; endl;</code></p><p><code>
cout &lt;&lt; abs(i1) &lt;&lt; endl;</code></p><p><code>
}</code></p><p><code>
<b></b></code></p><hr><p><code>
</code><b></b></p><p>
<b>Resultado do programa:</b></p><p>
<b></b>10</p><p>
10.1</p><p>
9.1</p><p>
8</p><p>
<b></b></p><p>
<b>Comentários: </b></p><p>
<b></b><code>cout &lt;&lt; abs(float(-10.1))&lt;&lt;endl; </code></p><p>
	Perceba que quando chamamos a função abs para um valor (-10.1) e
não uma variável (possui um tipo), temos que fazer a
conversão explícita para o compilador, porque este  não
sabe decidir qual função chamar (para<code> float
</code>ou <code>int</code>), mesmo estando presente o ponto
indicando a casa decimal.</p><p>
Observe que -10.1 pode ser <code>double </code>ou
<code>float</code>. Enquanto que 10 pode ser
<code>long</code> ou <code>int. </code></p><p>
	No exemplo 4 veremos sobrecarga de operador, que é semelhante a
sobrecarga de função. Observe que os operadores<code> * -
</code> e até mesmo os operadores de
extração<code> &lt;&lt; &gt;&gt;</code> usados com
<code>cout </code> são exemplos de sobrecarga de operadores.
Eles já estão definidos com a mesma forma para um conjunto
restrito de tipos.</p><p>
<b></b></p><p>
<b>Exercícios:</b></p><p>
<b></b>1) Melhore este exemplo para que se calcule também o valor
absoluto de números em tipo <code>long. </code></p><p>
</p><p>
2)Crie um programa análogo a este exemplo só que agora com a
função <code>max </code>que deve calcular o
máximo de dois números.</p><p>
</p><p>
3)Crie um programa análogo a este exemplo só que agora com a
função<code> mdc </code>que deve calcular o
máximo divisor comum de dois números<code> int</code>
ou <code>long</code>.</p><p>
</p><p>
*4)Lembre-se de alguns programas que você tenha escrito em que se pudesse
fazer uso de funções sobrecarregadas. Comente de que modo tal uso
facilitaria tanto a programação quanto a manutenção
de software. De algum modo esse uso poderia atrapalhar o desenvolvimento do
programa? Se sim de que modo?</p><p>
<b></b></p><p>
<b></b>*5)Mude o código de uma das funções abs para
calcular o módulo do número elevando-o ao quadrado e extraindo a
raiz quadrada, eliminando assim o sinal. Você provavelmente vai precisar
da library <code>&lt;math.h&gt;</code> . Note que o que importa
para a sobrecarga é o cabeçalho, a assinatura da
função e não o código em si.</p><p>
<b></b></p><p>
<b>	</b>Este programa mostra algumas peripécias que podemos fazer com
sobrecarga de funções. Veja exemplo anterior primeiro.
<code></code></p><p><code>
<b></b></code></p><hr><p><code>
<b></b>//header file funcover.h</code></p><p><code>
float max(float a,float b);</code></p><p><code>
float max(float a,float b,float c);</code></p><p><code>
int max(int a,int b);</code></p><p><code>
<b></b></code></p><p><code>
<b></b></code></p><hr><p><code>
<b></b></code></p><p><code>
<b></b>#include "funcover.h"</code></p><p><code>
</code></p><p><code>
float max(float a,float b)</code></p><p><code>
{</code></p><p><code>
 if (a&gt;b) return a;</code></p><p><code>
 else return b;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
float max(float a,float b,float c)</code></p><p><code>
{</code></p><p><code>
 if (a&gt;b) return max(a,c);</code></p><p><code>
 else return max(b,c);</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
int max(int a,int b)</code></p><p><code>
{</code></p><p><code>
 if (a&gt;b) return a;</code></p><p><code>
 else return b;</code></p><p><code>
}</code></p><p><code>
<b></b></code></p><p><code>
<b></b></code></p><hr><p><code>
<b></b></code></p><p><code>
<b></b>#include &lt;iostream.h&gt;</code></p><p><code>
#include "funcover.h"</code></p><p><code>
</code></p><p><code>
void main()</code></p><p><code>
{</code></p><p><code>
cout &lt;&lt; max(float(1.2),float(3.4),float(2.1))&lt;&lt;endl;</code></p><p><code>
cout &lt;&lt; max(float(1.5),float(.65)) &lt;&lt; endl;</code></p><p><code>
cout &lt;&lt; max(int(12),int(120));</code></p><p><code>
}</code></p><p><code>
<b></b></code></p><hr><p><code>
</code></p><p><code>
</code><b></b></p><p>
<b>Resultado do programa:</b></p><p>
<b></b>3.4</p><p>
1.5</p><p>
120</p><p>
<b></b>
</p><h3>
<a name="RTFToC46">3.1.5.
</a><a name="_Toc342736985"></a><a name="_Toc345409424"></a><a name="_Toc345810929"></a><a name="_Toc345838256"></a><a name="_Toc345942391"></a><a name="_Toc345949551"></a><a name="_Toc346168668"></a><a name="_Toc348417111"></a><a name="_Toc348931367"></a><a name="_Toc353900806"></a><a name="_Toc353946336">
"DEFAULT ARGUMENTS", VALORES
SUGESTÃO</a>
</h3>
<b></b><p>
<b>	</b>Valores sugestão, argumentos padrão ou "default
arguments", são nomes para um tipo de polimorfismo ad-hoc fornecido por
C++.</p><p>
<b>	</b>Para demonstrar o uso  de default values vamos relembrar o nosso tipo
abstrato de dados fração de 1.2.1.4. Um de seus  construtores
tinha a seguinte forma: <code> fracao() {num=0; den=1;} //construtor
vazio,default </code>enquanto que o construtor normal da
fração tinha a seguinte forma: <code> fracao(long t,long
m);. </code></p><p>
	"Default arguments" nos dá a oportunidade de fundir esses dois
construtores num só resultando no seguinte: <code> fracao(long
t=0,long m=1); {num=t; den=m;} </code>onde 1 e 0 são valores
sugestão para os argumentos.</p><p>
<b></b></p><p>
<b></b>A instanciação<code> fracao a( )
</code>segundo aquele único construtor cria : <code>(0/1)
</code></p><p>
A instanciação<code> fracao b(1) </code> segundo
aquele único construtor cria: <code>(1/1) </code></p><p>
A instanciação<code> fracao c(1,2) </code>segundo
aquele único construtor cria: <code>(1/2) </code></p><p>
<b></b></p><p>
<b>Regras para a criação de "Default arguments":</b></p><p>
<b>	</b>Não são permitidas declarações do tipo
<code>fracao(long t=0,long m); </code>uma vez que você
inseriu um argumento padrão na lista de argumentos todos a direita deste
também deverão ter seus valores sugestão. Então,
por esta regra a única alternativa restante para o tipo
fração seria <code>fracao(long t,long m=1); </code></p><p>
<b></b></p><p>
<b>Exercícios: </b></p><p>
<b></b>1)Faça a modificação do tipo abstrato de dados
fracao retirando os dois construtores mencionados e substituindo por um
único. O copy constructor você pode deixar como está.</p><p>
<b></b>
</p><h3>
<a name="RTFToC47">3.1.6.
</a><a name="_Ref342704371"></a><a name="_Toc342736986"></a><a name="_Toc345409425"></a><a name="_Toc345810930"></a><a name="_Toc345838257"></a><a name="_Toc345942392"></a><a name="_Toc345949552"></a><a name="_Toc346168669"></a><a name="_Toc348417112"></a><a name="_Toc348931368"></a><a name="_Toc353900807"></a><a name="_Toc353946337">
SOBRECARGA DE OPERADOR</a>
</h3>
<p>
<b>	</b>O tipo abstrato de dados fração (versão completa)
de 1.2.4.4 possui vários operadores sobrecarregados. Algumas sobrecargas
deste exemplo envolvem o uso da palavra chave<code> friends</code>
que você não aprendeu ainda, portanto atenha-se aos exemplos que
não contém essa palavra reservada.</p><p>
	Extensão da classe vetor de 1.5.3.6 para incluir um iterador.  Este
exemplo já é apresentado com templates.</p><p>
<b></b></p><p>
<b>Tópicos abordados:</b></p><p>
<b>	</b>Sobrecarga de operador.</p><p>
<code></code></p><p><code>
<b></b></code></p><hr><p><code>
<b></b>//header file para classe vetor: vet.h</code></p><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
#include &lt;stdlib.h&gt; //exit(1)</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
const int inicio=0; //inicio do vetor</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
class vetor{</code></p><p><code>
private:</code></p><p><code>
float* v;  //pode ser qualquer tipo que atenda as operacoes &lt; &gt; =</code></p><p><code>
int tamanho;</code></p><p><code>
public:</code></p><p><code>
vetor (int tamanho) ;</code></p><p><code>
float&amp; operator[] (int i);</code></p><p><code>
float maximo();   //acha o valor maximo do vetor</code></p><p><code>
int primeiro(void);</code></p><p><code>
int ultimo(void);</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
vetor::vetor (int tam)</code></p><p><code>
{v=new float[tam]; tamanho=tam;}</code></p><p><code>
</code></p><p><code>
int vetor::primeiro (void)</code></p><p><code>
{return inicio;}</code></p><p><code>
</code></p><p><code>
int vetor::ultimo (void)</code></p><p><code>
{return tamanho-1;}</code></p><p><code>
</code></p><p><code>
float&amp; vetor::operator[](int i)</code></p><p><code>
{</code></p><p><code>
 if (i&lt;0 || i&gt;=tamanho)</code></p><p><code>
 {cout &lt;&lt; "Fora dos limites! Exit program"; exit(1);}</code></p><p><code>
 return v[i];</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
float vetor:: maximo(void)</code></p><p><code>
{int candidato=inicio;</code></p><p><code>
 for (int i=inicio;i&lt;tamanho;i++)</code></p><p><code>
 if (v[i]&gt;v[candidato]) candidato=i;</code></p><p><code>
 return v[candidato];}<b></b></code></p><p><code>
<b></b></code></p><hr><p><code>
</code><b></b></p><p>
<b>Explicação das operações, das
função membros do iterador vetor:</b></p><p>
<b></b></p><p>
<b></b><code>iteradorvetor(vetor &amp; v); </code>:Construtor,
já cria o iterador de vetor inicializando-o para apontar para o
começo do vetor.</p><p>
<b></b></p><p>
<b></b><code>virtual int comeca();</code>: Inicializa o iterador
para o começo do vetor.<b></b></p><p>
<b></b></p><p>
<b></b><code>virtual int operator!(); </code><b> : </b>Verifica se
a iteração não chegou no fim do vetor: 1 indica que
não chegou, 0 indica que chegou no fim do vetor.</p><p>
<b></b></p><p>
<b></b><code>virtual int operator ++ ();</code>: Faz o iterador
mover adiante uma posição.</p><p>
<b>	</b></p><p>
<b></b><code>virtual float operator() ();</code><b> </b>:Retorna o
elemento daquela posição do vetor.</p><p>
<b></b></p><p>
<b></b><code>virtual void operator= (float entra);<b> </b></code>:
Atribui a posição atual do vetor.</p><p>
<b></b></p><p>
<b></b><code>int pos();</code><b> </b>: Retorna a
posição (índice) do vetor em que o iterador se encontra,
não é virtual porque não faz sentido para um iterador de
árvore por exemplo.<b></b></p><p>
<b></b><code></code></p><p><code>
<b></b></code></p><hr><p><code>
<b></b>//it.h , arquivo com definicoes do iterador.</code></p><p><code>
</code></p><p><code>
class iteradorvetor</code></p><p><code>
{</code></p><p><code>
private:</code></p><p><code>
		vetor vetorref;</code></p><p><code>
		int posicao;</code></p><p><code>
public:</code></p><p><code>
	iteradorvetor(vetor &amp; v);</code></p><p><code>
	int comeca();</code></p><p><code>
	int operator!();</code></p><p><code>
	int operator ++ ();</code></p><p><code>
	float operator() ();</code></p><p><code>
	void operator= (float entra);</code></p><p><code>
	int pos(); //retorna posicao, n~ virtual pq n~ faz sentido p/ arvore por ex.</code></p><p><code>
	};</code></p><p><code>
</code></p><p><code>
int iteradorvetor::pos()</code></p><p><code>
{</code></p><p><code>
return posicao;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
int iteradorvetor::operator!()</code></p><p><code>
{</code></p><p><code>
return posicao&lt;=vetorref.ultimo();</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
iteradorvetor::iteradorvetor(vetor &amp; vet):vetorref(vet)</code></p><p><code>
{</code></p><p><code>
comeca();</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
int iteradorvetor::comeca()</code></p><p><code>
{</code></p><p><code>
posicao=vetorref.primeiro();</code></p><p><code>
return operator!();</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
int iteradorvetor::operator ++()</code></p><p><code>
{</code></p><p><code>
posicao++;</code></p><p><code>
return operator!();</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
void iteradorvetor::operator=(float entra)</code></p><p><code>
{</code></p><p><code>
vetorref[posicao]=entra;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
float iteradorvetor::operator() ()</code></p><p><code>
{</code></p><p><code>
float copia;</code></p><p><code>
copia=vetorref[posicao];</code></p><p><code>
return copia;</code></p><p><code>
}<b></b></code></p><p><code>
<b></b></code></p><hr><p><code>
</code><b></b></p><p>
<b>Programa principal, testes:</b> <code></code></p><p><code>
<b></b></code></p><hr><p><code>
<b></b>#include &lt;iostream.h&gt;</code></p><p><code>
#include "vet.h"</code></p><p><code>
#include "it.h"</code></p><p><code>
main()</code></p><p><code>
{</code></p><p><code>
int repete=0;</code></p><p><code>
int ind;</code></p><p><code>
float item;</code></p><p><code>
vetor meu(5);</code></p><p><code>
iteradorvetor itmeu(meu);</code></p><p><code>
</code></p><p><code>
for (itmeu.comeca();!itmeu;++itmeu)</code></p><p><code>
{</code></p><p><code>
 cout &lt;&lt; "Entre com valor da posicao:" &lt;&lt; itmeu.pos() &lt;&lt;
"\n";</code></p><p><code>
 cin &gt;&gt; item;</code></p><p><code>
 itmeu=item;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
for (itmeu.comeca();!itmeu;++itmeu) cout&lt;&lt; itmeu()&lt;&lt; " ";</code></p><p><code>
cout &lt;&lt; "\nEntre com o indice da posicao a atualizar:\n";</code></p><p><code>
cin &gt;&gt; ind;</code></p><p><code>
cout &lt;&lt; "Entre com o valor a incluir:";</code></p><p><code>
cin  &gt;&gt; item;</code></p><p><code>
meu[ind]=item;</code></p><p><code>
</code></p><p><code>
for (int k=meu.primeiro();k&lt;=meu.ultimo();k++) cout&lt;&lt; meu[k]&lt;&lt; "
";</code></p><p><code>
cout &lt;&lt;endl &lt;&lt; "Maximo:" &lt;&lt; meu.maximo();</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
return 0;</code></p><p><code>
}</code></p><p><code>
<b></b></code></p><hr><p><code>
</code><b></b></p><p>
<b>Comentários: </b></p><p>
<b>	</b>O significado do operador é você que define, mas é
recomendável dar ao operador um significado próximo ao já
definido na linguagem. Por exemplo: o operador + seria ótimo para
representar a concatenação de  dois objetos do tipo string. A
sintaxe de cada operador é fixa: número de operandos,
precedência... O leitor pode aprender melhor tais regras gravando ou
relendo os exemplos de sobrecarga de cada operador e modificando-os quando
necessário.</p><p>
<b></b></p><p>
<b>Exercícios: </b></p><p>
<b></b>1)Implemente sobrecarga do operador de adição para o
exemplo TAD fração apresentado em 1.2.1.4</p><p>
</p><p>
2)Crie um TAD string e sobrecarregue o operador + com o significado de
concatenação.</p><p>
</p><p>
3)Leia os trechos onde há sobrecarga de operador, mas sem uso de friends
em 1.2.1.</p><p>
<a name="_Toc342736987"></a><a name="_Toc345409426"></a><a name="_Toc345810931"></a><a name="_Toc345838258"></a><a name="_Toc345942393"></a><a name="_Toc345949553"></a><a name="_Toc346168670"></a><a name="_Toc348417113"></a><a name="_Toc348931369"></a><a name="_Toc353900808"></a><a name="_Toc353946338">
</a></p><h2><a name="_Toc353946338">
</a><a name="RTFToC48">3.2.
CLASSES ABSTRATAS E CONCRETAS</a>
</h2>
<a name="_Toc342736988"></a><a name="_Toc345409427"></a><a name="_Toc345810932"></a><a name="_Toc345838259"></a><a name="_Toc345942394"></a><a name="_Toc345949554"></a><a name="_Toc346168671"></a><a name="_Toc348417114"></a><a name="_Toc348931370"></a><a name="_Toc353900809"></a><a name="_Toc353946339">
</a><h3><a name="_Toc353946339">
</a><a name="RTFToC49">3.2.1.
CLASSE ABSTRATA ITERADOR</a>
</h3>
<b></b><p>
<b>	</b>Neste tópico você verá que podem existir classes
que apenas definem protocolos ou interfaces para o uso e não podem ser
instanciadas, as classes filhas que herdam sua interface é que
são instanciáveis. </p><p>
	Neste exemplo vamos repetir o programa de 3.1.6, só que iremos incluir
uma classe base abstrata para o iterador.</p><p>
	O iterador de vetor é definido por herança<code> public
</code>da classe base abstrata de iteradores. Esta classe define o
protocolo, a interface de iteradores para listas e outras estruturas.</p><p>
	Perceba que algumas funções membro da classe base são
desprovidas de implementação, porém nada impede que
você coloque como código dessas funções membro uma
mensagem de erro do tipo <code> "Erro, classe base não deve ser
instanciada!" </code>, como foi feito em alguns casos.</p><p>
<code></code></p><p><code>
<b></b></code></p><hr><p><code>
//exvetit6 , arquivo com definicoes do iterador.</code></p><p><code>
class iterador{  //classe base abstrata</code></p><p><code>
public:</code></p><p><code>
 int comeca(void)</code></p><p><code>
 {cout &lt;&lt; "Erro, classe abstrata!";}</code></p><p><code>
 float operator()()</code></p><p><code>
 {cout &lt;&lt; "Erro, classe abstrata!"; return 0;}</code></p><p><code>
 int operator!(void) {return 0;}</code></p><p><code>
 int operator ++() {return 0;}</code></p><p><code>
 void operator=(float entra) {;}</code></p><p><code>
 };</code></p><p><code>
</code></p><p><code>
class iteradorvetor:public iterador</code></p><p><code>
{</code></p><p><code>
private:</code></p><p><code>
		vetor vetorref;</code></p><p><code>
		int posicao;</code></p><p><code>
		//classe filha acrescentando dados membro</code></p><p><code>
public:</code></p><p><code>
	iteradorvetor(vetor &amp; v);</code></p><p><code>
	int comeca();</code></p><p><code>
	int operator!();</code></p><p><code>
	int operator ++ ();</code></p><p><code>
	float operator() ();</code></p><p><code>
	void operator= (float entra);</code></p><p><code>
	int pos();</code></p><p><code>
	//retorna posicao, n~ virtual pq n~ faz sentido p/ arvore por ex.</code></p><p><code>
	//esta e' uma funcao membro acrescentada pela classe filha</code></p><p><code>
	};</code></p><p><code>
</code></p><p><code>
int iteradorvetor::pos()</code></p><p><code>
{</code></p><p><code>
return posicao;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
int iteradorvetor::operator!()</code></p><p><code>
{</code></p><p><code>
return posicao&lt;=vetorref.ultimo();</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
iteradorvetor::iteradorvetor(vetor &amp; vet):vetorref(vet)</code></p><p><code>
{</code></p><p><code>
comeca();</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
int iteradorvetor::comeca()</code></p><p><code>
{</code></p><p><code>
posicao=vetorref.primeiro();</code></p><p><code>
return operator!();</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
int iteradorvetor::operator ++()</code></p><p><code>
{</code></p><p><code>
posicao++;</code></p><p><code>
return operator!();</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
void iteradorvetor::operator=(float entra)</code></p><p><code>
{</code></p><p><code>
vetorref[posicao]=entra;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
float iteradorvetor::operator() ()</code></p><p><code>
{</code></p><p><code>
float copia;</code></p><p><code>
copia=vetorref[posicao];</code></p><p><code>
return copia;</code></p><p><code>
}</code></p><p><code>
<b></b></code></p><hr><p><code>
</code></p><p>
Os demais arquivos são identicos aos do exemplo sobre vetores de 3.1.6.
<code></code></p><p><code>
<b></b></code></p><hr><p><code>
//header file para classe vetor</code></p><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
#include &lt;stdlib.h&gt; //exit(1)</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
const int inicio=0; //inicio do vetor</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
class vetor{</code></p><p><code>
private:</code></p><p><code>
float* v;  //pode ser qualquer tipo que atenda as operacoes &lt; &gt; =</code></p><p><code>
int tamanho;</code></p><p><code>
public:</code></p><p><code>
vetor (int tamanho) ;</code></p><p><code>
float&amp; operator[] (int i);</code></p><p><code>
float maximo();   //acha o valor maximo do vetor</code></p><p><code>
int primeiro(void);</code></p><p><code>
int ultimo(void);</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
vetor::vetor (int tam)</code></p><p><code>
{v=new float[tam]; tamanho=tam;}</code></p><p><code>
</code></p><p><code>
int vetor::primeiro (void)</code></p><p><code>
{return inicio;}</code></p><p><code>
</code></p><p><code>
int vetor::ultimo (void)</code></p><p><code>
{return tamanho-1;}</code></p><p><code>
</code></p><p><code>
float&amp; vetor::operator[](int i)</code></p><p><code>
{</code></p><p><code>
 if (i&lt;0 || i&gt;=tamanho)</code></p><p><code>
 {cout &lt;&lt; "Fora dos limites! Exit program"; exit(1);}</code></p><p><code>
 return v[i];</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
float vetor:: maximo(void)</code></p><p><code>
{int candidato=inicio;</code></p><p><code>
 for (int i=inicio;i&lt;tamanho;i++)</code></p><p><code>
 if (v[i]&gt;v[candidato]) candidato=i;</code></p><p><code>
 return v[candidato];}</code></p><p><code>
</code></p><p><code>
<b></b></code></p><hr><p><code>
</code></p><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
#include "exvet6.h"</code></p><p><code>
#include "exvetit6.h"</code></p><p><code>
main()</code></p><p><code>
{</code></p><p><code>
int repete=0;</code></p><p><code>
int ind;</code></p><p><code>
float item;</code></p><p><code>
vetor meu(5);</code></p><p><code>
iteradorvetor itmeu(meu);</code></p><p><code>
</code></p><p><code>
for (itmeu.comeca();!itmeu;++itmeu)</code></p><p><code>
{</code></p><p><code>
 cout &lt;&lt; "Entre com valor da posicao:" &lt;&lt; itmeu.pos() &lt;&lt;
"\n";</code></p><p><code>
 cin &gt;&gt; item;</code></p><p><code>
 itmeu=item;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
for (itmeu.comeca();!itmeu;++itmeu) cout&lt;&lt; itmeu()&lt;&lt; " ";</code></p><p><code>
cout &lt;&lt; "\nEntre com o indice da posicao a atualizar:\n";</code></p><p><code>
cin &gt;&gt; ind;</code></p><p><code>
cout &lt;&lt; "Entre com o valor a incluir:";</code></p><p><code>
cin  &gt;&gt; item;</code></p><p><code>
meu[ind]=item;</code></p><p><code>
</code></p><p><code>
for (int k=meu.primeiro();k&lt;=meu.ultimo();k++) cout&lt;&lt; meu[k]&lt;&lt; "
";</code></p><p><code>
cout &lt;&lt;endl &lt;&lt; "Maximo:" &lt;&lt; meu.maximo();</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
return 0;</code></p><p><code>
}</code></p><p><code>
<b></b></code></p><hr><p><code>
</code><b></b></p><p>
<b> Resultado do programa:</b></p><p>
<b></b>Entre com valor da posicao:0</p><p>
2</p><p>
Entre com valor da posicao:1</p><p>
35</p><p>
Entre com valor da posicao:2</p><p>
82</p><p>
Entre com valor da posicao:3</p><p>
2</p><p>
Entre com valor da posicao:4</p><p>
3</p><p>
2 35 82 2 3</p><p>
Entre com o indice da posicao a atualizar:</p><p>
0</p><p>
Entre com o valor a incluir:1</p><p>
1 35 82 2 3</p><p>
Maximo:82<b></b></p><p>
<b></b>
<a name="_Toc342736989"></a><a name="_Toc345409428"></a><a name="_Toc345810933"></a><a name="_Toc345838260"></a><a name="_Toc345942395"></a><a name="_Toc345949555"></a><a name="_Toc346168672"></a><a name="_Toc348417115"></a><a name="_Toc348931371"></a><a name="_Toc353900810"></a><a name="_Toc353946340">
</a></p><h3><a name="_Toc353946340">
</a><a name="RTFToC50">3.2.2.
ACOPLAMENTO DE MENSAGENS</a>
</h3>
<p>
	Já dissemos que um objeto de uma classe filha garante no mínimo
o comportamento "behaviour" de seu pai. Por este motivo podemos atribuir um
objeto da classe filha a uma variável da classe pai, mas não o
contrário. </p><p>
	Acoplamento dinâmico mostrará que é possível fazer
com que o compilador execute a implementação desejada de uma
função membro redefinida para classes herdeiras, mesmo no caso de
chamada de função membro para uma variável de um supertipo
(classe pai) contendo um objeto de um subtipo (classe filha). Isto nos
permitirá construir listas hetorogêneas 3.2.4.<b>
<a name="_Toc342736990"></a><a name="_Toc345838261"></a><a name="_Toc345942396"></a><a name="_Toc345949556"></a><a name="_Toc346168673"></a><a name="_Toc348417116"></a><a name="_Toc348931372"></a><a name="_Toc353900811"></a><a name="_Toc353946341"></a></b><a name="_Toc353946341">
</a></p><h4><a name="_Toc353946341">
</a><a name="RTFToC51">3.2.2.1.
CASO ESTÁTICO</a>
</h4>
<code><p>
<b></b></p><hr><p>
#include &lt;iostream.h&gt;</p><p>
</p><p>
class pai {</p><p>
public:</p><p>
void print(void)</p><p>
{cout &lt;&lt; "Sou da classe pai"&lt;&lt;endl;}</p><p>
};</p><p>
</p><p>
class filho:public pai</p><p>
{</p><p>
private:</p><p>
public:</p><p>
void print(void)</p><p>
{cout &lt;&lt; "Sou da classe filha" &lt;&lt; endl;}</p><p>
};</p><p>
</p><p>
void main()</p><p>
{</p><p>
filho ef1;</p><p>
//estatica filho numero 1</p><p>
pai ep1;</p><p>
//estatica pai numero 1</p><p>
ef1.print();</p><p>
//variavel estatica contendo filho</p><p>
ep1.print();</p><p>
//variavel estatica  contendo pai</p><p>
ep1=ef1;</p><p>
//variavel estatica do tipo pai contendo filho convertido no pai</p><p>
ep1.print();</p><p>
}</p><p>
<b></b></p><hr></code><p><code>
</code></p><p>
<b>Diagrama das classes:</b></p><p>
<b></b></p><p>
<b></b></p><p>
	A classe filha garante no mínimo o mesmo comportamento, "behaviour" que
a classe pai, podendo acrescentar ou redefinir parte do que foi herdado. Por
este motivo, uma variável da classe pai pode receber um objeto da classe
filha, o comportamento da classe pai fica garantido e o restante (o que a
classe filha acrescentou) é perdido. Já uma variável da
classe filha não pode receber um objeto da classe pai, porque as
funções membro acrescentadas passam a não fazer sentido.</p><p>
</p><p>
<b>Resultado do programa:</b></p><p>
<b></b>Sou da classe filha</p><p>
Sou da classe pai</p><p>
Sou da classe pai</p><p>
</p><p>
<b>Explicação do programa, passo a passo:</b></p><p>
<b></b><code>filho ef1; </code></p><p>
</p><p>
Declaração de uma variável da classe filha.</p><p>
<code></code></p><p><code>
pai ep1;</code></p><p><code>
</code></p><p>
Declaração de uma variável da classe pai, menor ou igual
quantidade de membros que a filha.</p><p>
<code></code></p><p><code>
ef1.print();</code></p><p><code>
</code></p><p>
Mostra a função da classe filha, a qual pertence<code>
ef1</code> e seu conteúdo.</p><p>
<code></code></p><p><code>
ep1.print();</code></p><p><code>
</code></p><p>
Mostra a função da classe de<code> ep1</code> que
é a classe pai.</p><p>
<code></code></p><p><code>
ep1=ef1;</code></p><p><code>
</code></p><p>
Atribui o conteúdo de<code> ef1 </code>a<code>
ep1</code>, ou seja atribui um filho a um pai. O filho tem os dados
membros e funções membros acrescentados,  descartados e se torna
do tipo pai. Essa conversão é irreversível no caso.</p><p>
<code></code></p><p><code>
ep1.print();</code></p><p><code>
</code></p><p>
Mostra a função da classe de ep1 que é a classe pai, a
mesma de seu conteúdo.</p><p>
<a name="_Toc342736991"></a><a name="_Toc345838262"></a><a name="_Toc345942397"></a><a name="_Toc345949557"></a><a name="_Toc346168674"></a><a name="_Toc348417117"></a><a name="_Toc348931373"></a><a name="_Toc353900812"></a><a name="_Toc353946342">
</a></p><h4><a name="_Toc353946342">
</a><a name="RTFToC52">3.2.2.2.
DINÂMICO SEM VIRTUAL</a>	
</h4>
<code><p>
<b></b></p><hr><p>
#include &lt;iostream.h&gt;</p><p>
</p><p>
class pai {</p><p>
public:</p><p>
void print(void)</p><p>
{cout &lt;&lt; "Sou da classe pai"&lt;&lt;endl;}</p><p>
};</p><p>
</p><p>
class filho:public pai</p><p>
{</p><p>
private:</p><p>
public:</p><p>
void print(void)</p><p>
{cout &lt;&lt; "Sou da classe filha" &lt;&lt; endl;}</p><p>
};</p><p>
</p><p>
void main()</p><p>
{</p><p>
filho ef1;</p><p>
//estatica filho numero 1</p><p>
pai ep1;</p><p>
//estatica pai numero 1</p><p>
pai* pp1;</p><p>
//ponteiro pai numero 1</p><p>
ef1.print();</p><p>
//variavel estatica contendo filho</p><p>
ep1.print();</p><p>
//variavel estatica  contendo pai</p><p>
pp1=&amp;ep1;</p><p>
pp1-&gt;print();</p><p>
//ponteiro de pai,apontando para pai</p><p>
</p><p>
pp1=&amp;ef1;</p><p>
pp1-&gt;print();</p><p>
//ponteiro de pai apontando para filho</p><p>
</p><p>
ep1=ef1;</p><p>
//variavel estatica do tipo pai contendo filho convertido no pai</p><p>
ep1.print();</p><p>
}</p><p>
<b></b></p><hr></code><p><code>
</code><b></b></p><p>
<b>Resultado do programa:</b></p><p>
<b></b>Sou da classe filha</p><p>
Sou da classe pai</p><p>
Sou da classe pai</p><p>
Sou da classe pai</p><p>
Sou da classe pai</p><p>
</p><p>
<b>Comentários:</b></p><p>
<b>	</b>Note que a função membro executada é escolhida de
acordo que a variável e não de acordo com o conteúdo
desta, da mesma forma que no exemplo anterior.</p><p>
<a name="_Toc342736992"></a><a name="_Toc345838263"></a><a name="_Toc345942398"></a><a name="_Toc345949558"></a><a name="_Toc346168675"></a><a name="_Toc348417118"></a><a name="_Toc348931374"></a><a name="_Toc353900813"></a><a name="_Toc353946343">
</a></p><h4><a name="_Toc353946343">
</a><a name="RTFToC53">3.2.2.3.
DINÂMICO COM VIRTUAL</a>
</h4>
<code><p>
<b></b></p><hr><p>
<b></b>#include &lt;iostream.h&gt;</p><p>
</p><p>
class pai {</p><p>
public:</p><p>
virtual void print(void)</p><p>
{cout &lt;&lt; "Sou da classe pai"&lt;&lt;endl;}</p><p>
};</p><p>
</p><p>
class filho:public pai</p><p>
{</p><p>
private:</p><p>
public:</p><p>
virtual void print(void)</p><p>
{cout &lt;&lt; "Sou da classe filha" &lt;&lt; endl;}</p><p>
};</p><p>
</p><p>
void main()</p><p>
{</p><p>
filho ef1;</p><p>
//estatica filho numero 1</p><p>
pai ep1;</p><p>
//estatica pai numero 1</p><p>
pai* pp1;</p><p>
//ponteiro pai numero 1</p><p>
ef1.print();</p><p>
//variavel estatica contendo filho</p><p>
ep1.print();</p><p>
//variavel estatica  contendo pai</p><p>
pp1=&amp;ep1;</p><p>
pp1-&gt;print();</p><p>
//ponteiro de pai,apontando para pai</p><p>
</p><p>
pp1=&amp;ef1;</p><p>
pp1-&gt;print();</p><p>
//ponteiro de pai apontando para filho</p><p>
</p><p>
ep1=ef1;</p><p>
//variavel estatica do tipo pai contendo filho convertido no pai</p><p>
ep1.print();</p><p>
}<b></b></p><p>
<b></b></p><hr></code><p><code>
</code><b></b></p><p>
<b>Resultado do programa:</b></p><p>
<b></b>Sou da classe filha</p><p>
Sou da classe pai</p><p>
Sou da classe pai</p><p>
Sou da classe filha</p><p>
Sou da classe pai</p><p>
</p><p>
<b>Comentários:</b></p><p>
<b>	</b>Perceba que<code> virtual </code>faz com que a
função membro a executar seja escolhida de acordo com o
conteúdo da variável ou ponteiro e não de acordo com o
tipo da variável ou ponteiro (repositórios). <code>Virtual
</code>não tem efeito no uso estático de objetos, ou seja a
função membro será escolhida de arcordo com o tipo da
variável (repositório).</p><p>
<b></b></p><p>
<b>Exercícios:</b></p><p>
<b></b>1)Implemente em suas classes funções membro que imprimem
uma frase identificando o tipo da classe, por exemplo: "Eu sou a classe conta
corrente, especialização de conta bancaria."</p><p>
<a name="_Toc342736993"></a><a name="_Toc345409429"></a><a name="_Ref345758318"></a><a name="_Toc345810934"></a><a name="_Toc345838264"></a><a name="_Toc345942399"></a><a name="_Toc345949559"></a><a name="_Toc346168676"></a><a name="_Toc348417119"></a><a name="_Toc348931375"></a><a name="_Toc353900814"></a><a name="_Toc353946344">
</a></p><h3><a name="_Toc353946344">
</a><a name="RTFToC54">3.2.3.
CONTAS BANCÁRIAS</a>
</h3>
<p>
	Neste programa exemplo vamos definir uma classe abstrata chamada conta. Esta
classe define a interface de contas bancárias, que se constitui das
operações: <code>deposita, saca, get_saldo,  get_jurosn
</code> (juros quando saldo está negativo), <code>get_jurosp
</code> (juros quando o saldo está positivo) e
<code>computa</code> (calcula juros). Todos as
funções membro são  "virtuais" exceto destrutor .</p><p>
<b></b></p><p>
<b></b>	Preste atenção nas especificações a seguir
elas são detalhadas e importantíssimas para o entendimento do
programa:</p><p>
Da classe base abstrata descrita acima, criamos duas classes concretas com as
seguintes propriedades:</p><p>
	1-Conta corrente:</p><p>
		-Neste tipo de conta as computações dos juros são feitas
pelo banco diariamente.</p><p>
		-Permite taxa de juros diferente para saldos negativos e positivos.</p><p>
		-Possui um atributo menor que zero chamado <b>limite</b>. Saques que levem o
saldo abaixo deste valor são recusados. Esta definição
acima não implica que o saldo tenha que  estar sempre acima de
<b>limite</b>. Ele só vai  para valores menores que  se os juros da
dívida o fizerem e não o cliente.</p><p>
		 -O valor de<b> limite</b> é definido na criação da
conta, instanciação.</p><p>
		-Fica claro que este tipo de conta permite saldos negativos.	 </p><p>
	.	-A taxa de juros para  saldo positivo é zero ou seja, não
há rendimento.</p><p>
</p><p>
	2-Poupança:</p><p>
		-Possui uma data de aniversário, só neste dia é que se
computa juros ou seja mensalmente.</p><p>
		-Os juros acrescentados são referentes ao saldo após a
última computação, isto significa que depósitos
intermediários não rendem juros.</p><p>
		-Se houver algum saque que não seja no dia da computação
os juros referentes a aquele mês são cancelados.</p><p>
		-Só é permitido saldo maior ou igual a zero.</p><p>
<b></b></p><p>
<b>	</b>Outra classe foi criada no programa: a classe data que armazena datas
quaisquer. Por questões de simplicidade a classe data que é
simplesmente uma classe auxiliar foi implementada com o mínimo
necessário para o funcionamento e demonstração do
programa. A melhoria desta classe é sugerida como exercício.</p><p>
</p><p>
Tópicos abordados: Funções membro virtual e pure virtual.
Objetos constantes.</p><p>
<code><b>	</b></code></p><p><code>
<b></b></code></p><hr><p><code>
<b></b>//header file for conta.h</code></p><p><code>
//todas as funcoes recebem uma data porque o extrato presisa disso.</code></p><p><code>
const float jp=.05; /*juros padrao*/</code></p><p><code>
const float  vazio=0.0;</code></p><p><code>
const float  jnulo=0.0;</code></p><p><code>
const float lmin=-400.0;</code></p><p><code>
</code></p><p><code>
enum Boolean{FALSE,TRUE};</code></p><p><code>
typedef float dinh;</code></p><p><code>
</code></p><p><code>
float abs(float a); //funcao valor absoluto</code></p><p><code>
</code></p><p><code>
class data{ //definir outras operacoes elaborar mais</code></p><p><code>
private:</code></p><p><code>
	int dia;</code></p><p><code>
	int mes;</code></p><p><code>
	int ano;</code></p><p><code>
public:</code></p><p><code>
	data() {dia=1;mes=1;ano=95;} //default constructor, importante para
agregacao</code></p><p><code>
	data(int d,int m,int a) {dia=d;mes=m;ano=a;}</code></p><p><code>
	int get_dia(void) {return dia;}</code></p><p><code>
	int get_mes(void) {return mes;}</code></p><p><code>
	int get_ano(void) {return ano;}</code></p><p><code>
	};</code></p><p><code>
</code></p><p><code>
const data ddef(1,1,90);  //objeto constante;</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
class conta{ //pure virtual functions in abstract base class</code></p><p><code>
protected:</code></p><p><code>
dinh saldo;  //esse e' o dinheiro na conta.</code></p><p><code>
float jurosp; //juros p/ saldo positivo</code></p><p><code>
float jurosn; //juros p/ saldo negativo</code></p><p><code>
</code></p><p><code>
public:</code></p><p><code>
//pure virtual functions in abstract base class</code></p><p><code>
conta (dinh quantia=vazio,float taxap=jp,float taxan=jp,data dd=ddef);</code></p><p><code>
virtual Boolean computa(data dd)=0; //computa juros da conta</code></p><p><code>
virtual dinh get_saldo(data dd)const=0; //retorna conteudo da conta</code></p><p><code>
virtual float get_jurosn(data dd)const=0; //criar as respectivas funcoes set:
set_juros</code></p><p><code>
virtual float get_jurosp(data dd)const=0;</code></p><p><code>
virtual Boolean deposita(dinh quantia,data dd)=0;</code></p><p><code>
virtual dinh saca(dinh quantia,data dd)=0;</code></p><p><code>
~conta(){};</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
class contacorrente:public conta{</code></p><p><code>
private:</code></p><p><code>
dinh lim; //saques que levam saldo para baixo deste limite sao bloqueados.</code></p><p><code>
public:</code></p><p><code>
 contacorrente(dinh quantia=vazio,float taxan=jp,dinh min=lmin,data dd=ddef);
//so computa qdo neg.</code></p><p><code>
 Boolean computa(data dd); //para esse tipo de conta e' diario. (poupanca
mensal)</code></p><p><code>
 dinh get_saldo(data dd)const; //retorna conteudo da conta</code></p><p><code>
 float get_jurosn(data dd)const; //criar as respectivas funcoes set:
set_juros</code></p><p><code>
 float get_jurosp(data dd)const;</code></p><p><code>
 Boolean deposita(dinh quantia,data dd);</code></p><p><code>
 dinh saca(dinh quantia,data dd);</code></p><p><code>
 ~contacorrente(){}; //pode deletar deque com operacoes sobre conta (extrato)</code></p><p><code>
 };</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
class poupanca:public conta{</code></p><p><code>
private:</code></p><p><code>
 data aniversario; //dia do mes que a poupanca faz aniversario.</code></p><p><code>
 Boolean computar; //1:computar sobre ultimo, 0:rendimento perdido, saque</code></p><p><code>
 dinh ultimo; //os juros sao sobre o valor depois da ultima computacao.</code></p><p><code>
 //o que depositou nao importa, se sacou perdeu rendimento</code></p><p><code>
public:</code></p><p><code>
 poupanca(dinh quantia=vazio,float taxap=jp,data dd=ddef); //mensalmente</code></p><p><code>
 Boolean computa(data dd); // Boolean: Rendimento nao foi perdido?</code></p><p><code>
 dinh get_saldo(data dd)const; //retorna conteudo da conta</code></p><p><code>
 float get_jurosn(data dd)const; //criar as respectivas funcoes set:
set_juros</code></p><p><code>
 float get_jurosp(data dd)const;</code></p><p><code>
 Boolean deposita(dinh quantia,data dd);</code></p><p><code>
 dinh saca(dinh quantia,data dd);</code></p><p><code>
 ~poupanca(){}; //pode deletar deque com operacoes sobre conta (extrato)</code></p><p><code>
};</code></p><p><code>
<b></b></code></p><p><code>
<b></b></code></p><hr><p><code>
<b></b></code></p><p><code>
<b></b>//file conta.cpp</code></p><p><code>
#include "conta2.h"</code></p><p><code>
float abs(float a)</code></p><p><code>
{</code></p><p><code>
if  (a&lt;0.0) a=-a;</code></p><p><code>
return a;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
conta::conta(dinh quantia,float taxap,float taxan,data dd)</code></p><p><code>
{</code></p><p><code>
saldo=abs(quantia);</code></p><p><code>
jurosp=abs(taxap);</code></p><p><code>
jurosn=abs(taxan);</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
poupanca::poupanca(dinh quantia,float taxap,data dd):</code></p><p><code>
conta(quantia,taxap,jnulo,dd)</code></p><p><code>
{aniversario=dd; computar=TRUE; ultimo=abs(quantia);};</code></p><p><code>
</code></p><p><code>
Boolean poupanca::computa(data dd)</code></p><p><code>
{</code></p><p><code>
if (aniversario.get_dia()==dd.get_dia())</code></p><p><code>
  if (computar)  {saldo=ultimo*jurosp+saldo;return TRUE;}</code></p><p><code>
  else { computar=TRUE; ultimo=abs(saldo); }</code></p><p><code>
</code></p><p><code>
return FALSE;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
dinh poupanca::get_saldo(data dd)const</code></p><p><code>
{return saldo;}</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
float poupanca::get_jurosp(data dd)const</code></p><p><code>
{ return jurosp; }</code></p><p><code>
</code></p><p><code>
float poupanca::get_jurosn(data dd)const</code></p><p><code>
{ return jurosn; }</code></p><p><code>
</code></p><p><code>
Boolean poupanca::deposita(dinh quantia,data dd)</code></p><p><code>
{ saldo+=abs(quantia);</code></p><p><code>
  return TRUE;}</code></p><p><code>
</code></p><p><code>
dinh poupanca::saca(dinh quantia,data dd)</code></p><p><code>
{</code></p><p><code>
 if ((saldo-abs(quantia))&gt;vazio)</code></p><p><code>
	{saldo-=abs(quantia); computar=FALSE; return quantia;}</code></p><p><code>
 else return vazio;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
contacorrente::contacorrente(dinh quantia,float taxan,dinh min,data dd):</code></p><p><code>
conta(quantia,jnulo,taxan,dd)</code></p><p><code>
{if (min&lt;vazio) lim=min; else lim=-min;}</code></p><p><code>
</code></p><p><code>
Boolean contacorrente::computa(data dd) //so computo juros negativos.</code></p><p><code>
{</code></p><p><code>
if (saldo&lt;vazio) saldo=saldo*jurosn+saldo;</code></p><p><code>
else saldo=saldo*jurosp+saldo;</code></p><p><code>
return TRUE;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
dinh contacorrente::get_saldo(data dd) const</code></p><p><code>
{return saldo;}</code></p><p><code>
</code></p><p><code>
float contacorrente::get_jurosn(data dd) const</code></p><p><code>
{return jurosn;}</code></p><p><code>
</code></p><p><code>
float contacorrente::get_jurosp(data dd) const</code></p><p><code>
{return jurosp;}</code></p><p><code>
</code></p><p><code>
Boolean contacorrente::deposita(dinh quantia,data dd)</code></p><p><code>
{</code></p><p><code>
saldo+=quantia;</code></p><p><code>
return TRUE;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
dinh contacorrente::saca(dinh quantia,data dd)</code></p><p><code>
{</code></p><p><code>
quantia=abs(quantia);</code></p><p><code>
if ((saldo-quantia)&gt;lim)</code></p><p><code>
{ saldo-=quantia; return quantia;}</code></p><p><code>
else return vazio;</code></p><p><code>
}</code></p><p><code>
<b></b></code></p><p><code>
<b></b></code></p><hr><p><code>
<b></b></code></p><p><code>
<b></b>//main file.</code></p><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
#include "conta2.h"</code></p><p><code>
</code></p><p><code>
main()</code></p><p><code>
{</code></p><p><code>
data hoje(6,10,95);</code></p><p><code>
contacorrente minhacc(1340.34,0.1,-500.0,hoje);</code></p><p><code>
poupanca minhap(1500.00,0.1,hoje);</code></p><p><code>
</code></p><p><code>
cout &lt;&lt; "Saldo:" &lt;&lt;minhacc.get_saldo(hoje)&lt;&lt;endl;</code></p><p><code>
minhacc.deposita(10.00,hoje);</code></p><p><code>
cout &lt;&lt; "Saldo apos depositar
10.00:"&lt;&lt;minhacc.get_saldo(hoje)&lt;&lt;endl;</code></p><p><code>
minhacc.computa(hoje);</code></p><p><code>
cout &lt;&lt; "Saldo apos computar:"
&lt;&lt;minhacc.get_saldo(hoje)&lt;&lt;endl;</code></p><p><code>
minhacc.saca(1500.00,hoje);</code></p><p><code>
cout &lt;&lt; "Saldo apos sacar:" &lt;&lt;
minhacc.get_saldo(hoje)&lt;&lt;endl;</code></p><p><code>
minhacc.computa(hoje);</code></p><p><code>
cout &lt;&lt; "Saldo apos computar:" &lt;&lt; minhacc.get_saldo(hoje)
&lt;&lt;endl;</code></p><p><code>
cout &lt;&lt; "Taxa de juros:" &lt;&lt; minhacc.get_jurosn(hoje)&lt;&lt;endl;</code></p><p><code>
cout &lt;&lt; endl;</code></p><p><code>
cout &lt;&lt; "Agora a poupanca:";</code></p><p><code>
cout &lt;&lt; "Saldo apos criacao:" &lt;&lt; minhap.get_saldo(hoje) &lt;&lt;
endl;</code></p><p><code>
cout &lt;&lt; "Juros de saldo positivo:" &lt;&lt;
minhap.get_jurosp(hoje)&lt;&lt; endl;</code></p><p><code>
cout &lt;&lt; "Computando:" &lt;&lt; endl;</code></p><p><code>
minhap.computa(hoje) ;</code></p><p><code>
cout &lt;&lt; "Saldo apos computa:" &lt;&lt; minhap.get_saldo(hoje) &lt;&lt;
endl;</code></p><p><code>
cout &lt;&lt; "Retirando 500.00:" &lt;&lt;endl;</code></p><p><code>
minhap.saca(500.00,hoje) ;</code></p><p><code>
cout &lt;&lt; "Saldo apos retirada:" &lt;&lt; minhap.get_saldo(hoje) &lt;&lt;
endl;</code></p><p><code>
cout &lt;&lt; "Computando:"&lt;&lt;endl;</code></p><p><code>
minhap.computa(hoje);</code></p><p><code>
cout &lt;&lt; "Saldo apos computa:" &lt;&lt; minhap.get_saldo(hoje) &lt;&lt;
endl;</code></p><p><code>
cout &lt;&lt; "Depositando100 e Computando:"&lt;&lt;endl;</code></p><p><code>
minhap.deposita(100.00,hoje);</code></p><p><code>
minhap.computa(hoje);</code></p><p><code>
cout &lt;&lt; "Saldo apos computa:" &lt;&lt; minhap.get_saldo(hoje) &lt;&lt;
endl;</code></p><p><code>
cout &lt;&lt; "Retirando mais do que pode:2000.00" &lt;&lt; endl;</code></p><p><code>
minhap.saca(2000.00,hoje);</code></p><p><code>
cout &lt;&lt; "Saldo apos saca 2000.00:" &lt;&lt; minhap.get_saldo(hoje)
&lt;&lt; endl;</code></p><p><code>
return 0;</code></p><p><code>
}</code></p><p><code>
<b></b></code></p><hr><p><code>
</code><b></b></p><p>
<b>Resultado de teste do programa:</b></p><p>
<b></b>Saldo:1340.34</p><p>
Saldo apos depositar 10.00:1350.34</p><p>
Saldo apos computar:1350.34</p><p>
Saldo apos sacar:-149.66</p><p>
Saldo apos computar:-164.626</p><p>
Taxa de juros:0.1</p><p>
</p><p>
Agora a poupanca:Saldo apos criacao:1500</p><p>
Juros de saldo positivo:0.1</p><p>
Computando:</p><p>
Saldo apos computa:1650</p><p>
Retirando 500.00:</p><p>
Saldo apos retirada:1150</p><p>
Computando:</p><p>
Saldo apos computa:1150</p><p>
Depositando100 e Computando:</p><p>
Saldo apos computa:1365</p><p>
Retirando mais do que pode:2000.00</p><p>
Saldo apos saca 2000.00:1365</p><p>
</p><p>
<b>Comentários: </b></p><p>
<b>	</b>Observe que objetos da classe base não podem ser criados,
você não pode ter um objeto instanciado, mas ela pode ser usada.
Declarar um ponteiro: <code>conta* </code>, não significa
criar um objeto. Esse ponteiro pode referenciar qualquer objeto da hierarquia
(conta corrente , poupança) , veremos seu uso mais tarde.</p><p>
<b></b></p><p>
<b>Curiosidade:</b></p><p>
<b>	</b>Veja a importância da criação de componentes de
software seguros, de fácil modificação e
reutilizáveis:</p><p>
	Muitos programas que tinham que fazer uma representação de datas
estão sendo revistos devido a mudança do século e outros
provavelmente falharão devido a esta mudança. Seja pela
restrição da faixa de valores de anos com máximo em 2000
ou mesmo por outros motivos que não levassem este fator em conta, como a
subtração entre dois anos distintos exemplo 2001 e 1999
armazenados na forma 01 e 99.<b></b></p><p>
<b></b>	O exercício  5 pede que você melhore a classe data
apresentada neste exemplo. Com um pouquinho de pesquisa você pode criar
meios de checar anos bissextos (%4), meses com números de dias
diferentes e "viradas" de século.</p><p>
<b></b></p><p>
<b>Exercícios:</b></p><p>
<b></b>1)Você seria capaz de usando princípios de
agregação implementar uma estrutura de armazenamento (lista,
vetor) na classe conta e usá-la para salvar as operações
de modo que esta estrutura representasse o extrato? De que modo esta
idéia pode ser adaptada para criar estruturas que fazem um
histórico das funções membro chamadas para classes
quaisquer? Você pode usar este tipo de informação da classe
de armazenagem para debugar seus programas? </p><p>
<b></b></p><p>
<b></b>*2)Porque não houve preocupação de esconder
funções membro como<code> computa</code>?
Alguém poderia computar juros infinitamente em sua própria
conta..... Para responder pense no seguinte: Uma pessoa é cliente de uma
conta ou de um banco? Um banco mantém uma conta ou uma pessoa
mantém uma conta? Monte um diagrama de objetos contendo um banco,
várias contas , várias pessoas e as respectivas
associações.</p><p>
<b></b></p><p>
<b></b>3)Modifique este programa, implemente outros tipos de contas que
você conhece.</p><p>
<b></b></p><p>
<b></b>4)Após ler o tópico de tratamento de
exceções, adicione "exception handling" para argumentos
inválidos tipo <code>minhaconta.deposita(-10.3) </code> !</p><p>
<b></b></p><p>
<b></b>5)Modifique a classe data, crie restrições para datas
inválidas e outras funções membro que julgar importantes
como<code>: print_data().</code> Veja comentário neste
exemplo.</p><p>

</p><h3>
<a name="RTFToC55">3.2.4.
</a><a name="_Toc342736994"></a><a name="_Toc345409430"></a><a name="_Ref345753421"></a><a name="_Toc345810935"></a><a name="_Toc345838265"></a><a name="_Toc345942400"></a><a name="_Toc345949560"></a><a name="_Toc346168677"></a><a name="_Toc348417120"></a><a name="_Toc348931376"></a><a name="_Toc353900815"></a><a name="_Toc353946345">
LISTA HETEROGÊNEA DE CONTAS
BANCÁRIAS.</a>
</h3>
<b></b><p>
<b>	</b>Lista heterogênea de contas bancárias de exemplo anterior,
obtenção do saldo total das contas corrente e poupanças da
lista (no caso vetor).</p><p>
</p><p>
<b>Tópicos abordados: </b></p><p>
<b>	"</b>Dynamic binding", não aborda type casting, vai ser abordado num
programa mais completo: a simulação dirigida a eventos de 4.6.2
.</p><p>
<code></code></p><p><code>
<b></b></code></p><hr><p><code>
<b></b>//programa principal</code></p><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
#include "conta2.h" ///</code></p><p><code>
const int tamanho=3;</code></p><p><code>
main()</code></p><p><code>
{</code></p><p><code>
dinh soma=0.0;</code></p><p><code>
contacorrente cc1(500.00,0.1,-400); //SALDO,JUROS,LIMITE NEG</code></p><p><code>
contacorrente cc2(500.00,0.15,-400);</code></p><p><code>
poupanca p1(500.00,0.1);  //SALDO, JUROS</code></p><p><code>
</code></p><p><code>
conta* lheterogenea[tamanho]={&amp;cc1,&amp;cc2,&amp;p1};  //lista
heterogenea</code></p><p><code>
for (int i=0;i&lt;tamanho;i++) soma+=lheterogenea[i]-&gt;get_saldo(ddef);</code></p><p><code>
cout &lt;&lt; "Total armazenado nas contas:" &lt;&lt; soma &lt;&lt;endl;</code></p><p><code>
return 0;</code></p><p><code>
}</code></p><p><code>
<b></b></code></p><hr><p><code>
</code><b></b></p><p>
<b>Exercícios: </b></p><p>
<b></b>1)Melhore o exemplo de lista heterogênea dado  usando uma lista
com "templates" de 4.3.Você deve definir a lista para trabalhar com
ponteiros de contas.</p><p>
<b></b></p><p>
<b></b>2) Considere as seguintes declarações em C++:</p><p>
<code><b></b></code></p><p><code>
<b></b>class T</code></p><p><code>
{</code></p><p><code>
public:</code></p><p><code>
virtual void f(void) {cout &lt;&lt; "Estou em T";}</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
class S:public T</code></p><p><code>
{</code></p><p><code>
public:</code></p><p><code>
virtual void f(void) {cout &lt;&lt; "Estou em S";}</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
T x;</code></p><p><code>
//variavel estática</code></p><p><code>
S y;</code></p><p><code>
//variavel estatica, s de subclasse</code></p><p><code>
T* p;</code></p><p><code>
//apontador para tipo base t.<b></b></code></p><p><code>
<b></b></code><b></b></p><p>
<b></b>e as seguintes invocações de operações:</p><p>
<code></code></p><p><code>
p=&amp;x ;</code></p><p><code>
p-&gt;f(); //primeira</code></p><p><code>
p=&amp;y;</code></p><p><code>
p-&gt;f(); //segunda</code></p><p><code>
x.f(); //terceira</code></p><p><code>
y.f(); //quarta</code></p><p><code>
x=y;</code></p><p><code>
x.f() //quinta</code><b></b></p><p>
<b></b>Responda qual é o resultado na tela de cada uma destas chamadas.
<a name="_Toc342736995"></a><a name="_Toc345409431"></a><a name="_Toc345810936"></a><a name="_Toc345838266"></a><a name="_Toc345942401"></a><a name="_Toc345949561"></a><a name="_Toc346168678"></a><a name="_Toc348417121"></a><a name="_Toc348931377"></a><a name="_Toc353900816"></a><a name="_Toc353946346">
</a></p><h1><a name="_Toc353946346">
</a><a name="RTFToC56">4.
TÓPICOS AVANÇADOS</a>
</h1>
<p>
<b>	</b>Tópicos avançados apresenta recursos extremamente
úteis para programação orientada a objetos, por isso
convém ler este tópico somente quando você tiver uma boa
base de programação C++. Adquira prática. <b></b></p><p>
<b>	</b>A ordem em que os exemplos são apresentados é semelhante
a ordem de tópicos inicial. Como tópico avançado de
Encapsulamento temos<code> friends</code>, como tópico
avançado de herança temos herança múltipla, como
tópico avançado de polimorfismo, temos polimorfismo
paramétrico. Os demais tópicos não estão
diretamente relacionados com os anteriores.</p><p>
<b>
<a name="_Ref342220816"></a><a name="_Toc342736996"></a><a name="_Toc345409432"></a><a name="_Toc345810937"></a><a name="_Toc345838267"></a><a name="_Toc345942402"></a><a name="_Toc345949562"></a><a name="_Toc346168679"></a><a name="_Toc348417122"></a><a name="_Toc348931378"></a><a name="_Toc353900817"></a><a name="_Toc353946347"></a></b><a name="_Toc353946347">
</a></p><h2><a name="_Toc353946347">
</a><a name="RTFToC57">4.1.
FRIENDS</a>	
</h2>
<b></b><p>
<b>	</b><code>Friends </code>permite que uma classe toda ou uma
função membro acesse atributos encapsulados de outra classe. Por
este motivo, <code>friends</code> representa uma quebra do
encapsulamento e  deve portanto ser usado com muita cautela. Não raro
programadores descobrem que o uso de certos princípios de
orientação a objetos evita programar usando
demasiadamente<code> friends</code>. Se você vai aplicar este
recurso, analise bem as outras possibilidades, cheque outras abordagens
antes.<b></b></p><p>
<b>	</b>Novamente nos deparamos com um qualificador ou "specifier", mas este
tem uma diferença, não basta dizer que uma classe ou
função membro é amiga, <code>"friend", </code>
é preciso dizer de que classe ela é amiga</p><p>
	<code>Friends</code> é muito usado em conjunto com
operadores. Operadores são frequentemente usados para implementar
operações entre tipos enquanto que funções membro
comuns são mais usadas para passagem de mensagens alterando o estado de
um único objeto, segundo alguns parâmetros, normalmente tipos
simples.</p><p>
<a name="_Toc342736997"></a><a name="_Toc345409433"></a><a name="_Toc345810938"></a><a name="_Toc345838268"></a><a name="_Toc345942403"></a><a name="_Toc345949563"></a><a name="_Toc346168680"></a><a name="_Toc348417123"></a><a name="_Toc348931379"></a><a name="_Toc353900818"></a><a name="_Toc353946348">
</a></p><h3><a name="_Toc353946348">
</a><a name="RTFToC58">4.1.1.
UMA CLASSE PERMITINDO ACESSO A OUTRA</a>
</h3>
<p>
	Suponha que você está trabalhando em conjunto com um colega no
desenvolvimento de um software. Você faz a interface gráfica
enquanto que seu colega está implementado as classes estritamente
usuárias da interface gráfica. </p><p>
	Como seu colega não sabe usar sua interface gráfica ainda, ele
define algumas classes dele como <code>friends</code> de suas
classes de caixas de diálogos e janelas. Assim você ganha acesso
as definições <code>private </code>e<code>
public</code> dele nas suas classes. Ele só precisa perguntar a
você quais os nomes das suas classes. </p><p>
	Como você desconhece a implementação das classes de seu
colega, ele define pensando em você e também por razões de
portabilidade, funções membro que retornam os dados membros mais
úteis aos usuários das classes. Porém  estas
funções não retornam todos os dados membros porque alguns
objetos que ele está definindo são estruturas de
alocação dinâmica como árvores e é muito
difícil prever que tipo de acesso será feito nas estruturas.</p><p>
	Este é o tema do exemplo seguinte, só que não iremos
definir nenhuma interface gráfica, vamos apenas usar<code>
cout</code> simulando uma saída de tela mais complicada, como por
exemplo numa caixa de dialogo. Nosso objeto não define estruturas de
alocação dinâmica nenhuma, afinal o exemplo tem que ser
simples e objetivo.</p><p>
<code></code></p><p><code>
<b></b></code></p><hr><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
</code></p><p><code>
class relogio</code></p><p><code>
{</code></p><p><code>
friend class caixa_de_mensagem;</code></p><p><code>
//permitiu acesso as definicoes private e public</code></p><p><code>
private:</code></p><p><code>
 int hora;</code></p><p><code>
 int minuto;</code></p><p><code>
 int segundo;</code></p><p><code>
 //atributos private, encapsulados</code></p><p><code>
public:</code></p><p><code>
 relogio(int h,int m,int s)</code></p><p><code>
 {hora=h; minuto=m; segundo=s;}</code></p><p><code>
} ;</code></p><p><code>
</code></p><p><code>
class caixa_de_mensagem{</code></p><p><code>
public:</code></p><p><code>
void imprime(relogio a)</code></p><p><code>
{</code></p><p><code>
cout &lt;&lt; a.hora &lt;&lt; ":" &lt;&lt; a.minuto &lt;&lt; ":" &lt;&lt;
a.segundo &lt;&lt; endl;</code></p><p><code>
}</code></p><p><code>
} ;</code></p><p><code>
</code></p><p><code>
void main()</code></p><p><code>
{</code></p><p><code>
relogio meurolex(11,30,10);</code></p><p><code>
caixa_de_mensagem ativa;</code></p><p><code>
ativa.imprime(meurolex);</code></p><p><code>
}</code></p><p><code>
<b></b></code></p><hr><p><code>
</code></p><p>
<b>Resultado do programa:</b></p><p>
<b></b>11:30:10</p><p>
</p><p>
<b>Curiosidade: </b></p><p>
<b>	</b>Existem "libraries" em C++ que permitem programar em ambientes
gráficos como o Windows sem saber muitos detalhes. Estas "libraries"
definem objetos como caixas de dialogo, gerenciadores de eventos, etc. O uso
agora é diferente do descrito no exemplo: O programador só vai
utilizar os recursos gráficos padrão definidos pela "libraries".
Os objetos definidos para uso na interface gráfica são agregados
ao seu programa e podem ser chamados de dentro das implementações
das funções membro das suas classes.</p><p>
<b></b></p><p>
<b>Exercícios:</b></p><p>
<b></b>*1)Defina um iterador para a  classe lista, assim como foi definido para
a classe vetor em 3.1.6. Você provalvelmente terá que usar
noções de classes friends. Como evitar corromper o estado da
lista entre acessos a posições e incrementos do iterador
alternados? Uma sugestão é proibir as funções
membro insere início, insere último, enquanto se faz uso do
iterador. Este é um exercício avançado. Outra
sugestão é derivar uma classe a partir da base da hierarquia, e
para esta classe definir o iterador.</p><p>
<b></b></p><p>
<b></b>2)Um bom exemplo de uso de friends é o seguinte: suponha uma
classe que representa uma reta em três dimensões, e outra que
representa um plano. Use friends para criar em uma dessas classes, ou em ambas,
um a função membro que determina o ponto de
interseção entre uma reta e um plano. Se você gosta de
computação gráfica, então existe uma série
de tipos abstratos de dados que você pode definir para construir seus
programas em C++.</p><p>
	Alguém pode argumentar que a interseção descrita acima
poderia ser obtida sem o uso de friends, isto porque os dados membros das
classes usados para calcular a interseção poderiam ser lidos,
obtidos através de funções membro do tipo <code>:
get_x();</code>. Isto é verdade, mas em termos de
eficiência, talvez não de encapsulamento friends é melhor.
Explique porque.</p><p>
<b></b></p><p>
<b></b>3) Você se lembra do exemplo das contas bancárias? Melhore
este programa implementado a função de transferência de
quantias entre contas, você acha melhor defini-la como
<code>friend</code>? Porque? Quantas contas ela afeta?</p><p>
</p><p>
4)Defina a classe banco como <code>friend </code>de todas as
classes conta bancária. Muito bem, deixe como
<code>private</code> todos os métodos que o dono da conta
sozinho não pode chamar, tais como<code> computa</code>. O
banco deve conter referências para todas suas contas, as contas devem ter
um número identificador de conta. As operações sobre
contas devem ser feitas agora via banco, isto não impede que as contas
atendam a operações usuais como deposita, mas elas tem quer ser
private agora.. Veja 3.2.3.</p><p>
<a name="_Ref342710920"></a><a name="_Toc342736998"></a><a name="_Toc345409434"></a><a name="_Toc345810939"></a><a name="_Toc345838269"></a><a name="_Toc345942404"></a><a name="_Toc345949564"></a><a name="_Toc346168681"></a><a name="_Toc348417124"></a><a name="_Toc348931380"></a><a name="_Toc353900819"></a><a name="_Toc353946349">
</a></p><h3><a name="_Toc353946349">
</a><a name="RTFToC59">4.1.2.
OPERADORES E FRIENDS</a>
</h3>
<b></b><p>
<b>	</b>Vamos tomar o exemplo do tipo abstrato de dados fração de
1.4.1 e acrescentar  sobrecarga de operador e funções friends.
Fica faltando somente tratamento de exceções que é
sugerido como exercício no capítulo respectivo.</p><p>
<b></b></p><p>
<b>Tópicos abordados:</b></p><p>
<b>	</b>Sobrecarga de operador, "copy constructor" ,funções
friends. É uma implementação bastante completa e
portável de um TAD, use como referência para sintaxe de sobrecarga
de operadores.<b></b></p><p>
<b></b><code></code></p><p><code>
<b></b></code></p><hr><p><code>
<b></b>//Este programa implementa o tipo fracao.</code></p><p><code>
#ifndef OF_H</code></p><p><code>
//diretivas do compilador</code></p><p><code>
#define OF_H</code></p><p><code>
</code></p><p><code>
long mdc(long n,long d)</code></p><p><code>
 //maximo divisor comum</code></p><p><code>
//metodo de Euclides</code></p><p><code>
{</code></p><p><code>
 if (n&lt;0) n=-n;</code></p><p><code>
 if (d&lt;0) d=-d;</code></p><p><code>
 while (d!=0) {</code></p><p><code>
	long r=n % d;</code></p><p><code>
//   %=MOD</code></p><p><code>
	n=d;</code></p><p><code>
	d=r;</code></p><p><code>
	}</code></p><p><code>
	return n;</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
class fracao {</code></p><p><code>
	private:</code></p><p><code>
		long num;</code></p><p><code>
		long den;</code></p><p><code>
	public:</code></p><p><code>
		void simplifica(void);</code></p><p><code>
		//simplificacao</code></p><p><code>
		fracao(fracao &amp;t);</code></p><p><code>
		//copy constructor</code></p><p><code>
		fracao() {num=0; den=1;}</code></p><p><code>
		//construtor vazio.</code></p><p><code>
		fracao(const long t,const long m);</code></p><p><code>
		fracao(const long t) {num=t;den=1;}</code></p><p><code>
		~fracao() {};</code></p><p><code>
		//Nao precisa fazer nada</code></p><p><code>
		long get_num(void) {return num;}</code></p><p><code>
		long get_den(void) {return den;}</code></p><p><code>
</code></p><p><code>
//operacoes matematicas basicas</code></p><p><code>
		friend fracao operator+ (const fracao&amp; f,const fracao&amp; j);</code></p><p><code>
		friend fracao operator- (const fracao&amp; f,const fracao&amp; j);</code></p><p><code>
		friend fracao operator* (const fracao&amp; f,const fracao&amp; j);</code></p><p><code>
		friend fracao operator/ (const fracao&amp; f,const fracao&amp; j);</code></p><p><code>
</code></p><p><code>
//operadores de comparacao</code></p><p><code>
		friend int operator== (const fracao&amp; s,const fracao&amp; t);</code></p><p><code>
		friend int operator!= (const fracao&amp; s,const fracao&amp; t);</code></p><p><code>
		friend int operator&gt;= (const fracao&amp; s,const fracao&amp; t);</code></p><p><code>
		friend int operator&lt;= (const fracao&amp; s,const fracao&amp; t);</code></p><p><code>
		friend int operator&gt; (const fracao&amp; s,const fracao&amp; t);</code></p><p><code>
		friend int operator&lt; (const fracao&amp; s,const fracao&amp; t);</code></p><p><code>
</code></p><p><code>
//operadores de atribuicao</code></p><p><code>
	  fracao&amp; operator= (const fracao&amp; t);</code></p><p><code>
	  fracao&amp; operator+= (const fracao&amp; t);</code></p><p><code>
	  fracao&amp; operator-= (const fracao&amp; t);</code></p><p><code>
	  fracao&amp; operator*= (const fracao&amp; t);</code></p><p><code>
	  fracao&amp; operator/= (const fracao&amp; t);</code></p><p><code>
</code></p><p><code>
//operadores de input output</code></p><p><code>
	  friend istream&amp; operator&gt;&gt; (istream&amp; ci,fracao&amp; f);</code></p><p><code>
	  friend ostream&amp; operator&lt;&lt; (ostream&amp; co,const fracao&amp;
f);</code></p><p><code>
</code></p><p><code>
//operadores de conversao de tipos</code></p><p><code>
	  operator double() const;</code></p><p><code>
	  operator float() const;</code></p><p><code>
	  operator long() const;</code></p><p><code>
	  operator int() const;</code></p><p><code>
};</code></p><p><code>
#endif</code></p><p><code>
<b></b></code></p><p><code>
<b></b></code></p><hr><p><code>
<b></b></code></p><p><code>
<b></b>//codigo para a classe fracao</code></p><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
#include &lt;math.h&gt;</code></p><p><code>
#include &lt;iomanip.h&gt;</code></p><p><code>
#include &lt;stdio.h&gt;</code></p><p><code>
#include "of.h"</code></p><p><code>
</code></p><p><code>
fracao::fracao(fracao &amp;t)</code></p><p><code>
//copy constructor</code></p><p><code>
{</code></p><p><code>
num=t.num;</code></p><p><code>
den=t.den;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
void fracao::simplifica(void)</code></p><p><code>
{</code></p><p><code>
long commd;</code></p><p><code>
commd=mdc(num,den); //divisor comum</code></p><p><code>
num=num/commd;</code></p><p><code>
den=den/commd;</code></p><p><code>
if (den&lt;0) { den=-den; num=-num;};</code></p><p><code>
//move o sinal p/ cima</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
fracao&amp; fracao::operator+= (const fracao&amp; t)</code></p><p><code>
 {</code></p><p><code>
  num=num*t.den+den*t.num;</code></p><p><code>
  den=den*t.den;</code></p><p><code>
  simplifica();</code></p><p><code>
  return *this;</code></p><p><code>
 }</code></p><p><code>
</code></p><p><code>
fracao::fracao(const long t,const long m)</code></p><p><code>
{</code></p><p><code>
 num=t;</code></p><p><code>
 den=m;</code></p><p><code>
 simplifica();</code></p><p><code>
 //this-&gt;simplifica</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
fracao operator/ (const fracao&amp; f,const fracao&amp; j)</code></p><p><code>
{</code></p><p><code>
 fracao g(f.num*j.den,f.den*j.num);</code></p><p><code>
 g.simplifica();</code></p><p><code>
 //esse metodo nao pertence a g, mas ela chama</code></p><p><code>
 //g.simplifica(); isto e' permitido aqui mesmo com simplifica</code></p><p><code>
 //como private.</code></p><p><code>
 return g;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
fracao operator+ (const fracao&amp; f,const fracao&amp; j)</code></p><p><code>
{</code></p><p><code>
 fracao g((f.num*j.den)+(f.den*j.num),j.den*f.den);</code></p><p><code>
 //retorna variavel</code></p><p><code>
 g.simplifica();</code></p><p><code>
 return g;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
fracao operator- (const fracao&amp; f,const fracao&amp; j)</code></p><p><code>
{</code></p><p><code>
 fracao g((f.num*j.den)-(f.den*j.num),j.den*f.den);</code></p><p><code>
 //retorna variavel</code></p><p><code>
 g.simplifica();</code></p><p><code>
 return g;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
fracao operator* (const fracao&amp; f,const fracao&amp; j)</code></p><p><code>
{</code></p><p><code>
 fracao g(f.num*j.num,f.den*j.den);</code></p><p><code>
 //(f.num*j.num)/(f.den*j.den)</code></p><p><code>
 g.simplifica();</code></p><p><code>
 return g;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
ostream&amp; operator&lt;&lt; (ostream&amp; co,const fracao&amp; f)</code></p><p><code>
{</code></p><p><code>
 co &lt;&lt; "(" &lt;&lt; f.num &lt;&lt; "/" &lt;&lt; f.den &lt;&lt; ")";</code></p><p><code>
 return co;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
istream&amp; operator&gt;&gt; (istream&amp; ci, fracao&amp; f)</code></p><p><code>
{</code></p><p><code>
 long gcdiv;</code></p><p><code>
 //melhorar, ler mais sobre cin.</code></p><p><code>
 ci &gt;&gt; f.num &gt;&gt; f.den;</code></p><p><code>
 gcdiv=mdc(f.num,f.den);</code></p><p><code>
 f.num=f.num/gcdiv;</code></p><p><code>
 f.den=f.den/gcdiv;</code></p><p><code>
 return ci;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
int operator== (const fracao&amp; s,const fracao&amp; t)</code></p><p><code>
{</code></p><p><code>
 return ((s.num*t.den)==(s.den*t.num));</code></p><p><code>
 //veja operacoes matematicas com fracao</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
int operator!= (const fracao&amp; s,const fracao&amp; t)</code></p><p><code>
{</code></p><p><code>
 return ((s.num*t.den)!=(s.den*t.num));</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
int operator&lt;= (const fracao&amp; s,const fracao&amp; t)</code></p><p><code>
{</code></p><p><code>
 return ((s.num*t.den)&lt;=(s.den*t.num));</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
int operator&lt; (const fracao&amp; s,const fracao&amp; t)</code></p><p><code>
{</code></p><p><code>
return ((s.num*t.den)&lt;(s.den*t.num));</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
int operator&gt; (const fracao&amp; s,const fracao&amp; t)</code></p><p><code>
{</code></p><p><code>
return ((s.num*t.den)&gt;(s.den*t.num));</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
int operator&gt;= (const fracao&amp; s,const fracao&amp; t)</code></p><p><code>
{</code></p><p><code>
 return ((s.num*t.den)&gt;=(s.den*t.num));</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
 fracao&amp; fracao::operator= (const fracao&amp; t)</code></p><p><code>
 //equivale a copy constructor</code></p><p><code>
 {</code></p><p><code>
  num=t.num;</code></p><p><code>
  den=t.den;</code></p><p><code>
  return *this;</code></p><p><code>
 }</code></p><p><code>
</code></p><p><code>
 fracao&amp; fracao::operator-= (const fracao&amp; t)</code></p><p><code>
  {</code></p><p><code>
  num=num*t.den-den*t.num;</code></p><p><code>
  den=den*t.den;</code></p><p><code>
  simplifica();</code></p><p><code>
  return *this;</code></p><p><code>
  //ponteiro para o proprio objeto (o apontado por this)</code></p><p><code>
 }</code></p><p><code>
</code></p><p><code>
 fracao&amp; fracao::operator*= (const fracao&amp; t)</code></p><p><code>
 {</code></p><p><code>
  num=num*t.num;</code></p><p><code>
  den=den*t.den;</code></p><p><code>
  simplifica();</code></p><p><code>
  return *this;</code></p><p><code>
 }</code></p><p><code>
</code></p><p><code>
 fracao&amp; fracao::operator/= (const fracao&amp; t)</code></p><p><code>
 {</code></p><p><code>
  num=num*t.den;</code></p><p><code>
  den=den*t.num;</code></p><p><code>
  simplifica();</code></p><p><code>
  return *this;</code></p><p><code>
 }</code></p><p><code>
</code></p><p><code>
fracao::operator double() const</code></p><p><code>
{</code></p><p><code>
double dbl;</code></p><p><code>
dbl=(double(num)/double(den));</code></p><p><code>
return dbl;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
fracao::operator float() const</code></p><p><code>
{</code></p><p><code>
float flt;</code></p><p><code>
flt=(float(num)/float(den));</code></p><p><code>
return flt;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
fracao::operator long() const</code></p><p><code>
{</code></p><p><code>
long lng;</code></p><p><code>
lng=num/den;</code></p><p><code>
return lng;</code></p><p><code>
}</code></p><p><code>
//converte fracao para long </code></p><p><code>
</code></p><p><code>
fracao::operator int() const</code></p><p><code>
{</code></p><p><code>
int ntgr;</code></p><p><code>
ntgr=int(num/den);</code></p><p><code>
return ntgr;</code></p><p><code>
}<b></b></code></p><p><code>
<b></b></code></p><p><code>
<b></b></code></p><hr><p><code>
<b></b></code></p><p><code>
<b></b>//programa principal, testes e demonstracao</code></p><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
#include "of.h"</code></p><p><code>
//definicao da fracao</code></p><p><code>
#include &lt;stdio.h&gt;</code></p><p><code>
main()</code></p><p><code>
{</code></p><p><code>
char g;</code></p><p><code>
cout &lt;&lt; " Entre com fracao a: ";</code></p><p><code>
fracao a,b;</code></p><p><code>
cin &gt;&gt; a;</code></p><p><code>
cout&lt;&lt; "a"&lt;&lt; a &lt;&lt; "\n";</code></p><p><code>
cout &lt;&lt; " Entre fracao b:";</code></p><p><code>
cin &gt;&gt; b;</code></p><p><code>
cout &lt;&lt; "b" &lt;&lt; b &lt;&lt; "\n";</code></p><p><code>
fracao c;</code></p><p><code>
c=a+b;</code></p><p><code>
cout &lt;&lt; "c=a+b " &lt;&lt; c &lt;&lt; "\n";</code></p><p><code>
fracao d(c);</code></p><p><code>
cout &lt;&lt; "fracao d(c)"&lt;&lt; d &lt;&lt; endl;</code></p><p><code>
//e' o que chamamos de copy constructor</code></p><p><code>
cout &lt;&lt; "a*b " &lt;&lt; (a*b)&lt;&lt; "\n";</code></p><p><code>
cout &lt;&lt; "a-b " &lt;&lt; (a-b)&lt;&lt; "\n";</code></p><p><code>
cout &lt;&lt; "a/b " &lt;&lt; (a/b)&lt;&lt; "\n";</code></p><p><code>
cout &lt;&lt; "a&gt;b " &lt;&lt; (a&gt;b)&lt;&lt; "\n";</code></p><p><code>
cout &lt;&lt; "a&lt;b " &lt;&lt; (a&lt;b)&lt;&lt; "\n";</code></p><p><code>
cout &lt;&lt; "a&lt;=b " &lt;&lt; (a&lt;=b)&lt;&lt; "\n";</code></p><p><code>
cout &lt;&lt; "a&gt;=b " &lt;&lt; (a&gt;=b)&lt;&lt; "\n";</code></p><p><code>
cout &lt;&lt; "a==b " &lt;&lt; (a==b)&lt;&lt; "\n";</code></p><p><code>
cout &lt;&lt; "a!=b " &lt;&lt; (a!=b)&lt;&lt; "\n";</code></p><p><code>
c=a;</code></p><p><code>
a*=b;</code></p><p><code>
cout &lt;&lt; "a*=b " &lt;&lt; a&lt;&lt; "\n";</code></p><p><code>
a=c;</code></p><p><code>
a/=b;</code></p><p><code>
cout &lt;&lt; "a/=b " &lt;&lt; a&lt;&lt; "\n";</code></p><p><code>
a=c;</code></p><p><code>
a+=b;</code></p><p><code>
cout &lt;&lt; "a+=b " &lt;&lt; a &lt;&lt; "\n";</code></p><p><code>
a=c;</code></p><p><code>
a-=b;</code></p><p><code>
cout &lt;&lt; "a-=b " &lt;&lt; a&lt;&lt; "\n";</code></p><p><code>
a=c;</code></p><p><code>
cout &lt;&lt; "long(a) " &lt;&lt; long(a) &lt;&lt; "\n";</code></p><p><code>
cout &lt;&lt; "double(a) " &lt;&lt; double(a) &lt;&lt; "\n";</code></p><p><code>
cout &lt;&lt; "int(a) " &lt;&lt; int(a) &lt;&lt; "\n";</code></p><p><code>
cout &lt;&lt; "float(a) " &lt;&lt; float(a) &lt;&lt; "\n";</code></p><p><code>
cin &gt;&gt; g;</code></p><p><code>
return 0;</code></p><p><code>
}<b></b></code></p><p><code>
<b></b></code></p><hr><p><code>
</code><b></b></p><p>
<b>Resultado do programa:</b></p><p>
<b></b>Entre fracao a:9</p><p>
8</p><p>
a(9/8)</p><p>
 Entre fracao b:9</p><p>
4</p><p>
b(9/4)</p><p>
c=a+b (27/8)</p><p>
fraction d(c)(27/8)</p><p>
a*b (81/32)</p><p>
a-b (-9/8)</p><p>
a/b (1/2)</p><p>
a&gt;b 0</p><p>
a&lt;b 1</p><p>
a&lt;=b 1</p><p>
a&gt;=b 0</p><p>
a==b 0</p><p>
a!=b 1</p><p>
a*=b (81/32)</p><p>
a/=b (1/2)</p><p>
a+=b (27/8)</p><p>
a-=b (-9/8)</p><p>
long(a) 1</p><p>
double(a) 1.125</p><p>
int(a) 1</p><p>
float(a) 1.125</p><p>
<b></b></p><p>
<b>Resultado do programa:</b></p><p>
<b> </b>Entre fracao a:1</p><p>
2</p><p>
a(1/2)</p><p>
Entre fracao b:5</p><p>
3</p><p>
b(5/3)</p><p>
c=a+b (13/6)</p><p>
fraction d(c)(13/6)</p><p>
a*b (5/6)</p><p>
a-b (-7/6)</p><p>
a/b (3/10)</p><p>
a&gt;b 0</p><p>
a&lt;b 1</p><p>
a&lt;=b 1</p><p>
a&gt;=b 0</p><p>
a==b 0</p><p>
a!=b 1</p><p>
a*=b (5/6)</p><p>
a/=b (3/10)</p><p>
a+=b (13/6)</p><p>
a-=b (-7/6)</p><p>
long(a) 0</p><p>
double(a) 0.5</p><p>
int(a) 0</p><p>
float(a) 0.5</p><p>
<b></b></p><p>
<b>Exercícios:</b></p><p>
1)Defina um tipo abstrato de dados matriz (do campo da matemática) com
sobrecarga de operadores que permita acessar via índice linear ou
linha/coluna qualquer elemento da matriz. Defina outras funções
membro que achar importantes. Por herança, construa a classe matriz
quadrada, defina a função membro transposta para esta matriz. </p><p>
	Dependendo doas funções membro que você implementar
haverá bastante trabalho referente a tratamento de
exceções, por exemplo: matrizes singulares não são
inversíveis, existem restrições para a
multiplicação e até mesmo para a soma e
subtração visto que as dimensões nas duas últimas
operações tem que ser iguais.</p><p>
<b></b>
</p><h2>
<a name="RTFToC60">4.2.
</a><a name="_Ref342721811"></a><a name="_Toc342736999"></a><a name="_Toc345409435"></a><a name="_Toc345810940"></a><a name="_Toc345838270"></a><a name="_Toc345942405"></a><a name="_Toc345949565"></a><a name="_Toc346168682"></a><a name="_Toc348417125"></a><a name="_Toc348931381"></a><a name="_Toc353900820"></a><a name="_Toc353946350">
HERANÇA MÚLTIPLA</a>
</h2>
<b></b>

 "Herança:múltipla"Se nos exemplos                                                            
anteriores tínhamos uma hierarquia que se                                                     
comportava da seguinte maneira:                                                               
<center>
<img src="TUTORIAL_unicamp_c++_files/lista.gif">
</center>
<b>
	</b><p>
<b></b>Agora teremos algo como:

</p><pre><center>
<img src="TUTORIAL_unicamp_c++_files/radiorel.gif">
</center>
                 
<p>                                                                             
</p><center>
<img src="TUTORIAL_unicamp_c++_files/estagi1.gif">
</center>

</pre>


<pre>ou então:                                                                                     
<center>
<img src="TUTORIAL_unicamp_c++_files/veiculo.gif">
</center>

</pre>

Tendo o seguinte significado: A classe herdeira tem comportamento, "behaviour",
semelhante ao das duas classes pais.		<b></b><p>
<b></b>
</p><h3>
<a name="RTFToC61">4.2.1.
</a><a name="_Toc342737000"></a><a name="_Toc345409436"></a><a name="_Toc345810941"></a><a name="_Toc345838271"></a><a name="_Toc345942406"></a><a name="_Toc345949566"></a><a name="_Toc346168683"></a><a name="_Toc348417126"></a><a name="_Toc348931382"></a><a name="_Toc353900821"></a><a name="_Toc353946351">
UM EXEMPLO SIMPLES.</a>
</h3>
<p>
Este exemplo seria sobre como implementar uma hierarquia semelhante a
hierarquia 1, mas não está pronto ainda . Precisamos de
sugestões sobre exemplos mais claros que um rádio relógio
ou um Estagiário Remunerado. O exemplo seguinte supre a falta deste, mas
o apredizado é mas abrupto.</p><p>
<b></b>
</p><h3>
<a name="RTFToC62">4.2.2.
</a><a name="_Toc342737001"></a><a name="_Toc345409437"></a><a name="_Toc345810942"></a><a name="_Toc345838272"></a><a name="_Toc345942407"></a><a name="_Toc345949567"></a><a name="_Toc346168684"></a><a name="_Toc348417127"></a><a name="_Toc348931383"></a><a name="_Toc353900822"></a><a name="_Toc353946352">
VIRTUAL PUBLIC E RESOLUÇÃO DE
CONFLITOS.</a>
</h3>
<p>
	Referente ao diagrama hierarquia de veículos apresentado neste
tópico.<b></b></p><p>
<b></b>O que este caso tem de novo com relação ao anterior
é  que veículo utilitário pode herdar as
características de veículo por dois ramos da "hierarquia" de
herança, como prevenir os possíveis conflitos decorrentes deste
fato? Simples, os pais de veículo utilitário devem receber
veículo (a classe comum) através do qualificador
<code>virtual public</code>.<b></b></p><p>
<b></b>Este exemplo também apresenta a estratégia para
resolução de conflitos de nomes em herança
múltipla, lembre-se que agora as classes pai podem ter nomes,
identificadores em comum. Nesse caso usamos o operador de
resolução de escopo <code>::</code> , veja os
comentários.</p><p>
<b></b></p><p>
<b>Tópicos abordados: </b></p><p>
<b>	</b>Resolução de conflitos quando existe mais de um caminho
de herança para uma classe pai (veículo),  chamada do construtor
para essa classe pai nas classes filhas. Resolução de conflitos
entre identificadores comuns.</p><p>
<code></code></p><p><code>
<b></b></code></p><hr><p><code>
<b></b>//header file</code></p><p><code>
class veiculo {</code></p><p><code>
private:</code></p><p><code>
	char* nome; //qualificacao do veiculo</code></p><p><code>
	int peso; //massa do veiculo</code></p><p><code>
	int hp; //potencia em hp.</code></p><p><code>
public:</code></p><p><code>
	veiculo(char* n,int p,int h);</code></p><p><code>
	void altera_hp(int en);</code></p><p><code>
	int retorna_hp(void);</code></p><p><code>
	void altera_peso(int en);</code></p><p><code>
	int retorna_peso(void);</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
class v_passeio:virtual public veiculo {</code></p><p><code>
private:</code></p><p><code>
	int vol_int; //volume interno.</code></p><p><code>
public:</code></p><p><code>
	v_passeio(char* n,int p,int hp,int vi);</code></p><p><code>
	void altera_vi(int en);</code></p><p><code>
	int retorna_vi(void);</code></p><p><code>
	float peso_pot(void); //relacao peso potencia.</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
class v_carga:virtual public veiculo {</code></p><p><code>
private:</code></p><p><code>
	int carga; //carga do veiculo.</code></p><p><code>
public:</code></p><p><code>
	v_carga(char* n,int p,int hp,int c);</code></p><p><code>
	void altera_carga(int en);</code></p><p><code>
	int retorna_carga(void);</code></p><p><code>
	float peso_pot(void); //relacao peso potencia, veiculo carregado</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
class v_utilitario:public v_passeio,public v_carga {</code></p><p><code>
private:</code></p><p><code>
//qualquer outro atributo unico de v_utilitario.</code></p><p><code>
public:</code></p><p><code>
	v_utilitario(char* n,int p,int hp,int vi,int c);</code></p><p><code>
	float peso_pot(void);</code></p><p><code>
};</code></p><p><code>
<b></b></code></p><p><code>
<b></b></code></p><hr><p><code>
<b></b></code></p><p><code>
<b></b>//implementation file</code></p><p><code>
#include "multiple.h"</code></p><p><code>
</code></p><p><code>
veiculo::veiculo(char* n,int p,int h)</code></p><p><code>
{ nome=n; peso=p; hp=h; }</code></p><p><code>
</code></p><p><code>
void veiculo::altera_peso(int en)</code></p><p><code>
{ peso=en;}</code></p><p><code>
</code></p><p><code>
int veiculo::retorna_peso(void)</code></p><p><code>
{ return peso; }</code></p><p><code>
</code></p><p><code>
void veiculo::altera_hp(int en)</code></p><p><code>
{ hp=en; }</code></p><p><code>
</code></p><p><code>
int veiculo::retorna_hp(void)</code></p><p><code>
{ return hp;}</code></p><p><code>
</code></p><p><code>
v_passeio::v_passeio(char* n,int p,int hp,int vi):veiculo(n,p,hp)</code></p><p><code>
{ vol_int=vi; }</code></p><p><code>
</code></p><p><code>
void v_passeio::altera_vi(int en)</code></p><p><code>
{ vol_int=en; }</code></p><p><code>
</code></p><p><code>
int v_passeio::retorna_vi(void)</code></p><p><code>
{ return vol_int; }</code></p><p><code>
</code></p><p><code>
float v_passeio::peso_pot(void)</code></p><p><code>
{ return float(retorna_peso())/float(retorna_hp()); }</code></p><p><code>
</code></p><p><code>
v_carga::v_carga(char* n,int p,int hp,int c):veiculo(n,p,hp)</code></p><p><code>
{ carga=c; }</code></p><p><code>
</code></p><p><code>
void v_carga::altera_carga(int en)</code></p><p><code>
{ carga=en; }</code></p><p><code>
</code></p><p><code>
int v_carga::retorna_carga(void)</code></p><p><code>
{ return carga; }</code></p><p><code>
</code></p><p><code>
float v_carga::peso_pot(void)</code></p><p><code>
{ return float(retorna_peso()+carga)/float(retorna_hp()); }</code></p><p><code>
</code></p><p><code>
v_utilitario::v_utilitario(char* m,int p,int hp,int vi,int
c):v_carga(m,p,hp,c),v_passeio(m,p,hp,vi),veiculo(m,p,hp)</code></p><p><code>
{</code></p><p><code>
//o construtor veiculo(m,p,hp) declarado aqui e que vale,</code></p><p><code>
//os construtores veiculo(m,p,hp) hierarquia acima sao descartados</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
float v_utilitario::peso_pot(void)</code></p><p><code>
{ return v_carga::peso_pot(); }</code></p><p><code>
<b></b></code></p><p><code>
<b></b></code></p><hr><p><code>
<b></b></code></p><p><code>
<b></b>//main file</code></p><p><code>
#include "multiple.h"</code></p><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
void main()</code></p><p><code>
{</code></p><p><code>
v_passeio v1("Toyota Corolla",300,130,3);</code></p><p><code>
cout &lt;&lt; v1.peso_pot()&lt;&lt;endl;</code></p><p><code>
v_utilitario v2("Pick-up A",400,180,2,400);</code></p><p><code>
cout &lt;&lt; v2.peso_pot()&lt;&lt;endl;</code></p><p><code>
cout &lt;&lt; v2.retorna_peso();</code></p><p><code>
}</code></p><p><code>
<b></b></code></p><hr><p><code>
</code><b></b></p><p>
<b>Comentários: </b><code><b></b></code></p><p><code>
<b></b>float v_utilitario::peso_pot(void)</code></p><p><code>
{ return v_carga::peso_pot(); }</code></p><p><code>
</code><b></b></p><p>
<b></b>	A função membro <code>peso_pot</code>
está presente em todas as classes da "hierarquia".  Na
classe<code> veiculo utilitario</code> ela não precisa ser
reimplementada, basta escolher se em termos de peso potência,
<code> veiculo utilitario</code> deve se comportar como
<code>veiculo de carga</code> ou como<code> veiculo de
passeio</code>.</p><p>
A escolha do comportamento foi a de <code>veiculo de carga</code>,
agora o que temos a fazer é chamar a função membro
<code>peso_pot </code>de<code> veiculo de carga</code>
que já está implementada,  o que fazer para distinguir entre a
função membro de mesmo nome da classe base<code> veiculo de
passeio</code>? Usa-se o operador de resolução de escopo,
mas agora acompanhado do nome da classe base que se deseja acessar:
<code>v_carga::peso_pot();</code>. A mesma estratégia
é adotada para dados membros em conflito: <code>
nome_classe_pai::dado_membro_em_conflito; </code>, neste caso os
atributos em comum estão na classe <code>veiculo</code>,
topo da "hierarquia".</p><p>
</p><p>
<b>Resultado do programa:</b></p><p>
<b></b>2.30769</p><p>
4.44444</p><p>
400</p><p>
</p><p>
<b>Exercícios: </b></p><p>
<b></b>1) Modifique este exemplo para que em veículos  com capacidade de
carga<code> (v_carga e v_utilitario) </code> peso potência
imprima a potência do veículo carregado e também a
potência do veículo descarregado, bem como a categoria (classe) do
veículo.</p><p>
<b>
<a name="_Ref342301505"></a><a name="_Toc342737002"></a><a name="_Toc345409438"></a><a name="_Toc345810943"></a><a name="_Toc345838273"></a><a name="_Toc345942408"></a><a name="_Toc345949568"></a><a name="_Toc346168685"></a><a name="_Toc348417128"></a><a name="_Toc348931384"></a><a name="_Toc353900823"></a><a name="_Toc353946353"></a></b><a name="_Toc353946353">
</a></p><h2><a name="_Toc353946353">
</a><a name="RTFToC63">4.3.
POLIMORFISMO PARAMÉTRICO
(TEMPLATE</a>)
</h2>
<p>
Polimorfismo paramétrico é um recurso bastante útil para
evitar redundância de código, portanto se trata de um meio de
reuso deste. É importante para criar famílias de classes ou
funções relacionadas.</p><p>
	Este recurso permite por exemplo definir uma classe matriz (do campo da
matemática) uma única vez num "header file" e utilizar esta
classe matriz para matrizes de tipo<code> float</code>,
tipo<code> int</code> ou <code>long</code> ,etc.
É muito importante e existência de um comportamento uniforme entre
os tipos que serão instanciados, por exemplo se na sua classe matriz
você usa o operador %, todos os tipos a serem instanciados
(susbtituídos como tipo usado na matriz) devem atender da maneira
desejada a esse operador.</p><p>
	Em linguagens orientadas a objetos que não definem sobrecarga de
operador (Módula-3) surge um problema: suponha que você definiu o
tipo fração e quer usar em sua matriz de tipos parametrizados
tanto o tipo fração quanto o tipo inteiro. Como uniformizar o
comportamento desses tipos no que se refere a operação
de<code> soma </code>usada na classe matriz? Uma
solução é redefinir o tipo inteiro oferecido pela
linguagem de modo que ele atenda a função membro de mesmo nome
usada no tipo fração, exemplo a função<code>
soma(novo_inteiro a);. </code></p><p>
<b></b>
</p><h3>
<a name="RTFToC64">4.3.1.
</a><a name="_Ref342701822"></a><a name="_Toc342737003"></a><a name="_Toc345409439"></a><a name="_Toc345810944"></a><a name="_Toc345838274"></a><a name="_Toc345942409"></a><a name="_Toc345949569"></a><a name="_Toc346168686"></a><a name="_Toc348417129"></a><a name="_Toc348931385"></a><a name="_Toc353900824"></a><a name="_Toc353946354">
TAD VETOR</a> 
</h3>
<b></b><p>
<b></b>	Modificação do programa vetor de 1.5.3.6 para suportar
polimorfismo paramétrico<code> (template). </code></p><p>
	Uma condição para que o polimorfismo paramétrico funcione
bem é: Os tipos que são substituídos no<code>
template</code> devem se comportar de maneira uniforme para exemplificar
isso vamos substituir no template da classe vetor o tipo fração
com sobrecarga de operadores de 4.1.2 e o tipo
<code>float</code>.</p><p>
	Foi proposta a implementação do tipo abstrato de dados string,
uma boa indicação da qualidade de sua implementação
é uma substituição no template deste exemplo sem acarretar
modificações, isto só vale se nessa
implementação já foi feita sobrecarga de operadores
(comparação entre strings).</p><p>
	Dica de implementação: Se você deseja fazer um programa
que use "templates" seguir os passos indicados abaixo normalmente lhe
poupará tempo:</p><p>
</p><p>
-Defina os tipos que você quer parametrizar um termos de chamadas de
funções membro e operadores de nomes e sintaxe iguais
(uniformidade). Os tipos dos argumentos vão variar.</p><p>
-Construa seu programa para operar em um só destes tipos.</p><p>
-Termine incluindo as definições dos templates no programa e
testando para os demais tipos.</p><p>
-Corrija as eventuais falhas de substituição.</p><p>
<code>	</code></p><p><code>
<b></b></code></p><hr><p><code>
//tempvet.h definicao da classe vetor com template.</code></p><p><code>
#include &lt;stdlib.h&gt;</code></p><p><code>
//header file para classe vetor</code></p><p><code>
const int inicio=0;</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt; class vetor{ //T e' o tipo do elemento do vetor</code></p><p><code>
private:</code></p><p><code>
T* v;  //pode ser qualquer tipo que atenda as operacoes &lt; &gt; =</code></p><p><code>
int tamanho;</code></p><p><code>
public:</code></p><p><code>
vetor (int tamanho) ;</code></p><p><code>
T&amp; operator[] (int i);</code></p><p><code>
T maximo();</code></p><p><code>
int primeiro(void);</code></p><p><code>
int ultimo(void);</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt; vetor&lt;T&gt;::vetor (int tam)</code></p><p><code>
{v=new T[tam]; tamanho=tam;}</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt; int vetor&lt;T&gt;::primeiro (void)</code></p><p><code>
{return inicio;}</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt; int vetor&lt;T&gt;::ultimo (void)</code></p><p><code>
{ return tamanho-1; }</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt; T&amp; vetor&lt;T&gt;::operator[](int i)</code></p><p><code>
{</code></p><p><code>
 if (i&lt;0 || i&gt;=tamanho) {cout &lt;&lt; "Fora dos limites!"; exit(1);}</code></p><p><code>
 //use exception handling to make it check bounds for you.</code></p><p><code>
  return v[i];</code></p><p><code>
 }</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt; T vetor&lt;T&gt;:: maximo(void)</code></p><p><code>
{int candidato=inicio;</code></p><p><code>
 for (int i=inicio;i&lt;tamanho;i++)</code></p><p><code>
 if (v[i]&gt;v[candidato]) candidato=i;</code></p><p><code>
 return v[candidato];}</code></p><p><code>
</code></p><p><code>
<b></b></code></p><hr><p><code>
</code></p><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
#include "exvet3.h"</code></p><p><code>
</code></p><p><code>
main()</code></p><p><code>
{</code></p><p><code>
vetor&lt;float&gt; meu(5);</code></p><p><code>
</code></p><p><code>
for (int i=meu.primeiro();i&lt;=meu.ultimo();i++)</code></p><p><code>
{</code></p><p><code>
</code></p><p><code>
 cout &lt;&lt; "Entre com valor da posicao:" &lt;&lt; i &lt;&lt; "\n";</code></p><p><code>
 cin &gt;&gt; meu[i];</code></p><p><code>
}</code></p><p><code>
for (int j=meu.primeiro();j&lt;=meu.ultimo();j++) cout&lt;&lt; meu[j]&lt;&lt; "
";</code></p><p><code>
cout &lt;&lt; endl &lt;&lt; "Maximo:" &lt;&lt; meu.maximo();</code></p><p><code>
return 0;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
<b></b></code></p><hr><p><code>
</code></p><p><code>
//main file, programa principal</code></p><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
#include "exvet3.h"</code></p><p><code>
#include "fractio2.h"</code></p><p><code>
#include "fractio2.cpp"</code></p><p><code>
main()</code></p><p><code>
{</code></p><p><code>
vetor&lt;fraction&gt; meu(5);</code></p><p><code>
</code></p><p><code>
for (int i=meu.primeiro();i&lt;=meu.ultimo();i++)</code></p><p><code>
{</code></p><p><code>
</code></p><p><code>
 cout &lt;&lt; "Entre com valor da posicao:" &lt;&lt; i &lt;&lt; "\n";</code></p><p><code>
 cin &gt;&gt; meu[i];</code></p><p><code>
}</code></p><p><code>
for (int j=meu.primeiro();j&lt;=meu.ultimo();j++) cout&lt;&lt; meu[j]&lt;&lt; "
";</code></p><p><code>
cout &lt;&lt; endl &lt;&lt; "Maximo:" &lt;&lt; meu.maximo();</code></p><p><code>
return 0;</code></p><p><code>
}</code></p><p><code>
<b></b></code></p><hr><p><code>
</code></p><p>
</p><p>
<b>Comentários</b>:</p><p>
	Se você substituísse no template do vetor o tipo
fração que vamos definido em 4.1.2, o resultado seria  igual ao
apresentado no sub-tópico resultado do programa em comentários.
Isto é só a título de curiosidade. Você não
precisa tentar implementar um tipo fração para uso neste
<code>template </code>ainda.</p><p>
<b></b></p><p>
<b>Resultado de teste do programa em comentários:</b></p><p>
<b></b>Entre com valor da posicao:0</p><p>
1</p><p>
2</p><p>
Entre com valor da posicao:1</p><p>
5</p><p>
4</p><p>
Entre com valor da posicao:2</p><p>
6</p><p>
1</p><p>
Entre com valor da posicao:3</p><p>
2</p><p>
8</p><p>
Entre com valor da posicao:4</p><p>
4</p><p>
2</p><p>
(1/2) (5/4) (6/1) (1/4) (2/1)</p><p>
Maximo: (6/1)</p><p>
</p><p>
</p><p>
<b>Resultado do programa com o tipo float parametrizado</b>:</p><p>
Entre com valor da posicao:0</p><p>
1.2</p><p>
Entre com valor da posicao:1</p><p>
2.1</p><p>
Entre com valor da posicao:2</p><p>
5.3</p><p>
Entre com valor da posicao:3</p><p>
1.5</p><p>
Entre com valor da posicao:4</p><p>
1.9</p><p>
1.2 2.1 5.3 1.5 1.9</p><p>
Maximo:5.3</p><p>
</p><p>
<b>Exercícios:</b></p><p>
<b></b>1)Crie uma função membro troca que recebe como argumentos
dois índices do vetor e faz a troca deles.
</p><h3>
<a name="RTFToC65">4.3.2.
</a><a name="_Toc342737004"></a><a name="_Toc345409440"></a><a name="_Toc345810945"></a><a name="_Toc345838275"></a><a name="_Toc345942410"></a><a name="_Toc345949570"></a><a name="_Toc346168687"></a><a name="_Toc348417130"></a><a name="_Toc348931386"></a><a name="_Toc353900825"></a><a name="_Toc353946355">
TEMPLATE DE FUNÇÃO</a>
</h3>
<b></b><p>
<b></b>	Template de função , introduziremos tipos parametrizados
na função mdc que calcula o máximo divisor comum tanto
para long quanto para int e outros tipos que definam o operador
%:<code></code></p><p><code>
<b></b></code></p><hr><p><code>
//exemplo facil de templates de funcao</code></p><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt; T mdc(T n,T d)  //maximo divisor comum</code></p><p><code>
//metodo de Euclides</code></p><p><code>
{</code></p><p><code>
 if (n&lt;0) n=-n;</code></p><p><code>
 if (d&lt;0) d=-d;</code></p><p><code>
 while (d!=0) {</code></p><p><code>
	T r=n % d; //template T    %=MOD</code></p><p><code>
	n=d;</code></p><p><code>
	d=r;</code></p><p><code>
	}</code></p><p><code>
	return n;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
void main(void)</code></p><p><code>
{</code></p><p><code>
int a=5;</code></p><p><code>
long b=6;</code></p><p><code>
long c=7;</code></p><p><code>
int d=14;</code></p><p><code>
cout &lt;&lt; "mdc(5,6)=" &lt;&lt; mdc(a,6) &lt;&lt; "\n";  //int int</code></p><p><code>
cout &lt;&lt; "mdc(2,3)=" &lt;&lt; mdc(2,3) &lt;&lt; "\n"; //int int || long
long</code></p><p><code>
cout &lt;&lt; "mdc(6,7)=" &lt;&lt; mdc(b,c) &lt;&lt; "\n";//long long</code></p><p><code>
cout &lt;&lt; "mdc(7,14)=" &lt;&lt; mdc(c,d) &lt;&lt; "\n"; //long int
//erro!!!!</code></p><p><code>
}</code></p><p><code>
<b></b></code></p><p><code>
<b></b></code></p><hr><p><code>
<b></b></code></p><p><code>
<b></b>//Versao que nao produz erro.</code></p><p><code>
//exemplo facil de templates de funcao</code></p><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt; T mdc(T n,T d)  //maximo divisor comum</code></p><p><code>
//metodo de Euclides</code></p><p><code>
{</code></p><p><code>
 if (n&lt;0) n=-n;</code></p><p><code>
 if (d&lt;0) d=-d;</code></p><p><code>
 while (d!=0) {</code></p><p><code>
	T r=n % d; //template T    %=MOD</code></p><p><code>
	n=d;</code></p><p><code>
	d=r;</code></p><p><code>
	}</code></p><p><code>
	return n;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
long mdc(long m,long n); //definicao exata, long prevalece sobre int em termos
de conversao</code></p><p><code>
//nao acrescente int mdc(int a,int b); voce tera ambiguidades e o compilador
nao fara a //conversao</code></p><p><code>
</code></p><p><code>
void main(void)</code></p><p><code>
{</code></p><p><code>
int a=5;</code></p><p><code>
long b=6;</code></p><p><code>
long c=7;</code></p><p><code>
int d=14;</code></p><p><code>
cout &lt;&lt; "mdc(5,6)=" &lt;&lt; mdc(a,6) &lt;&lt; "\n";  //int int</code></p><p><code>
cout &lt;&lt; "mdc(2,3)=" &lt;&lt; mdc(2,3) &lt;&lt; "\n"; //int int || long
long</code></p><p><code>
cout &lt;&lt; "mdc(6,7)=" &lt;&lt; mdc(b,c) &lt;&lt; "\n";//long long</code></p><p><code>
cout &lt;&lt; "mdc(7,14)=" &lt;&lt; mdc(c,d) &lt;&lt; "\n"; //long int  OK,
conversao.</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
<b></b></code></p><hr><p><code>
</code><b></b></p><p>
<b>Comentários: </b></p><p>
<b>	</b>Na primeira versão do programa tudo funciona bem, com
exceção da última linha, ela produz um erro que é
corrigido na segunda versão do programa. Vamos explicar esse
erro:<b></b></p><p>
<b></b>	Quando o compilador resolve, decide, uma chamada de
função ele primeiro tentar achar uma definição
exata dela (tipos já definidos) exemplo <code>long mdc (int a,long
b);. </code><b></b></p><p>
<b></b>	Se não houver nenhuma versão exata o compilador tenta
achar uma versão com tipos paramétricos que aceite os tipos da
chamada da função, no caso uma definição de
template que aceitaria seria: <code>template&lt;class T1,class T2&gt; T2
max(T2 n,T1 d) </code>, que é um tanto perigosa em termos de
operações entre tipos, por isso também não foi
fornecida.<b></b></p><p>
<b></b>	Se esta tentativa também falhar o compilador tenta fazer a
conversão implícita do argumento de modo a satisfazer uma
definição exata, essa conversão não pode resultar
numa ambiguidade. Na segunda versão fornecemos uma versão exata:
<code>long mdc (long a, long b);. </code> somente, não
deixando margens para ambiguidades.</p><p>
<b></b></p><p>
<b>Exercícios:</b></p><p>
1) Use um programa antigo feito em outra linguagem, ou mesmo em C. Tente
identificar as possíveis substituições por tipos
paramétricos que poderiam ser feitas com sucesso e segurança. Em
que casos outras soluções seriam melhores e mais seguras? Que
soluções?</p><p>
</p><p>
2)Perceba que nada impede que você chame a função
<code>mdc</code> para dois argumentos
<code>float</code>, o compilador executa de fato a chamada e vai
acusar erro  na operação <code>%</code> que
não é definida para este tipo. Por isso é que se diz que
os tipos parametrizados devem se comportar de maneira uniforme, com
operações semelhantes. </p><p>
	Defina uma função de ordenação de vetor, com tipos
paramétricos e que se baseie na existência em alguns dos
operadores<code> &lt; , &gt; , &lt;= , &gt;= , ==</code> nos tipos
usados.</p><p>
	Observe que se quiséssemos usar nosso tipo fracao nesta
função teríamos que definir o(s) operador(es)
relacional(is) usado(s), . Para fazer esta definição você
terá ler 4.1.2.</p><p>
</p><p>
3)Escreva uma função troca com tipos parametrizados. Você
deve usar passagem por referência para trocar os dois argumentos do mesmo
tipo parametrizado que são passados: <code>void troca (T a,T b);
</code></p><p>
</p><p>
4)Mesmo quando você não tem um motivo imediato para utilizar tipos
parametrizados em uma aplicação faz sentido fazê-lo? Se sim
em que casos?</p><p>
<b></b>
</p><h3>
<a name="RTFToC66">4.3.3.
  
</a><a name="_Toc342737005"></a><a name="_Toc345409441"></a><a name="_Toc345810946"></a><a name="_Toc345838276"></a><a name="_Toc345942411"></a><a name="_Toc345949571"></a><a name="_Toc346168688"></a><a name="_Toc348417131"></a><a name="_Toc348931387"></a><a name="_Toc353900826"></a><a name="_Toc353946356">HERANÇA
E TEMPLATES.</a>
</h3>
<p>
	Modificação do programa de listas ligadas de 2.1.4 para suportar
templates. Esta versão é usada em muitos outros exemplos do
tutorial.</p><p>
<code></code></p><p><code>
<b></b></code></p><hr><p><code>
#ifndef MLISTH_H</code></p><p><code>
#define MLISTH_H</code></p><p><code>
#include &lt;stdlib.h&gt;</code></p><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
//Criacao de uma hierarquia de listas ligadas.</code></p><p><code>
//O elemento da lista e' um inteiro</code></p><p><code>
enum Boolean{FALSE,TRUE};</code></p><p><code>
</code></p><p><code>
template &lt;class T&gt;class no{ //este e' o no da lista ligada, so e' usado
por ela</code></p><p><code>
private:</code></p><p><code>
 T info; //informacao</code></p><p><code>
 no* prox; //ponteiro para o proximo</code></p><p><code>
public:</code></p><p><code>
 no();</code></p><p><code>
 no(T i,no* p);</code></p><p><code>
 no* get_prox(void);</code></p><p><code>
 void set_prox(no* p);</code></p><p><code>
 T get_info(void);</code></p><p><code>
 void set_info(T a);</code></p><p><code>
 no* dobra(void);</code></p><p><code>
 ~no(void);</code></p><p><code>
} ;</code></p><p><code>
</code></p><p><code>
template &lt;class T&gt;class lista{ //esta e' a lista ligada comum.</code></p><p><code>
protected: //"visivel hierarquia abaixo"</code></p><p><code>
	no&lt;T&gt;* primeiro; //primeiro no da lista, aqui eu insiro e removo.</code></p><p><code>
public:</code></p><p><code>
lista(void);</code></p><p><code>
lista(const lista&lt;T&gt;&amp; lc); //copy constructor.</code></p><p><code>
Boolean vazia(void)const;</code></p><p><code>
Boolean contem(T el)const;</code></p><p><code>
void insere_primeiro(T elem);</code></p><p><code>
T* remove_primeiro();</code></p><p><code>
void mostra()const;</code></p><p><code>
~lista(void);</code></p><p><code>
}; //fim classe lista</code></p><p><code>
</code></p><p><code>
template &lt;class T&gt;class listaultimo:public lista&lt;T&gt; { //essa e a
lista util para</code></p><p><code>
//implementar pilhas e filas.</code></p><p><code>
protected: //protected e uma opcao outra e' get_ultimo() e set_...</code></p><p><code>
  no&lt;T&gt;* ultimo;</code></p><p><code>
public:</code></p><p><code>
listaultimo(void);</code></p><p><code>
listaultimo(const listaultimo&lt;T&gt;&amp; lc); //redefinicao</code></p><p><code>
void insere_ultimo(T elem); //nova</code></p><p><code>
void insere_primeiro(T elem); //redefinicao</code></p><p><code>
T* remove_primeiro();//redefinicao</code></p><p><code>
~listaultimo(void);</code></p><p><code>
//as operacoes nao redefinidas sao validas.</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
template &lt;class T&gt;class listaordenada:public lista&lt;T&gt; {</code></p><p><code>
//essa e' a lista comum com aprimoramentos.</code></p><p><code>
public:</code></p><p><code>
listaordenada(void);</code></p><p><code>
//nao definimos copy constructor</code></p><p><code>
Boolean contem(T el)const;</code></p><p><code>
void insere_primeiro(T elem); //insere em ordem</code></p><p><code>
T* remove_elemento(T el);</code></p><p><code>
~listaordenada(void);</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt;no&lt;T&gt;::no()</code></p><p><code>
{prox=NULL;cout &lt;&lt; "Hi";}</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt;no&lt;T&gt;::no(T i,no* p)</code></p><p><code>
{info=i;prox=p;cout &lt;&lt; "Hi";}</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt; no&lt;T&gt;* no&lt;T&gt;::get_prox(void)</code></p><p><code>
{return prox;}</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt; void no&lt;T&gt;::set_prox(no* p)</code></p><p><code>
{prox=p;}</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt; T no&lt;T&gt;::get_info(void) {return info;}</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt; void no&lt;T&gt;::set_info(T i)</code></p><p><code>
{info=i;}</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt; no&lt;T&gt;* no&lt;T&gt;::dobra(void)</code></p><p><code>
{</code></p><p><code>
if (get_prox()==NULL) return new no&lt;T&gt;(get_info(),NULL);</code></p><p><code>
else return new no&lt;T&gt;(get_info(),this-&gt;get_prox()-&gt;dobra());</code></p><p><code>
//recursividade para duplicacao da lista</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt; no&lt;T&gt;::~no(void)</code></p><p><code>
{cout &lt;&lt; "bye";}  //bye e so para debugar, retire depois de compilado.</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt; lista&lt;T&gt;::lista(void):primeiro(NULL)</code></p><p><code>
{}  //bloco de codigo vazio</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt; lista&lt;T&gt;::lista(const lista&lt;T&gt;&amp; lc)</code></p><p><code>
{ primeiro=lc.primeiro-&gt;dobra(); }</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt; Boolean lista&lt;T&gt;::vazia(void)const</code></p><p><code>
{ return Boolean(primeiro==NULL); }</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt; Boolean lista&lt;T&gt;::contem(T el) const//mais rapido
que iterador</code></p><p><code>
{</code></p><p><code>
 no&lt;T&gt;* curr;</code></p><p><code>
 curr=primeiro;</code></p><p><code>
 while ((curr!=NULL) &amp;&amp; (curr-&gt;get_info()!=el))</code></p><p><code>
 {</code></p><p><code>
  curr=curr-&gt;get_prox();</code></p><p><code>
 };</code></p><p><code>
  return Boolean(curr-&gt;get_info()==el);</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt; void lista&lt;T&gt;::insere_primeiro(T elem)</code></p><p><code>
{</code></p><p><code>
no&lt;T&gt;* insirame;</code></p><p><code>
 if (primeiro==NULL) //lista vazia</code></p><p><code>
	 primeiro=new no&lt;T&gt;(elem,NULL);</code></p><p><code>
 else {</code></p><p><code>
		 insirame=new no&lt;T&gt;(elem,primeiro);</code></p><p><code>
		 primeiro=insirame;</code></p><p><code>
		};</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt; T* lista&lt;T&gt;::remove_primeiro(void)</code></p><p><code>
 {</code></p><p><code>
 T* devolvame; //return</code></p><p><code>
 no&lt;T&gt;* temp;     //to delete</code></p><p><code>
 if (primeiro==NULL)  return NULL; //lista vazia</code></p><p><code>
 else {</code></p><p><code>
		 (*devolvame)=primeiro-&gt;get_info();</code></p><p><code>
		 temp=primeiro;</code></p><p><code>
		 primeiro=primeiro-&gt;get_prox();</code></p><p><code>
		 delete temp;</code></p><p><code>
		 return devolvame;</code></p><p><code>
		};</code></p><p><code>
 };</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt;void lista&lt;T&gt;::mostra() const</code></p><p><code>
{</code></p><p><code>
no&lt;T&gt;* curr;</code></p><p><code>
cout &lt;&lt; "=";</code></p><p><code>
curr=primeiro;</code></p><p><code>
while (curr!=NULL)</code></p><p><code>
 {</code></p><p><code>
  cout &lt;&lt;"("&lt;&lt;curr-&gt;get_info()&lt;&lt;")"&lt;&lt;"-";</code></p><p><code>
  curr=curr-&gt;get_prox();</code></p><p><code>
 };</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt;lista&lt;T&gt;::~lista(void)</code></p><p><code>
{</code></p><p><code>
 no&lt;T&gt;* temp;</code></p><p><code>
  while (primeiro!=NULL)</code></p><p><code>
  {</code></p><p><code>
  temp=primeiro;</code></p><p><code>
  primeiro=primeiro-&gt;get_prox();</code></p><p><code>
  delete temp;</code></p><p><code>
  };</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
template&lt;class
T&gt;listaordenada&lt;T&gt;::listaordenada(void):lista&lt;T&gt;()</code></p><p><code>
{};</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt; Boolean listaordenada&lt;T&gt;::contem(T el)const</code></p><p><code>
{</code></p><p><code>
no&lt;T&gt;* curr;</code></p><p><code>
Boolean conti=TRUE;</code></p><p><code>
 curr=primeiro;</code></p><p><code>
 while ((curr!=NULL) &amp;&amp; conti)</code></p><p><code>
 {</code></p><p><code>
  if (curr-&gt;get_info()&lt;el)</code></p><p><code>
  curr=curr-&gt;get_prox();</code></p><p><code>
  else conti=FALSE;</code></p><p><code>
 };</code></p><p><code>
 if (curr==NULL) return FALSE;</code></p><p><code>
 else return Boolean(curr-&gt;get_info()==el);</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt;void listaordenada&lt;T&gt;::insere_primeiro(T elem)</code></p><p><code>
{</code></p><p><code>
no&lt;T&gt;* curr=primeiro;</code></p><p><code>
no&lt;T&gt;* prev=NULL;</code></p><p><code>
no&lt;T&gt;* insirame;</code></p><p><code>
Boolean conti=TRUE;</code></p><p><code>
 while ((curr!=NULL) &amp;&amp; conti)</code></p><p><code>
 {</code></p><p><code>
  if (curr-&gt;get_info()&lt;elem)</code></p><p><code>
  {prev=curr; curr=curr-&gt;get_prox();}</code></p><p><code>
  else conti=FALSE;</code></p><p><code>
 };</code></p><p><code>
 insirame=new no&lt;T&gt;(elem,curr);</code></p><p><code>
 if (prev==NULL) primeiro=insirame;</code></p><p><code>
  else prev-&gt;set_prox(insirame);</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt; T* listaordenada&lt;T&gt;::remove_elemento(T el)</code></p><p><code>
{</code></p><p><code>
T* devolvame;</code></p><p><code>
no&lt;T&gt;* curr=primeiro;</code></p><p><code>
no&lt;T&gt;* prev=NULL;</code></p><p><code>
no&lt;T&gt;* deleteme;</code></p><p><code>
Boolean conti=TRUE;</code></p><p><code>
 while ((curr!=NULL) &amp;&amp; conti) //acha lugar onde pode estar el</code></p><p><code>
 {</code></p><p><code>
  if (curr-&gt;get_info()&lt;el)</code></p><p><code>
  {prev=curr; curr=curr-&gt;get_prox();} //anda</code></p><p><code>
  else conti=FALSE;</code></p><p><code>
 };</code></p><p><code>
 if (curr==NULL) return FALSE; //fim de lista ou vazia</code></p><p><code>
 else //pode ser o elemento ou ele nao existe</code></p><p><code>
  {</code></p><p><code>
	 if (curr-&gt;get_info()==el)</code></p><p><code>
	  {</code></p><p><code>
		deleteme=curr;</code></p><p><code>
		if (prev==NULL) //lista so com um elemento ou primeiro el</code></p><p><code>
		  primeiro=curr-&gt;get_prox();</code></p><p><code>
		else</code></p><p><code>
		 {</code></p><p><code>
		  prev-&gt;set_prox(curr-&gt;get_prox());</code></p><p><code>
		 }</code></p><p><code>
		cout &lt;&lt; deleteme-&gt;get_info()&lt;&lt;endl; //so para verificar</code></p><p><code>
		(*devolvame)=delete-&gt;get_info();</code></p><p><code>
		delete deleteme;</code></p><p><code>
		return devolvame;</code></p><p><code>
	  }</code></p><p><code>
	 else return NULL;</code></p><p><code>
  }</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt;listaordenada&lt;T&gt;::~listaordenada(void)</code></p><p><code>
{cout &lt;&lt; "Lista destruida.";};</code></p><p><code>
</code></p><p><code>
template&lt;class
T&gt;listaultimo&lt;T&gt;::listaultimo(void):lista&lt;T&gt;()</code></p><p><code>
{</code></p><p><code>
ultimo=NULL;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt;listaultimo&lt;T&gt;::listaultimo(const
listaultimo&lt;T&gt;&amp; lc)</code></p><p><code>
{</code></p><p><code>
no&lt;T&gt;* curr;</code></p><p><code>
 primeiro=ultimo=NULL; //inicializa lista</code></p><p><code>
 if (!lc.vazia())</code></p><p><code>
  {</code></p><p><code>
	curr=lc.primeiro;</code></p><p><code>
	while (curr!=NULL)</code></p><p><code>
	{</code></p><p><code>
	 insere_ultimo(curr-&gt;get_info());</code></p><p><code>
	 curr=curr-&gt;get_prox();</code></p><p><code>
	}</code></p><p><code>
  }</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt;void listaultimo&lt;T&gt;::insere_ultimo(T elem)</code></p><p><code>
{</code></p><p><code>
no&lt;T&gt;* insirame;</code></p><p><code>
insirame=new no&lt;T&gt;(elem,NULL);</code></p><p><code>
if (ultimo==NULL) ultimo=insirame; //lista vazia</code></p><p><code>
else {</code></p><p><code>
		ultimo-&gt;set_prox(insirame);</code></p><p><code>
		ultimo=insirame;</code></p><p><code>
		};</code></p><p><code>
if (primeiro==NULL) primeiro=ultimo; //lista vazia</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt; void listaultimo&lt;T&gt;::insere_primeiro(T elem)
//redefinicao</code></p><p><code>
{</code></p><p><code>
no&lt;T&gt;* insirame;</code></p><p><code>
 if (primeiro==NULL) //lista vazia</code></p><p><code>
	{</code></p><p><code>
	 primeiro=new no&lt;T&gt;(elem,ultimo);</code></p><p><code>
	 ultimo=primeiro;</code></p><p><code>
	}//lista vazia</code></p><p><code>
 else {</code></p><p><code>
		 insirame=new no&lt;T&gt;(elem,primeiro);</code></p><p><code>
		 primeiro=insirame;</code></p><p><code>
		};</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt; T*
listaultimo&lt;T&gt;::remove_primeiro()//redefinicao</code></p><p><code>
{</code></p><p><code>
T* devolvame; //return</code></p><p><code>
 no&lt;T&gt;* temp;     //to delete</code></p><p><code>
 if (primeiro==NULL)  return 0; //lista vazia</code></p><p><code>
 else {</code></p><p><code>
		 (*devolvame)=primeiro-&gt;get_info();</code></p><p><code>
		 temp=primeiro;</code></p><p><code>
		 primeiro=primeiro-&gt;get_prox();</code></p><p><code>
		 delete temp;</code></p><p><code>
		 if (primeiro==NULL) ultimo=NULL; //volta lista vazia</code></p><p><code>
		 return devolvame;</code></p><p><code>
		};</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt;listaultimo&lt;T&gt;::~listaultimo(void)</code></p><p><code>
{</code></p><p><code>
 no&lt;T&gt;* temp;</code></p><p><code>
  while (primeiro!=NULL)</code></p><p><code>
  {</code></p><p><code>
  temp=primeiro;</code></p><p><code>
  primeiro=primeiro-&gt;get_prox();</code></p><p><code>
  delete temp;</code></p><p><code>
  };</code></p><p><code>
  delete ultimo;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
#endif</code></p><p><code>
</code></p><p><code>
<b></b></code></p><hr><p><code>
</code></p><p><code>
#include "mlistht.h"</code></p><p><code>
main()</code></p><p><code>
{</code></p><p><code>
listaultimo&lt;int&gt; minha;</code></p><p><code>
listaultimo&lt;int&gt;* copia;</code></p><p><code>
char option; //use in menu as option variable</code></p><p><code>
char cpyopt; //copy option para copia</code></p><p><code>
int el; //elemento a inserir</code></p><p><code>
do {</code></p><p><code>
 cout &lt;&lt;"\n";   //menu options display</code></p><p><code>
 cout &lt;&lt;"P:Insere no primeiro.\n";</code></p><p><code>
 cout &lt;&lt;"R:Remove no primeiro.\n";</code></p><p><code>
 cout &lt;&lt;"U:Insere no ultimo.\n";</code></p><p><code>
 cout &lt;&lt;"E:Existe elemento?\n";</code></p><p><code>
 cout &lt;&lt;"V:Vazia?\n";</code></p><p><code>
 cout &lt;&lt;"M:Mostra lista.\n";</code></p><p><code>
 cout &lt;&lt;"C:Copia lista e mostra.\n";</code></p><p><code>
 cout &lt;&lt;"Q:Quit teste lista.\n";</code></p><p><code>
 cout &lt;&lt;"Entre comando:";</code></p><p><code>
 cin &gt;&gt; option; //reads user option</code></p><p><code>
 switch(option) //executes user option</code></p><p><code>
 {</code></p><p><code>
  case 'P':</code></p><p><code>
  case 'p':</code></p><p><code>
				cout &lt;&lt; "Entre elemento:";</code></p><p><code>
				cin &gt;&gt;el;</code></p><p><code>
				minha.insere_primeiro(el);</code></p><p><code>
				break;</code></p><p><code>
  case 'R':</code></p><p><code>
  case 'r':</code></p><p><code>
				if (!minha.vazia())</code></p><p><code>
				cout &lt;&lt; (*minha.remove_primeiro())&lt;&lt;endl;</code></p><p><code>
				else cout &lt;&lt; "NULL, Lista vazia." &lt;&lt;endl;</code></p><p><code>
				break;</code></p><p><code>
  case 'U':</code></p><p><code>
  case 'u':</code></p><p><code>
				cout &lt;&lt; "Entre elemento:";</code></p><p><code>
				cin &gt;&gt; el;</code></p><p><code>
				minha.insere_ultimo(el);</code></p><p><code>
				break;</code></p><p><code>
  case 'M':</code></p><p><code>
  case 'm': minha.mostra();</code></p><p><code>
				break;</code></p><p><code>
  case 'E':</code></p><p><code>
  case 'e':</code></p><p><code>
				cout &lt;&lt; "Entre elemento:";</code></p><p><code>
				cin &gt;&gt;el;</code></p><p><code>
				cout &lt;&lt; minha.contem(el);</code></p><p><code>
				break;</code></p><p><code>
  case 'V':</code></p><p><code>
  case 'v':</code></p><p><code>
				cout &lt;&lt; minha.vazia();</code></p><p><code>
				break;</code></p><p><code>
  case 'C':</code></p><p><code>
  case 'c':</code></p><p><code>
				copia=new listaultimo&lt;int&gt;(minha);</code></p><p><code>
				copia-&gt;mostra();</code></p><p><code>
				cout &lt;&lt; "Agora trabalhando na lista copia." &lt;&lt; endl;</code></p><p><code>
				do {</code></p><p><code>
				 cout &lt;&lt;"\n";   //menu options display</code></p><p><code>
				 cout &lt;&lt;"P:Insere no primeiro.\n";</code></p><p><code>
				 cout &lt;&lt;"R:Remove no primeiro.\n";</code></p><p><code>
				 cout &lt;&lt;"U:Insere no ultimo.\n";</code></p><p><code>
				 cout &lt;&lt;"E:Existe elemento?\n";</code></p><p><code>
				 cout &lt;&lt;"V:Vazia?\n";</code></p><p><code>
				 cout &lt;&lt;"M:Mostra lista.\n";</code></p><p><code>
				 cout &lt;&lt;"Q:Quit teste lista copia?Volta lista anterior?.\n";</code></p><p><code>
				 cout &lt;&lt;"Entre comando:";</code></p><p><code>
				 cin &gt;&gt; cpyopt; //reads user option</code></p><p><code>
				 switch(cpyopt) //executes user option</code></p><p><code>
				 {</code></p><p><code>
				  case 'P':</code></p><p><code>
				  case 'p':</code></p><p><code>
							cout &lt;&lt; "Entre elemento:";</code></p><p><code>
							cin &gt;&gt;el;</code></p><p><code>
							copia-&gt;insere_primeiro(el);</code></p><p><code>
					break;</code></p><p><code>
				  case 'R':</code></p><p><code>
				  case 'r':</code></p><p><code>
							if (!copia-&gt;vazia())</code></p><p><code>
							cout &lt;&lt; (*copia-&gt;remove_primeiro())&lt;&lt;endl;</code></p><p><code>
							else cout &lt;&lt; "NULL, Lista vazia." &lt;&lt;endl;</code></p><p><code>
					break;</code></p><p><code>
				  case 'U':</code></p><p><code>
				  case 'u':</code></p><p><code>
							cout &lt;&lt; "Entre elemento:";</code></p><p><code>
							cin &gt;&gt;el;</code></p><p><code>
							copia-&gt;insere_ultimo(el);</code></p><p><code>
					break;</code></p><p><code>
				  case 'M':</code></p><p><code>
				  case 'm':</code></p><p><code>
						copia-&gt;mostra();</code></p><p><code>
					break;</code></p><p><code>
				  case 'E':</code></p><p><code>
				  case 'e':</code></p><p><code>
							cout &lt;&lt; "Entre elemento:";</code></p><p><code>
							cin &gt;&gt;el;</code></p><p><code>
							cout &lt;&lt; copia-&gt;contem(el);</code></p><p><code>
					break;</code></p><p><code>
				case 'V':</code></p><p><code>
				case 'v':</code></p><p><code>
							cout &lt;&lt; copia-&gt;vazia();</code></p><p><code>
					break;</code></p><p><code>
				case 'Q':</code></p><p><code>
				case 'q':</code></p><p><code>
							delete copia;</code></p><p><code>
					break;</code></p><p><code>
			  default:  ;</code></p><p><code>
			  }  //switch-case code block</code></p><p><code>
				} while ((cpyopt!='Q') &amp;&amp; (cpyopt!='q'));</code></p><p><code>
				break;</code></p><p><code>
  default:  ;</code></p><p><code>
 }  //switch-case code block</code></p><p><code>
} while ((option!='Q') &amp;&amp; (option!='q'));  //menu loop code block</code></p><p><code>
</code></p><p><code>
return 0;</code></p><p><code>
}  //main code block</code></p><p><code>
</code></p><p>
<b></b></p><hr><p>
</p><p>
<b>Exercícios:</b></p><p>
<b></b>1)Compare esta lista com <code> "templates" </code> com
outras listas implementadas sem tipos paramétricos. Que vantagens
você pode apontar a nível de independência entre as partes
de um programa? Porque é importante maximizar esta independência
entre as partes de um programa? Outro exercício: Modifique o programa
<code>lista&lt;T&gt;</code> para trabalhar com
ponteiros<code> &lt;T*&gt;</code><b> </b>evitando a copia de
objetos grandes visando assim  maior eficiência.</p><p>
<b></b>
</p><h3>
<a name="RTFToC67">4.3.4.
</a><a name="_Toc342737006"></a><a name="_Toc345409442"></a><a name="_Toc345810947"></a><a name="_Toc345838277"></a><a name="_Toc345942412"></a><a name="_Toc345949572"></a><a name="_Toc346168689"></a><a name="_Toc348417132"></a><a name="_Toc348931388"></a><a name="_Toc353900827"></a><a name="_Toc353946357">
TEMPLATES E AGREGAÇÃO</a>
</h3>
<p>
<b>	</b>Usando o template definido no exemplo dois criaremos uma classe pilha e
a testaremos de modo análogo ao que foi feito em 2.2 só que agora
com templates e com uma pilha e não fila.</p><p>
<code>mlisth.h</code> não será copiada, é
idêntica a do exemplo anterior de "templates".</p><p>
<code></code></p><p><code>
<b></b></code></p><hr><p><code>
</code></p><p><code>
#include "mlistht.h"</code></p><p><code>
template&lt;class T&gt;class pilha { //agregacao de uma lista</code></p><p><code>
private:</code></p><p><code>
 lista&lt;T&gt; al;  //a lista</code></p><p><code>
public:</code></p><p><code>
 pilha();</code></p><p><code>
 Boolean vazia();</code></p><p><code>
 Boolean contem(T el);</code></p><p><code>
 void insere(T el);</code></p><p><code>
 T* remove();</code></p><p><code>
 void mostra();</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt; pilha&lt;T&gt;::pilha(){};</code></p><p><code>
template&lt;class T&gt; Boolean pilha&lt;T&gt;::vazia()</code></p><p><code>
	{return al.vazia();}</code></p><p><code>
template&lt;class T&gt; Boolean pilha&lt;T&gt;::contem(T el)</code></p><p><code>
	{return al.contem(el);}</code></p><p><code>
template&lt;class T&gt; void pilha&lt;T&gt;::insere(T el)</code></p><p><code>
	{al.insere_primeiro(el);}</code></p><p><code>
template&lt;class T&gt; T* pilha&lt;T&gt;::remove()</code></p><p><code>
	{return al.remove_primeiro();}</code></p><p><code>
template&lt;class T&gt; void pilha&lt;T&gt;::mostra()</code></p><p><code>
	{al.mostra();}</code></p><p><code>
</code></p><p><code>
<b></b></code></p><p><code>
<b></b></code></p><hr><p><code>
<b></b></code></p><p><code>
<b></b>#include "mpilhat.h"</code></p><p><code>
main()</code></p><p><code>
{</code></p><p><code>
pilha&lt;int&gt; minha;</code></p><p><code>
char option; //use in menu as option variable</code></p><p><code>
int el; //elemento a inserir</code></p><p><code>
do {</code></p><p><code>
 cout &lt;&lt;"\n";   //menu options display</code></p><p><code>
 cout &lt;&lt;"I:Insere.\n";</code></p><p><code>
 cout &lt;&lt;"R:Remove.\n";</code></p><p><code>
 cout &lt;&lt;"M:Mostra pilha.\n";</code></p><p><code>
 cout &lt;&lt;"Q:Quit pilha test.\n";</code></p><p><code>
 cout &lt;&lt;"V:Vazia?\n";</code></p><p><code>
 cout &lt;&lt;"C:Contem?\n";</code></p><p><code>
 cout &lt;&lt;"Entre comando:";</code></p><p><code>
 cin &gt;&gt; option; //reads user option</code></p><p><code>
 switch(option) //executes user option</code></p><p><code>
 {</code></p><p><code>
  case 'I':</code></p><p><code>
  case 'i':</code></p><p><code>
				cout &lt;&lt; "Entre elemento:";</code></p><p><code>
				cin &gt;&gt;el;</code></p><p><code>
				minha.insere(el);</code></p><p><code>
				break;</code></p><p><code>
  case 'R':</code></p><p><code>
  case 'r':</code></p><p><code>
				if (!minha.vazia())</code></p><p><code>
				cout &lt;&lt; (*(minha.remove()))&lt;&lt;endl;</code></p><p><code>
				else cout &lt;&lt; "NULL, pilha vazia." &lt;&lt;endl;</code></p><p><code>
				break;</code></p><p><code>
  case 'C':</code></p><p><code>
  case 'c':</code></p><p><code>
				cout &lt;&lt; "Entre elemento:";</code></p><p><code>
				cin &gt;&gt;el;</code></p><p><code>
				cout &lt;&lt; minha.contem(el);</code></p><p><code>
				break;</code></p><p><code>
  case 'M':</code></p><p><code>
  case 'm':</code></p><p><code>
				minha.mostra();</code></p><p><code>
				break;</code></p><p><code>
  case 'V':</code></p><p><code>
  case 'v':</code></p><p><code>
				cout &lt;&lt; "Resultado:" &lt;&lt; minha.vazia() &lt;&lt;endl;</code></p><p><code>
				break;</code></p><p><code>
  default:  ;</code></p><p><code>
 }  //switch-case code block</code></p><p><code>
} while ((option!='Q') &amp;&amp; (option!='q'));  //menu loop code block</code></p><p><code>
</code></p><p><code>
return 0;</code></p><p><code>
}  //main code block</code></p><p><code>
<b></b></code></p><hr><p><code>
</code></p><p>
<b></b></p><p>
<b>Exercícios:</b></p><p>
<b></b>1)Defina outras classes apresentadas em termos de templates, por exemplo
a classe conta . Suponha que você tem que fazer um programa que usa a
classe conta, mas não sabe ao certo se vai usar o tipo<code>
float</code> para representar o dinheiro ou vai usar algum outro tipo
<code> (double) </code>. Use templates e defina este tipo somente
quanto as operações.<b>
<a name="_Toc342737007"></a><a name="_Toc345409443"></a><a name="_Toc345810948"></a><a name="_Toc345838278"></a><a name="_Toc345942413"></a><a name="_Toc345949573"></a><a name="_Toc346168690"></a><a name="_Toc348417133"></a><a name="_Toc348931389"></a><a name="_Toc353900828"></a><a name="_Toc353946358"></a></b><a name="_Toc353946358">
</a></p><h2><a name="_Toc353946358">
</a><a name="RTFToC68">4.4.
METACLASSES</a> 
</h2>
<p>
	Metaclasses armazenam informações sobre classes definidas pelo
usuário e são comuns em algumas linguagens de
programação orientadas a objetos. Essa informação
armazenada é a chamada metainformação.</p><p>
<b>	</b>C++ não possui metaclasses, porém existem meios de
armazenar alguma metainformação, um deles é o uso de
variáveis do tipo static que guardam informações sobre os
vários objetos de uma mesma classe.</p><p>
	A utilidade da metainformação é vasta. Por exemplo um
arquivo que armazena uma imagem contém geralmente um cabeçalho
sobre a imagem (número de "pixels", largura, altura, etc). Numa classe
lista, pode ser considerado como meta-informação: o número
de elementos, o estado: ordenado ou não, etc. Em bancos de dados
é muito comum se armazenar meta-informação nos arquivos.</p><p>
<b>
<a name="_Toc342737008"></a><a name="_Toc345409444"></a><a name="_Toc345810949"></a><a name="_Toc345838279"></a><a name="_Toc345942414"></a><a name="_Toc345949574"></a><a name="_Toc346168691"></a><a name="_Toc348417134"></a><a name="_Toc348931390"></a><a name="_Toc353900829"></a><a name="_Toc353946359"></a></b><a name="_Toc353946359">
</a></p><h3><a name="_Toc353946359">
</a><a name="RTFToC69">4.4.1.
UM TIPO SIMPLES COMO STATIC</a>	
</h3>
	<p>
	Quando se declara um atributo <code>static</code> em uma classe,
todos os objetos instanciados tem uma referência para ele (o mesmo
atributo), ou seja ele pode ser modificado ou lido  por funções
membro de todos os objetos desta classe. No exemplo a seguir declaramos um
atributo <code>static</code> inteiro que é incrementado
quando o objeto é criado (construtor) e decrementado quando o objeto
é destruído. Esse atributo static pode ser de qualquer tipo, pode
ser até um objeto.</p><p>
	Variáveis static servem para fazer estatísticas sobre uma
classe, também são  adequadas para tornar
informações de um objeto disponíveis para outros da mesma
classe, elas continuam existindo (conservam seu valor) mesmo que não
haja nenhum objeto instanciado e não destruído (vivo).</p><p>
	O programa abaixo mostra como fazê-lo, <code>alive
</code>representa o número de objetos da classe robot criados.
Veja que a declaração de alive segue a palavra static.</p><p>
</p><p>
</p><center>
<img src="TUTORIAL_unicamp_c++_files/robostat.html">
</center>
Diagrama do atributo static alive, compartilhado por vários
robôs:<p>
</p><p>
<code></code></p><p><code>
<b></b></code></p><hr><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
</code></p><p><code>
class robo {</code></p><p><code>
private:</code></p><p><code>
	float x,y;</code></p><p><code>
	static int vivos;  //guarda numero de robos vivos.</code></p><p><code>
public:</code></p><p><code>
	robo(float x,float y) {vivos++;} //cria robo</code></p><p><code>
	void move(float dx,float dy) {x+=dx;y+=dy;}</code></p><p><code>
	static int get_vivos(void) {return vivos;} //quantos vivos</code></p><p><code>
	~robo(void) {vivos--;} //mata robo</code></p><p><code>
	};</code></p><p><code>
</code></p><p><code>
int robo::vivos=0; //inicializacao da variavel static.</code></p><p><code>
</code></p><p><code>
main()</code></p><p><code>
{</code></p><p><code>
cout &lt;&lt; robo::get_vivos() &lt;&lt; endl;</code></p><p><code>
robo *r1=new robo(1.3,1.4); //cria robo 1</code></p><p><code>
robo *r2;</code></p><p><code>
cout &lt;&lt; r1-&gt;get_vivos() &lt;&lt; "\n" ; //1 vivo</code></p><p><code>
r2=new robo(0.0,0.0);  //cri robo 2</code></p><p><code>
cout &lt;&lt; r1-&gt;get_vivos() &lt;&lt; "\n" ; //2 vivos</code></p><p><code>
delete r1; //kill robo 1</code></p><p><code>
cout &lt;&lt; robo::get_vivos() &lt;&lt; "\n" ; //1 vivo</code></p><p><code>
r2-&gt;move(12.4,23.2); //movendo robo certa distancia.</code></p><p><code>
delete r2; //mata robo 2.</code></p><p><code>
//nenhum robo vivo</code></p><p><code>
cout &lt;&lt; robo::get_vivos() &lt;&lt; endl;</code></p><p><code>
return 0;</code></p><p><code>
}</code></p><p><code>
<b></b></code></p><hr><p><code>
</code></p><p>
<b>Resultado do programa:</b></p><p>
<b></b>0</p><p>
1</p><p>
2</p><p>
1</p><p>
0</p><p>
</p><p>
<b>Comentários:</b> </p><p>
	Observe o trecho de código: <code> int robot::alive=0;
</code> perceba que você deve inicializar o atributo antes da
criação de qualquer objeto. Esse tipo de acesso não
é permitido em<code> main(),</code> mantendo assim o
encapsulamento. Quando os objetos são criados eles incrementam
<code>alive</code> através de seus construtores, e
decrementam quando são destruídos.</p><p>
	Existe uma função membro declarada como static: <code>
static int get_vivos(void) {return vivos;} </code>  esta
função membro tem um tipo de acesso diferente dos outros , o
seguinte trecho de código usado em nosso programa é permitido:
<code> cout &lt;&lt; robo::get_vivos() &lt;&lt; endl;.
</code>Perceba que <code>get_vivos</code> é chamado
sem o operador . ou<code> -&gt;</code>, isto é permitido
porque <code>get_vivos</code> é um função
membro<code> static</code>, opera portanto sobre variáveis
<code>static</code> que podem existir antes da
criação do primeiro objeto da classe ou quando nenhum objeto
está ativo.</p><p>
</p><p>
<b>Exercícios:</b></p><p>
<b></b>1) No lugar da variável inteira declarada como static faca a
seguinte declaração: <code>static armazenagem vivos;
//guarda numero de robos vivos.. </code></p><p>
Inicialize também o objeto<code> static</code> chamando seu
construtor fora de main.</p><p>
Uma possível definição para a classe armazenagem seria:</p><p>
<code>class armazenagem {</code></p><p><code>
private:</code></p><p><code>
	int numero;</code></p><p><code>
public:</code></p><p><code>
	armazenagem() {numero=0;}</code></p><p><code>
	void armazenagempp() {numero++;}</code></p><p><code>
	void armazenagemmm() {numero--;}</code></p><p><code>
	int get_numero() {return numero;}</code></p><p><code>
};</code></p><p><code>
</code></p><p>
Não se esqueça de chamar os função membros de
armazenagem nos construtores dos robos.</p><p>
</p><p>
2)Use variáveis static em seus programas para que fazem
alocação dinâmica para controlar o número de objetos
criados e não deletados. Use por exemplo o objeto lista de 2.1.4 e
verifique a importância desta técnica para o desenvolvimento de
programas que sejam corretos no uso da memória dinâmica (heap),
principalmente em C++ que não fornece coleta automática de lixo.
</p><p>
	Usar técnicas deste tipo em Módula-3 é impossível
porque a linguagem não suporta construtores e destrutores, porém
a coleta automática de lixo, "Garbage Collection" , já faz grande
parte do trabalho para o programador. Em C++ existem técnicas
avançadas  de programação para conseguir coleta
automática de lixo para alguns tipos, essas técnicas se baseiam
na chamada de automática  de um destrutor quando um objeto sai de
escopo, e também no uso de "templates".</p><p>
</p><p>
3) Existe uma linguagem de programação chamada Logo que é
muito usada no Brasil em escolas de primeiro e segundo grau. Nesta linguagem
você pode programar os movimentos na tela de uma tartaruginha ou cursor.
Este cursor descreve movimentos riscando ou não a tela, dentre os
movimentos descritos estão círculos, quadrados e sequências
repetitivas (loops). Modifique seu objeto robo para apresentar alguns desses
recursos. Crie então um programa que lê de um arquivo texto
instruções para este objeto robo executar movimentos na tela.</p><p>
	Logo foi criada por um cientista de computação do MIT.</p><p>
<a name="_Toc342737009"></a><a name="_Toc345409445"></a><a name="_Toc345810950"></a><a name="_Toc345838280"></a><a name="_Toc345942415"></a><a name="_Toc345949575"></a><a name="_Toc346168692"></a><a name="_Toc348417135"></a><a name="_Toc348931391"></a><a name="_Toc353900830"></a><a name="_Toc353946360">
</a></p><h3><a name="_Toc353946360">
</a><a name="RTFToC70">4.4.2.
UM TIPO DEFINIDO PELO USUÁRIO USADO COMO
STATIC</a>
</h3>
<b></b><p>
<b>	</b>Trechos de um programa com um objeto<code> static
</code>representando uma lista parametrizada (templates). A estrutura
poderia  ser  parametrizada de modo a armazenar informações sobre
os estados dos demais objetos, permitindo que eles realizem algum tipo de
interação. Neste exemplo vamos só armazenar os
módulos das distância que os robos se moveram
(função membro <code>move()</code>)<b></b></p><p>
<b>	</b>Faça a inclusão do arquivo que define sua estrutura de
armazenamento, "storage", no seu projeto:</p><p>
</p><p>
<code>#include "mlistht.h"</code><b></b></p><p>
<b></b></p><p>
<b></b>Crie o atributo <code>static</code> com o encapsulamento
desejado na definição da classe <code>robo</code>. Se
preciso indique o tipo parametrizado:</p><p>
<code><b></b></code></p><p><code>
<b></b>class faca_estatisticas_sobre_mim {</code></p><p><code>
private:</code></p><p><code>
	static lista&lt;float&gt; registro;  //storage class</code></p><p><code>
public: ...</code></p><p><code>
</code><b></b></p><p>
<b></b>Acesse o atributo<code> static</code> aonde seu
encapsulamento permite através de chamadas de funções
membro como: <code></code></p><p><code>
registro.insere_ultimo(a);<b></b></code></p><p><code>
<b></b></code><b></b></p><p>
<b></b>Tente fazer este exemplo sozinho, depois confira com o programa a
seguir: <code></code></p><p><code>
<b></b></code></p><hr><p><code>
<b></b>#include &lt;iostream.h&gt;</code></p><p><code>
#include &lt;math.h&gt;</code></p><p><code>
#include "mlistht.h"</code></p><p><code>
</code></p><p><code>
class robot {</code></p><p><code>
private:</code></p><p><code>
	float x,y; //posicoes</code></p><p><code>
	static lista&lt;float&gt; deltas;//guarda os passos dados</code></p><p><code>
public:</code></p><p><code>
	robot(float a,float b)</code></p><p><code>
	{</code></p><p><code>
	x=a;</code></p><p><code>
	y=b;</code></p><p><code>
	} //cria robo</code></p><p><code>
	void move(float dx,float dy)</code></p><p><code>
	{</code></p><p><code>
	 x+=dx;</code></p><p><code>
	 y+=dy;</code></p><p><code>
	 deltas.insere_primeiro(sqrt(x*x+y*y));</code></p><p><code>
	}</code></p><p><code>
	static void mostra_lista(void)</code></p><p><code>
	{</code></p><p><code>
	deltas.mostra();</code></p><p><code>
	cout &lt;&lt; endl;</code></p><p><code>
	}</code></p><p><code>
	~robot(void) {} //mata robo</code></p><p><code>
	};</code></p><p><code>
</code></p><p><code>
lista&lt;float&gt; robot::deltas; //chama o construtor.</code></p><p><code>
</code></p><p><code>
main()</code></p><p><code>
{</code></p><p><code>
</code></p><p><code>
robot *r1=new robot(0.0,0.0); //cria robo 1</code></p><p><code>
r1-&gt;move(1,1);</code></p><p><code>
robot *r2;</code></p><p><code>
robot::mostra_lista(); //mostra lista.</code></p><p><code>
r2=new robot(1.0,1.0);  //cria robo 2</code></p><p><code>
robot::mostra_lista(); //mostra lista.</code></p><p><code>
r2-&gt;move(10,10);</code></p><p><code>
robot::mostra_lista(); //mostra lista.</code></p><p><code>
delete r1;</code></p><p><code>
delete r2;</code></p><p><code>
</code></p><p><code>
return 0;</code></p><p><code>
}</code></p><p><code>
<b></b></code></p><hr><p><code>
</code><b></b></p><p>
<b>Resultado do programa:</b></p><p>
<b></b>=(1.41421)-</p><p>
=(1.41421)-</p><p>
=(15.5563)-(1.41421)-</p><p>
<b></b></p><p>
<b>Static e funções comuns: </b></p><p>
<b>	</b>Funções comuns também podem ter variáveis
static e não só objetos. Neste caso as variáveis
permanecem ativas durante chamadas da função.</p><p>
<b></b></p><p>
<b>Exercícios: </b></p><p>
<b></b>1)Defina uma estrutura de dados mais eficiente para busca que uma lista,
use-a como<code> static</code> no exemplo acima. Faca com que os
robos atendam ao seguinte função membro:
<code>encontra_proximo(void); </code> que faz com que um robo se
mova até a posição do companheiro mais próximo
dele. Perceba que agora você tem que armazenar a posição de
cada robô na estrutura, juntamente com um identificador deste
robô.</p><p>
</p><p>
2)Defina de modo análogo ao exercício anterior
funções membro como agrupa, que faz com que os robos se movam uma
unidade de comprimento em direção ao centro de massa do grupo.
Suponha que todos os robos tenham a mesma massa.</p><p>
</p><p>
3)Você pode desejar armazenar as informações da
classe<code> robot</code> em outra classe, que computa outros
cálculos, neste caso temos pelo menos duas alternativas a
seguir:<b></b></p><p>
<b></b>	a)Crie uma classe auxiliar externa de armazenagem e para todos
objetos<code> robo </code>instanciados passe o ponteiro desta
classe auxiliar como argumento do construtor . Assim esses objetos
poderão mandar mensagens para esta classe de armazenagem. Essas
mensagens, chamadas de funções membro, podem ter vários
significados, num sentido figurado podemos ter algo parecido com: "Classe
auxiliar, armazene essa informação para mim". "Classe auxiliar,
me mande uma mensagem daqui a cinco segundos, estou passando o ponteiro para
mim mesmo <code> (this) </code>" , etc. </p><p>
<b>	</b>As mensagens vistas desse modo ficam mais interessantes, você
pode até achar engraçado, mas é muito prático
pensar assim. Quando estudarmos simulações dirigidas a eventos em
4.6.2 veremos a importância destas trocas de mensagens entre
objetos.<b></b></p><p>
<b></b>	b)Usar friends para que a classe de armazenagem e cálculo e a
classe <code>robot </code>possam interagir.</p><p>
<b></b></p><p>
<b></b>4) Em alguma classe que você criou anteriormente defina
variáveis <code>static </code>com o seguinte objetivo:
Contar, fazer estatísticas das chamadas de função membros
de classe.</p><p>
</p><p>
5)Use o que foi aprendido sobre "<code>static</code> variables" no
programa contas, o objetivo é armazenar informações sobre
os movimentos de todas as contas num objeto static. Para que a
modificação fique a contento você pode precisar tornar o
exemplo mais próximo da realidade, adicionando no construtor de contas
um argumento: número de conta. Comente se você usaria
alocação dinâmica para essa classe de armazenagem agregada
em conta, ou não. Tenha em mente a questão do tamanho em bytes do
objeto.</p><p>
<b>
<a name="_Ref342218224"></a><a name="_Toc342737010"></a><a name="_Toc345409446"></a><a name="_Toc345810951"></a><a name="_Toc345838281"></a><a name="_Toc345942416"></a><a name="_Toc345949576"></a><a name="_Toc346168693"></a><a name="_Toc348417136"></a><a name="_Toc348931392"></a><a name="_Toc353900831"></a><a name="_Toc353946361"></a></b><a name="_Toc353946361">
</a></p><h2><a name="_Toc353946361">
</a><a name="RTFToC71">4.5.
TRATAMENTO DE
EXCEÇÕES</a>
</h2>
<b></b><p>
<b>	</b>Adicionando tratamento de exceções ao programa vetor do
item  4.3.1.</p><p>
<code></code></p><p><code>
<b></b></code></p><hr><p><code>
<b></b>//header file para classe vetor ex.h</code></p><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
</code></p><p><code>
const int inicio=0;</code></p><p><code>
</code></p><p><code>
class excecoesvetor {   //to be throwed</code></p><p><code>
 public:  //nao tenho interesse de encapsular por enquanto.</code></p><p><code>
	excecoesvetor(char* texto);</code></p><p><code>
	char* mensagem;</code></p><p><code>
	char* retorna_mensagem(void);</code></p><p><code>
 };</code></p><p><code>
</code></p><p><code>
class excecaoalocacao:public excecoesvetor{</code></p><p><code>
public:</code></p><p><code>
	 excecaoalocacao(char* texto);</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
class excecaoinstanciacao:public excecoesvetor{</code></p><p><code>
public:</code></p><p><code>
	excecaoinstanciacao(char* texto,int num);</code></p><p><code>
	int quant; //numero de elementos com que se tentou instanciar vetor</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
class excecaolimite:public excecoesvetor{ //limite de indice desrespeitado</code></p><p><code>
 public:</code></p><p><code>
	excecaolimite(char* texto,int ind,int max);</code></p><p><code>
	int indice; //armazena o indice que gerou excecao</code></p><p><code>
	int maximo; //armazena o indice maximo</code></p><p><code>
	//indice minimo e' fixo para este programa=0</code></p><p><code>
	};</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
excecoesvetor::excecoesvetor(char* texto)</code></p><p><code>
{ mensagem=texto;}</code></p><p><code>
</code></p><p><code>
char* excecoesvetor::retorna_mensagem(void)</code></p><p><code>
{ return mensagem; }</code></p><p><code>
</code></p><p><code>
excecaolimite::excecaolimite(char* texto,int ind,int
max):excecoesvetor(texto)</code></p><p><code>
{ indice=ind; maximo=max;}</code></p><p><code>
</code></p><p><code>
excecaoinstanciacao::excecaoinstanciacao(char* texto,int
num):excecoesvetor(texto)</code></p><p><code>
{ quant=num; }</code></p><p><code>
</code></p><p><code>
excecaoalocacao::excecaoalocacao(char* texto):excecoesvetor(texto)</code></p><p><code>
{}</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt; class vetor{ //T e' o tipo do elemento do vetor</code></p><p><code>
private:</code></p><p><code>
T* v;  //pode ser qualquer tipo que atenda as operacoes &lt; &gt; =</code></p><p><code>
int tamanho;</code></p><p><code>
public:</code></p><p><code>
vetor (int tamanho) ;</code></p><p><code>
T&amp; operator[] (int i);</code></p><p><code>
T maximo();</code></p><p><code>
int primeiro(void);</code></p><p><code>
int ultimo(void);</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt; vetor&lt;T&gt;::vetor (int tam)</code></p><p><code>
{</code></p><p><code>
if (tam&lt;1)</code></p><p><code>
	throw excecaoinstanciacao("Vetores de tamanho &lt;1. Sao invalidos.",tam);</code></p><p><code>
v=new T[tam];</code></p><p><code>
if (v==NULL)</code></p><p><code>
	 throw excecaoinstanciacao("Nao consegui alocar memoria",tam);</code></p><p><code>
tamanho=tam;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt; int vetor&lt;T&gt;::primeiro (void)</code></p><p><code>
{return inicio;}</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt; int vetor&lt;T&gt;::ultimo (void)</code></p><p><code>
{return tamanho-1;}</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt; T&amp; vetor&lt;T&gt;::operator[](int i)</code></p><p><code>
{</code></p><p><code>
 if (i&lt;0 || i&gt;=tamanho)</code></p><p><code>
 throw excecaolimite("Fora dos limites.",i,tamanho);</code></p><p><code>
 return v[i];</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
template&lt;class T&gt; T vetor&lt;T&gt;:: maximo(void)</code></p><p><code>
{</code></p><p><code>
 int candidato=inicio;</code></p><p><code>
 for (int i=inicio;i&lt;tamanho;i++)</code></p><p><code>
 if (v[i]&gt;v[candidato]) candidato=i;</code></p><p><code>
 return v[candidato];</code></p><p><code>
}</code></p><p><code>
<b></b></code></p><p><code>
<b></b></code></p><hr><p><code>
<b></b></code></p><p><code>
<b></b>//main file</code></p><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
#include "ex.h"</code></p><p><code>
main()</code></p><p><code>
{</code></p><p><code>
try</code></p><p><code>
{</code></p><p><code>
 int ind; //indice, usado para atualizacoes</code></p><p><code>
 float item; //item, usado para insercoes no vetor</code></p><p><code>
</code></p><p><code>
 vetor&lt;float&gt;* meu;</code></p><p><code>
</code></p><p><code>
 try</code></p><p><code>
  { meu=new vetor&lt;float&gt;(5); }</code></p><p><code>
 catch  (excecaoinstanciacao&amp; e)</code></p><p><code>
  {</code></p><p><code>
	cout &lt;&lt; "Excecao gerada! O  vetor nao pode ser criado." &lt;&lt; endl;</code></p><p><code>
	cout &lt;&lt; e.retorna_mensagem() &lt;&lt; endl;</code></p><p><code>
	cout &lt;&lt; "O indice invalido e':"&lt;&lt; e.quant &lt;&lt; endl;</code></p><p><code>
	cout &lt;&lt; "O programa sera terminado." &lt;&lt; endl;</code></p><p><code>
	throw; //~rethrow</code></p><p><code>
  }</code></p><p><code>
 catch (excecaoalocacao&amp; e)</code></p><p><code>
  {</code></p><p><code>
	cout &lt;&lt; "Excecao gerada! O vetor nao pode ser criado." &lt;&lt; endl;</code></p><p><code>
	cout &lt;&lt; e.retorna_mensagem() &lt;&lt; endl;</code></p><p><code>
	cout &lt;&lt; "O programa sera terminado." &lt;&lt; endl;</code></p><p><code>
	throw;</code></p><p><code>
 }</code></p><p><code>
 catch (excecoesvetor&amp; e)</code></p><p><code>
  {</code></p><p><code>
	cout &lt;&lt; "Esta excecao nao estava prevista em nosso
codigo."&lt;&lt;endl;</code></p><p><code>
	cout &lt;&lt; "Pode ser resultado de uma extensao na hierarquia de
excecoes."&lt;&lt;endl;</code></p><p><code>
   cout &lt;&lt; e.retorna_mensagem() &lt;&lt; endl;</code></p><p><code>
  }</code></p><p><code>
</code></p><p><code>
 for (int i=meu-&gt;primeiro();i&lt;=meu-&gt;ultimo();i++)</code></p><p><code>
 {</code></p><p><code>
  cout &lt;&lt; "Entre com valor da posicao:" &lt;&lt; i &lt;&lt; "\n";</code></p><p><code>
  cin &gt;&gt; meu-&gt;operator[](i);</code></p><p><code>
 }</code></p><p><code>
</code></p><p><code>
 for (int j=meu-&gt;primeiro();j&lt;=meu-&gt;ultimo();j++) cout&lt;&lt;
(*meu)[j]&lt;&lt; " ";</code></p><p><code>
</code></p><p><code>
 cout &lt;&lt; "Entre com o indice da posicao a atualizar:\n";</code></p><p><code>
 cin &gt;&gt; ind;</code></p><p><code>
 cout &lt;&lt; "Entre com o valor a incluir:";</code></p><p><code>
 cin  &gt;&gt; item;</code></p><p><code>
</code></p><p><code>
 try{(*meu)[ind]=item;}</code></p><p><code>
 catch  (excecaolimite&amp; e)</code></p><p><code>
 {</code></p><p><code>
  cout &lt;&lt; "\a Subscripting desconsiderado."&lt;&lt;endl;</code></p><p><code>
  cout &lt;&lt; e.retorna_mensagem() &lt;&lt; endl;</code></p><p><code>
 }</code></p><p><code>
 //incluir um loop ate obter do teclado valores validos.</code></p><p><code>
</code></p><p><code>
 for (int k=meu-&gt;primeiro();k&lt;=meu-&gt;ultimo();k++) cout&lt;&lt;
(*meu)[k]&lt;&lt; " ";</code></p><p><code>
 cout &lt;&lt;endl &lt;&lt; "Maximo:" &lt;&lt; meu-&gt;maximo();</code></p><p><code>
</code></p><p><code>
 return 0;</code></p><p><code>
 }//try</code></p><p><code>
 catch(...)</code></p><p><code>
 {</code></p><p><code>
  cout &lt;&lt; "Excecoes nao tratadas, fim do programa."&lt;&lt;endl;</code></p><p><code>
 }</code></p><p><code>
}</code></p><p><code>
<b></b></code></p><hr><p><code>
</code><b></b></p><p>
<b>Resultado normal do programa:</b></p><p>
<b></b>Entre com valor da posicao:0</p><p>
5.2</p><p>
Entre com valor da posicao:1</p><p>
5632.2</p><p>
Entre com valor da posicao:2</p><p>
12.5</p><p>
Entre com valor da posicao:3</p><p>
12</p><p>
Entre com valor da posicao:4</p><p>
2.21</p><p>
5.2 5632.2 12.5 12 2.21 Entre com o indice da posicao a atualizar:</p><p>
0</p><p>
Entre com o valor a incluir:2</p><p>
2 5632.2 12.5 12 2.21</p><p>
Maximo:5632.2</p><p>
<b></b></p><p>
<b>Resultado anormal devido a índice inválido dado ao
programa:</b></p><p>
<b></b>Entre com valor da posicao:0</p><p>
2.2</p><p>
Entre com valor da posicao:1</p><p>
5.9</p><p>
Entre com valor da posicao:2</p><p>
4.1</p><p>
Entre com valor da posicao:3</p><p>
65.5</p><p>
Entre com valor da posicao:4</p><p>
2.3</p><p>
2.2 5.9 4.1 65.5 2.3 Entre com o indice da posicao a atualizar:</p><p>
6</p><p>
Entre com o valor a incluir:4.5</p><p>
 Subscripting desconsiderado.</p><p>
Fora dos limites.</p><p>
2.2 5.9 4.1 65.5 2.3</p><p>
Maximo:65.5</p><p>
<b></b></p><p>
<b>Resultado anormal devido a falha de alocação de
memória</b>:</p><p>
Excecao gerada! O  vetor nao pode ser criado.</p><p>
Nao consegui alocar memoria</p><p>
O indice invalido e':5</p><p>
O programa sera terminado.</p><p>
Excecoes nao tratadas, fim do programa.</p><p>
<b></b></p><p>
<b>Resultado anormal devido a numero de elementos do vetor &lt; 1:</b></p><p>
<b></b>Excecao gerada! O  vetor nao pode ser criado.</p><p>
Vetores de tamanho &lt;1. Sao invalidos.</p><p>
O indice invalido e':-5</p><p>
O programa sera terminado.</p><p>
Excecoes nao tratadas, fim do programa.</p><p>
<b></b></p><p>
<b>Exercícios:</b></p><p>
<b></b>1) Implemente, adicione tratamento de exceções para o
exemplo de 4.1.2. Antes faça um levantamento das exceções
que podem ser geradas, lembre das restrições matemáticas
para o denominador em uma divisão. Leve em conta também o
overflow de variáveis<code> long</code> que são uma
representação com número de bits finito da sequencia dos
números inteiros (conjunto Z da matemática). Compare este
tratamento com o de outros programas por exemplo na divisão por zero,
quais as vantagens que você pode apontar e desvantagens?</p><p>
<b>
<a name="_Toc342737011"></a><a name="_Toc345409447"></a><a name="_Toc345810952"></a><a name="_Toc345838282"></a><a name="_Toc345942417"></a><a name="_Toc345949577"></a><a name="_Toc346168694"></a><a name="_Toc348417137"></a><a name="_Toc348931393"></a><a name="_Toc353900832"></a><a name="_Toc353946362"></a></b><a name="_Toc353946362">
</a></p><h2><a name="_Toc353946362">
</a><a name="RTFToC72">4.6.
CONCLUSÕES</a>
</h2>
<p>
	Neste tópico apresentaremos programas mais elaborados dentre eles uma
simulação dirigida a eventos e uma implementação de
uma árvore binária.</p><p>
<a name="_Toc342737012"></a><a name="_Toc345409448"></a><a name="_Toc345810953"></a><a name="_Toc345838283"></a><a name="_Toc345942418"></a><a name="_Toc345949578"></a><a name="_Toc346168695"></a><a name="_Toc348417138"></a><a name="_Toc348931394"></a><a name="_Toc353900833"></a><a name="_Toc353946363">
</a></p><h3><a name="_Toc353946363">
</a><a name="RTFToC73">4.6.1.
ÁRVORE BINÁRIA.</a>
</h3>
<p>
Este programa implementa uma árvore binária e testa-a:
<code></code></p><p><code>
<b></b></code></p><hr><p><code>
#include&lt;iostream.h&gt;</code></p><p><code>
const TRUE=1;</code></p><p><code>
const FALSE=0;</code></p><p><code>
</code></p><p><code>
class no //no agregado na classe arvore, por razoes de encapsulamento</code></p><p><code>
{</code></p><p><code>
private:</code></p><p><code>
 int info;    //atributo informacao, use template depois...</code></p><p><code>
 no* esq;   //subarvore esquerda</code></p><p><code>
 no* dir; //subarvore direita</code></p><p><code>
 int busca_maisesq(void);</code></p><p><code>
public:</code></p><p><code>
 no(int a);  //sem filhos</code></p><p><code>
 no(int a,no* b,no* c);  //com filhos</code></p><p><code>
 int retorna_quant(void);</code></p><p><code>
 no* insere(int a,int&amp; res);</code></p><p><code>
 no* remove(int b,int&amp; res);//res = resultado (sucesso?)</code></p><p><code>
 int busca(int c); //busca binaria</code></p><p><code>
 void in_order(); //parentisada</code></p><p><code>
 ~no(void); //destrutor da arvore/subarvore</code></p><p><code>
 static int quant; //so para testes, pode ser public.</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
class arv_bin { //encapsula no e redireciona chamadas de metodos</code></p><p><code>
private:</code></p><p><code>
 no* ar;</code></p><p><code>
public:</code></p><p><code>
arv_bin(void);</code></p><p><code>
arv_bin(int a);</code></p><p><code>
void insere(int a,int&amp; result);</code></p><p><code>
void remove(int b,int&amp; result);</code></p><p><code>
int busca(int c); //busca binaria</code></p><p><code>
void in_order(); //parentisada</code></p><p><code>
~arv_bin(void);</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
<b></b></code></p><hr><p><code>
</code></p><p><code>
#include&lt;iostream.h&gt;</code></p><p><code>
#include&lt;stdlib.h&gt;</code></p><p><code>
#include"binatree.h"</code></p><p><code>
</code></p><p><code>
int no::quant=0; //aqui eu uso uma variavel static</code></p><p><code>
</code></p><p><code>
no::no(int a)</code></p><p><code>
{info=a; esq=NULL; dir=NULL;quant++;}</code></p><p><code>
</code></p><p><code>
no::no(int a,no* b,no* c) //constructor</code></p><p><code>
{info=a;esq=b;dir=c;quant++;}</code></p><p><code>
</code></p><p><code>
int no::retorna_quant(void)</code></p><p><code>
{ return quant; }</code></p><p><code>
</code></p><p><code>
int no:: busca_maisesq(void)</code></p><p><code>
{</code></p><p><code>
 if  ((*this).esq==0) return info;</code></p><p><code>
 else return ((*this).esq-&gt;busca_maisesq());</code></p><p><code>
//chamada recursiva.</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
no* no::insere(int a,int&amp; res)</code></p><p><code>
{</code></p><p><code>
 res=1;</code></p><p><code>
 if (this==NULL) return new no(a,NULL,NULL);</code></p><p><code>
 if (a&gt;=info) if (dir==NULL) dir=new no(a,NULL,NULL);</code></p><p><code>
				 else dir=(*dir).insere(a,res);</code></p><p><code>
 else  if (a&lt;info) if (esq==NULL) esq=new no(a,NULL,NULL);</code></p><p><code>
						 else esq=(*esq).insere(a,res);</code></p><p><code>
 return this; //nao e necessario.</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
no* no::remove(int b,int&amp; res)</code></p><p><code>
{</code></p><p><code>
  int copy;</code></p><p><code>
  no* delete_aux;</code></p><p><code>
  no* return_aux; //usado para deletar um no</code></p><p><code>
  if (this==NULL) {</code></p><p><code>
							res=FALSE;</code></p><p><code>
							return NULL; //arvore ou subarvore vazia</code></p><p><code>
						}</code></p><p><code>
  else //not a nill pointer</code></p><p><code>
	if (b&gt;(*this).info) (*this).dir=(*this).dir-&gt;remove(b,res);</code></p><p><code>
	 if (b&lt;(*this).info) (*this).esq=(*this).esq-&gt;remove(b,res);</code></p><p><code>
	  if (b==(*this).info) //preciso deletar aqui</code></p><p><code>
	  {</code></p><p><code>
		res=TRUE;</code></p><p><code>
		if (((*this).dir==NULL) &amp;&amp; ((*this).esq==NULL)) //sem filhos</code></p><p><code>
			{</code></p><p><code>
			delete this;</code></p><p><code>
			return NULL;</code></p><p><code>
			}</code></p><p><code>
		else if ((*this).esq==NULL) //como remover de lista linear</code></p><p><code>
			  {</code></p><p><code>
			  delete_aux=this;</code></p><p><code>
			  return_aux=((*this).dir);</code></p><p><code>
			  (*delete_aux).dir=NULL; //evita deletar subarvore</code></p><p><code>
			  delete delete_aux;</code></p><p><code>
			  return return_aux;</code></p><p><code>
			  }</code></p><p><code>
			  else if ((*this).dir==NULL) //como lista linear</code></p><p><code>
					 {</code></p><p><code>
					 delete_aux=this;</code></p><p><code>
					 return_aux=(*this).esq;</code></p><p><code>
					 (*delete_aux).esq=NULL;</code></p><p><code>
					 delete delete_aux;  //nao esqueca</code></p><p><code>
					 return return_aux;</code></p><p><code>
					 }</code></p><p><code>
					 else //o caso mais complicado</code></p><p><code>
					 {</code></p><p><code>
					  copy=(*this).dir-&gt;busca_maisesq();</code></p><p><code>
					  info=copy;</code></p><p><code>
					  (*this).dir=(*this).dir-&gt;remove(copy,res);</code></p><p><code>
					 }</code></p><p><code>
	  }</code></p><p><code>
  return this; //para muitos casos.</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
int no::busca(int c)</code></p><p><code>
{</code></p><p><code>
 if (this!=NULL)</code></p><p><code>
  if (c==info) return c;</code></p><p><code>
  else if (c&gt;info) return ((*dir).busca(c));</code></p><p><code>
		 else return ((*esq).busca(c));</code></p><p><code>
 else return -c;</code></p><p><code>
</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
void no::in_order(void)   //percurso in_order</code></p><p><code>
{</code></p><p><code>
 if (this!=NULL)</code></p><p><code>
 {</code></p><p><code>
 cout &lt;&lt; "(" ;</code></p><p><code>
 (*esq).in_order();</code></p><p><code>
 cout &lt;&lt; info;</code></p><p><code>
 (*dir).in_order();</code></p><p><code>
 cout &lt;&lt; ")";</code></p><p><code>
 };</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
no::~no(void)</code></p><p><code>
{</code></p><p><code>
if (this!=NULL)</code></p><p><code>
 {</code></p><p><code>
 quant--;</code></p><p><code>
 if (dir!=NULL) delete dir; //primeiro chama destrutor depois deleta no</code></p><p><code>
 if (esq!=NULL) delete esq; //o destrutor e chamado para toda a arvore e
entao</code></p><p><code>
 }</code></p><p><code>
//ela volta deletando os nos</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
</code></p><p><code>
arv_bin::arv_bin(void)</code></p><p><code>
{ ar=NULL;} </code></p><p><code>
</code></p><p><code>
arv_bin::arv_bin(int a)</code></p><p><code>
 { ar=new no(a);}</code></p><p><code>
</code></p><p><code>
//inline</code></p><p><code>
void arv_bin::insere(int a,int&amp; result)</code></p><p><code>
 { ar=ar-&gt;insere(a,result); }</code></p><p><code>
</code></p><p><code>
//inline</code></p><p><code>
 void arv_bin::remove(int a,int&amp; result)</code></p><p><code>
 { ar=ar-&gt;remove(a,result);}</code></p><p><code>
</code></p><p><code>
//inline</code></p><p><code>
 int arv_bin::busca(int a)</code></p><p><code>
 { return ar-&gt;busca(a); }</code></p><p><code>
</code></p><p><code>
//inline</code></p><p><code>
 void arv_bin::in_order(void)</code></p><p><code>
 { ar-&gt;in_order(); }</code></p><p><code>
</code></p><p><code>
arv_bin::~arv_bin()</code></p><p><code>
 { delete ar; }</code></p><p><code>
</code></p><p><code>
<b></b></code></p><hr><p><code>
</code></p><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
#include "binatree.h"</code></p><p><code>
</code></p><p><code>
main() //testa a arvore com menu.</code></p><p><code>
{</code></p><p><code>
int n; //lido para ser inserido ou removido.</code></p><p><code>
int flag;</code></p><p><code>
arv_bin my_tree;</code></p><p><code>
char option='w';</code></p><p><code>
do</code></p><p><code>
{</code></p><p><code>
cout &lt;&lt; endl;</code></p><p><code>
cout &lt;&lt; " I-Insere\n";</code></p><p><code>
cout &lt;&lt; " R-Remove\n";</code></p><p><code>
cout &lt;&lt; " N-In Order (Percurso)\n";</code></p><p><code>
cout &lt;&lt;7 " B-Busca\n";</code></p><p><code>
cout &lt;&lt; " S-Sair\n";</code></p><p><code>
cout &lt;&lt; " Entre opcao:";</code></p><p><code>
cout &lt;&lt; " \n";</code></p><p><code>
cin &gt;&gt;option; //entre a opcao do menu</code></p><p><code>
 switch(option) //executes user option</code></p><p><code>
 {</code></p><p><code>
  case 'I':</code></p><p><code>
  case 'i':</code></p><p><code>
				cout &lt;&lt; "\n Digite numero a inserir:";</code></p><p><code>
				cin &gt;&gt; n;</code></p><p><code>
				cout &lt;&lt; "\n";</code></p><p><code>
				flag=FALSE;</code></p><p><code>
				my_tree.insere(n,flag);</code></p><p><code>
				cout &lt;&lt; "flag:"&lt;&lt;flag &lt;&lt; endl;</code></p><p><code>
				break;</code></p><p><code>
  case 'R':</code></p><p><code>
  case 'r':</code></p><p><code>
				cout &lt;&lt; "\n Digite numero a remover:";</code></p><p><code>
				cin &gt;&gt; n;</code></p><p><code>
				cout &lt;&lt; "\n";</code></p><p><code>
				flag=FALSE;</code></p><p><code>
				my_tree.remove(n,flag);</code></p><p><code>
				cout &lt;&lt; "flag:"&lt;&lt;flag &lt;&lt; endl;</code></p><p><code>
				break;</code></p><p><code>
  case 'N':</code></p><p><code>
  case 'n':</code></p><p><code>
				cout &lt;&lt; "\n";</code></p><p><code>
				my_tree.in_order();</code></p><p><code>
				cout &lt;&lt; " " &lt;&lt; no::quant &lt;&lt; ":Nos\n";</code></p><p><code>
				cout &lt;&lt; "\n";</code></p><p><code>
				break;</code></p><p><code>
  case 'B':</code></p><p><code>
  case 'b':</code></p><p><code>
				cout &lt;&lt; "\n Digite numero a achar:";</code></p><p><code>
				cin &gt;&gt; n;</code></p><p><code>
				cout &lt;&lt; "\n";</code></p><p><code>
				cout &lt;&lt; " " &lt;&lt; my_tree.busca(n);</code></p><p><code>
				cout &lt;&lt; "\n";</code></p><p><code>
				break;</code></p><p><code>
  case 'S':</code></p><p><code>
  case 's':</code></p><p><code>
				cout &lt;&lt; "\n BYE \n";</code></p><p><code>
				break;</code></p><p><code>
  default:  ;</code></p><p><code>
 }  //switch-case code block</code></p><p><code>
} while ((option!='s')&amp;&amp;(option!='S'));</code></p><p><code>
cout &lt;&lt; " Nodes:" &lt;&lt; no::quant &lt;&lt; endl;</code></p><p><code>
return 0;</code></p><p><code>
}</code></p><p><code>
<b></b></code></p><hr><p><code>
</code><b></b></p><p>
<b>Resultado do programa:</b></p><p>
<b></b>	Não pode ser exibido por ser muito extenso.</p><p>
<b>
<a name="_Ref345754631"></a><a name="_Toc345810954"></a><a name="_Toc345838284"></a><a name="_Toc345942419"></a><a name="_Toc345949579"></a><a name="_Toc346168696"></a><a name="_Toc348417139"></a><a name="_Toc348931395"></a><a name="_Toc353900834"></a><a name="_Toc353946364"></a></b><a name="_Toc353946364">
</a></p><h3><a name="_Toc353946364">
</a><a name="RTFToC74">4.6.2.
SIMULAÇÃO DIRIGIDA A
EVENTOS.</a>
</h3>
<p>
</p><p>
	Este tópico é o último e o único que ainda
está sendo editado.</p><p>
	Este exemplo apresenta uma simulação dirigida a eventos.
Simulamos um banco, as variáveis da simulação são:
tempo médio de entrada de clientes no banco, tempo médio de
atendimento, número de atendentes. </p><p>
A  linguagem precursora das atuais linguagens orientadas a objetos, Simula,
não por acaso foi criada para programar simulações. Em
programação orientada a objetos estamos frequentemente
preocupados em modelar entidades, objetos, do mundo real, é justamente
esta a tarefa de uma simulação.</p><p>
	Você notará que nosso programa principal é bastante
pequeno. Ocorre que <code>main</code> é usado para apenas
inicializar os objetos e a simulação, a maioria das
ações ocorre através de chamadas de funções
membro entre os objetos, isto é muito bom, evitamos ao máximo a
presença de variáveis locais e passagem por referência.</p><p>
<a href="http://www.ic.unicamp.br/%7Ecmrubira/aacesta/cpp/bancosim.gif">Click here for Picture </a></p><p>
	O diagrama mostra o cenário de nossa simulação:</p><p>
</p><p>
</p><p>
Neste diagrama estão presentes as classes com que iremos trabalhar:
<code>costumer, clerk, scheduler</code>, <code>manager,
front_door, geometric. Costumer e clerk </code>são subclasses de
<code>active</code>, uma classe base abstrata. <code>
Manager, costumer, clerk </code>são objetos reais, existiriam no
mundo real. <code>Scheduler</code> e <code>front_door,
</code> <code>geometric </code>não são objetos
reis, são criados para auxiliar na simulação.</p><p>
Nossa simulação é do tipo discreta, dirigida a eventos, em
contraposição com o tipo contínuo. Ou seja estaremos
atentos, monitorando,eventos tais como o fato de um cliente entrar no banco ou
ser atendido e não grandezas continuas como a vazão de uma bomba
hidráulica ou a velocidade de um motor elétrico. </p><p>
Nossa simulação é dita discreta porque os eventos ocorrem
em intervalos fixos de tempo e não entre eles, o número desses
intervalos é escolhido pelo usuário e deve ser grande com
relação aos tempos usados na simulação (tempo
médio de atendimento, etc). Estes tempos médios por serem
inteiros devem ser escolhidos de forma a não gerar casos degenerados, ou
seja se você estimou que em seu banco o tempo de atendimento é em
geral três vezes maior que o tempo médio de entrada de clientes no
banco, então prefira uma relação do tipo (27/9) ao
envés de (9/3), esses tempos continuarão pequenos perto do tempo
de duracão da simulação: 10000, porém não
tão pequenos que possam ser pouco
[[dieresis]]representativos[[dieresis]] em termos de tempos diferentes que
podem ocorrer. Entenda por casos degenerados, casos que não serão
capazes de representar, modelar corretamente o que aconteceria em seu banco,
fornecendo resultados discrepantes com outras opções equivalentes
(em termos de proporções) de valores iniciais da
simulação.</p><p>
	Um pouco sobre estatística e probalilidade. Vamos precisar de conceitos
de estatística neste problema. A tempo de atendimento de clientes segue
usualmente uma distribuição geométrica (lembre-se que em
estatística existem distribuições discretas e
contínuas), a nossa é discreta. A linguagem só oferece a
distribuição de números conhecida como uniforme ,aquela em
que todos números tem a mesma probabilidade de serem sorteados, ela pode
ser gerada por chamadas a função rand() da
[[dieresis]]library[[dieresis]] stdlib.h, rand() gera números
pseudo-aleatórios na faixa de 0 até RAND_MAX (não se
preocupe, RAND_MAX está definido na stdlib.h e é
geralmente==32767).</p><p>
	Dizemos que <code>rand()</code> gera números
pseudo-aleatórios porque esta função utiliza uma semente
para gerar uma sequência de números, esta sequência de
números pode ser repetida, basta utilizar a mesma semente. Esta
possíbilidade de repetição será importante para
realizar testes do programa, frequentemente o programador deseja repetir o
resultado da última execução, isto só é
possível se for fornecida a mesma semente de geração dos
números através de uma chamada a função
<code>void srand(unsigned s) </code>, já importada com as
"libraries" que você utilizará na simulação.</p><p>
	Felizmente dispomos de uma maneira de construir um gerador de números
que obedecem uma distribuição geométrica, a partir de um
gerador de números aleatórios. A distribuição
uniforme precisa como parametro um valor máximo, enquanto que a
geométrica precisa de um valor médio. </p><p>
Na distribuição geométrica, se um cliente é
atendido em um tempo médio de 10, então podemos dizer que se ele
tiver começado a ser atendido agora, existe em média uma chance
em dez de ele terminar de ser atendido no próximo instante. Vamos supor
que o cliente não foi atendido logo no primeiro instante, então
existe uma chance em dez de ele ser atendido no próximo instante e assim
por diante. As probabilidades são iguais e independentes uma das outras.
A soma das probabilidades de cada instante completa 1 no tempo médio de
atendimento que no caso é 10. Porém isto não significa que
10 é um limite máximo, mas apenas a média!</p><p>
	Se a probabilidade p de o cliente ser atendido no instante atual é
p==(1/média) então a probabilidade de ele não ser atendido
é (1-p). Seguindo o raciocínio anterior, a probabilidade de o
cliente ser atendido no primeiro tique do relógio é p. A
probabilidade que o mesmo cliente seja atendido só no segundo tique
é igual a probabilidade de ele não ser atendido no primeiro
tique==(1-p) <b>e (*)</b> a probabilidade de ele ser atendido no segundo
tique==p (igual a p para todos os instantes isolados). Seguindo o mesmo
raciocínio, a probabilidade de o cliente vir a ser atendido só no
terceiro tique é (1-p)*(1-p)*p. A formula geral da probabilidade de um
cliente esperar t tiques enquanto é atendido é:
p*((1-p)ˆ(t-1)).</p><p>
	Suponha que tomamos n=100 bolas, das quais pintamos (n/média) de branco
e o restante de preto (média&lt;n). Chamemos de p a probabilidade de se
retirar numa única tentativa uma bola branca de nossas n bolas, p
é igual a (1/média). A probabilidade do evento complementar
é (1-(1/média))==(1-p). A probabilidade de se obter uma bola
branca só na segunda retirada com reposição é
(1-p)*p, enquanto que só na terceira retirada é (1-p)*(1-p)*p e
assim por diante, como no exemplo anterior.</p><p>
	Pois bem, as nossas n bolas podem ser vistas como os números da
distribuição uniforme gerada por rand(). Pintar de branco parte
das bolas de branco e o restante de preto equivale a dividir o intervalo de 0
até RAND_MAX em números menores que <code>
(RAND_MAX+1/média)==ways_to_occur </code> (brancos) e
números maiores que isso (pretos). Sortear uma bola e verificar a cor
equivale a chamar <code>rand()</code> e ver em que intervalo o
resultado cai. Temos então o procedimento para obter números
segundo uma distribuição geométrica a partir de um gerador
de números aleatórios. Construiremos uma classe em nosso programa
para obter estes números, será a classe geometric. Sua
implementação está no arquivo geometric.cpp. </p><p>
</p><p>
<a href="http://www.ic.unicamp.br/%7Ecmrubira/aacesta/cpp/cpp153.gif">Click here for Picture </a></p><p>
</p><p>
</p><p>
<code></code></p><p><code>
<b></b></code></p><hr><p><code>
//File repair.h</code></p><p><code>
//Header file for costumer-servement simulation</code></p><p><code>
#include &lt;stdlib.h&gt;</code></p><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
</code></p><p><code>
enum Boolean {FALSE,TRUE};   //0 ou 1</code></p><p><code>
</code></p><p><code>
class scheduler; //classe nao real</code></p><p><code>
class manager;   //classe real</code></p><p><code>
</code></p><p><code>
//class of geometric-distribution random number generators</code></p><p><code>
</code></p><p><code>
class geometric{</code></p><p><code>
            int geo_max;			//maximum value of random number</code></p><p><code>
	int ways_to_occur;  //no. ways desired event can occur</code></p><p><code>
 public:</code></p><p><code>
	geometric(double mean,int max);</code></p><p><code>
	int draw(); //return next random number</code></p><p><code>
	Boolean e_agora(void); //verifica se e agora que entra costumer</code></p><p><code>
 };</code></p><p><code>
</code></p><p><code>
 //Abstract base class of active objects</code></p><p><code>
</code></p><p><code>
 class active{</code></p><p><code>
	active* next; //next-object pointer for linked lists</code></p><p><code>
 public:</code></p><p><code>
	void set_next(active* p) {next=p;}</code></p><p><code>
	active* get_next(void) {return next;}</code></p><p><code>
	virtual void event()=0; //trigger scheduled event</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
//Class for costumer objects</code></p><p><code>
</code></p><p><code>
class costumer:public active{</code></p><p><code>
	scheduler* sp; //pointer to scheduler</code></p><p><code>
	manager* mp;    //pointer to service manager</code></p><p><code>
	geometric g;	//random number generator</code></p><p><code>
	Boolean is_up;  //state_variable</code></p><p><code>
	int tot_up_time; //tempo total de pe</code></p><p><code>
	int up_time_start; //start of most recent up-period</code></p><p><code>
	static double servedcost; //total number of served costumers</code></p><p><code>
	static double waitedtime; //total waited time for all costumers</code></p><p><code>
public:</code></p><p><code>
	costumer(double mean,int max,scheduler* s,manager* m);</code></p><p><code>
	void event(); //time to be served</code></p><p><code>
	void served(); //Come back home costumer. (Killed)</code></p><p><code>
	static double g_servedcost() {return servedcost;}</code></p><p><code>
	static double g_waitedtime() {return waitedtime;}</code></p><p><code>
	static int vivos; //numero de costumers vivos, so p/debugging</code></p><p><code>
	~costumer() {vivos--;} //so para controle de alocacao dinamica</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
//Class for clerk objects</code></p><p><code>
</code></p><p><code>
class clerk:public active{</code></p><p><code>
	scheduler* sp; //pointer to scheduler</code></p><p><code>
	manager* mp;   //pointer to service manager</code></p><p><code>
	geometric g;   //random number generator</code></p><p><code>
	costumer* workp; //pointer to costumer under repair</code></p><p><code>
	Boolean is_busy; //state variable</code></p><p><code>
	int busy_time_start; //start of most recent busy period</code></p><p><code>
	int tot_busy_time; //total busy time</code></p><p><code>
public:</code></p><p><code>
	clerk(double mean,int max,scheduler* s,manager*  m);</code></p><p><code>
	void event(); //time to complete repair</code></p><p><code>
	void serve(costumer* p); //acept work assigment</code></p><p><code>
	int busy_time(); //return total busy time</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
class manager {</code></p><p><code>
	enum who {COSTUMERS,CLERKS,NONE};</code></p><p><code>
	who waiting; //kind of objects in queue</code></p><p><code>
	active* first; //points to first object in queue</code></p><p><code>
	active* last; //points to last object in queue</code></p><p><code>
	double llsum; //line lenght sum (sum every tick, when with costumers)</code></p><p><code>
	int lenght; //comprimento da fila</code></p><p><code>
</code></p><p><code>
	//Private functions for manipulating queue</code></p><p><code>
</code></p><p><code>
	void insert_first(active* p)</code></p><p><code>
		{first=last=p; p-&gt;set_next(0);lenght++;}</code></p><p><code>
	void insert(active* p)</code></p><p><code>
		{last-&gt;set_next(p); p-&gt;set_next(0); last=p;lenght++;}</code></p><p><code>
	void remove()</code></p><p><code>
		{first=first-&gt;get_next();lenght--;}</code></p><p><code>
</code></p><p><code>
//vamos percorrer a lista e sortear clerk desocupado</code></p><p><code>
	clerk* escolhe_randomico(void)</code></p><p><code>
		{  //escolhe randomico</code></p><p><code>
		  int posicao;</code></p><p><code>
		  posicao=(rand() % lenght)+1;  //1..lenght posicao a deletar</code></p><p><code>
		  active* corr=first; //corrente, itera sobre lista</code></p><p><code>
		  active* prev=NULL; //ainda nao esta sobre a lista</code></p><p><code>
		  for (int i=0;i&lt;(posicao-1);i++) //i=local do previo (0...lenght-1)</code></p><p><code>
			{</code></p><p><code>
			prev=corr;</code></p><p><code>
			corr=corr-&gt;get_next(); //desloca ponteiros na lista</code></p><p><code>
			}</code></p><p><code>
			clerk* retorne=(clerk*) corr; //type cast</code></p><p><code>
			if (last==corr) last=prev;</code></p><p><code>
			if (prev==NULL) first=corr-&gt;get_next();</code></p><p><code>
			else prev-&gt;set_next(corr-&gt;get_next());</code></p><p><code>
			lenght--;</code></p><p><code>
			return retorne;</code></p><p><code>
		}	 //escolhe_randomico</code></p><p><code>
public:</code></p><p><code>
	manager() {first=last=0; waiting=NONE;lenght=0;llsum=0;}</code></p><p><code>
	void request_service(costumer* p); //service request</code></p><p><code>
	costumer* request_work(clerk* p); //work request</code></p><p><code>
	void tick(void)</code></p><p><code>
	{ if (waiting==COSTUMERS) llsum+=lenght;}</code></p><p><code>
	double g_llsum(void)</code></p><p><code>
		{ return llsum;}</code></p><p><code>
	~manager()</code></p><p><code>
	 {</code></p><p><code>
	 while (first!=NULL)</code></p><p><code>
	 {active* aux=first; first=first-&gt;get_next(); delete aux;}</code></p><p><code>
	 }</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
//Class for scheduler</code></p><p><code>
class front_door{</code></p><p><code>
private:</code></p><p><code>
	double media;</code></p><p><code>
	int maximo;</code></p><p><code>
	scheduler* sp;</code></p><p><code>
	manager* mp;</code></p><p><code>
	geometric* g;</code></p><p><code>
public:</code></p><p><code>
  void init(double mean,int max,scheduler* s,manager* m)</code></p><p><code>
		{</code></p><p><code>
		media=mean;</code></p><p><code>
		maximo=max;</code></p><p><code>
		sp=s;</code></p><p><code>
		mp=m;</code></p><p><code>
		g=new geometric(mean,max);</code></p><p><code>
		}</code></p><p><code>
	void sorteia_cost(void)</code></p><p><code>
	 {</code></p><p><code>
	 costumer* esquecame;</code></p><p><code>
	 if (g-&gt;e_agora()) esquecame=new costumer(media,maximo,sp,mp);</code></p><p><code>
	 //nao se preocupe com delecao, o costumer se pendura nas listas</code></p><p><code>
	 //(this) e vai acabar sendo deletado pelo clerk</code></p><p><code>
	 }</code></p><p><code>
	 ~front_door(void) { delete g;}</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
class scheduler {</code></p><p><code>
	int clock;        	//simulation clock</code></p><p><code>
	int calendar_size;   //size of calendar_queue array</code></p><p><code>
	active** calendar; //pointer to calendar queue array</code></p><p><code>
	int index; //calendar queue array subscript for current time</code></p><p><code>
	front_door* fd;</code></p><p><code>
	manager* m;</code></p><p><code>
public:</code></p><p><code>
	scheduler(int sz,front_door* fdp,manager* mp);</code></p><p><code>
	int time() {return clock;} //return time</code></p><p><code>
	void schedule(active* p,int delay); //schedule event</code></p><p><code>
	void run(int ticks); //run simulation</code></p><p><code>
	~scheduler(void)</code></p><p><code>
	 {</code></p><p><code>
	  for (int i=0;i&lt;calendar_size;i++)</code></p><p><code>
		 {</code></p><p><code>
		  while (calendar[i]!=NULL)</code></p><p><code>
			{</code></p><p><code>
			active* aux;</code></p><p><code>
			aux=calendar[i];</code></p><p><code>
			calendar[i]=calendar[i]-&gt;get_next();</code></p><p><code>
			delete aux;</code></p><p><code>
			}</code></p><p><code>
		 }</code></p><p><code>
	 }</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
<b></b></code></p><hr><p><code>
</code></p><p><code>
//File geometrc.cpp</code></p><p><code>
//Source file for class geometric</code></p><p><code>
</code></p><p><code>
#include &lt;stdlib.h&gt;</code></p><p><code>
#include "repair.h"</code></p><p><code>
</code></p><p><code>
#ifndef RAND_MAX</code></p><p><code>
#define RAND_MAX 32767</code></p><p><code>
#endif</code></p><p><code>
</code></p><p><code>
//RAND_COUNT is number of different values that</code></p><p><code>
//rand() can return</code></p><p><code>
</code></p><p><code>
const double RAND_COUNT=double(RAND_MAX)+1.0;</code></p><p><code>
</code></p><p><code>
//Initialize geometric-distribution object</code></p><p><code>
</code></p><p><code>
geometric::geometric(double mean, int max)</code></p><p><code>
{</code></p><p><code>
	ways_to_occur=int(RAND_COUNT/mean+0.5);</code></p><p><code>
	geo_max=max;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
//Return next geometrically distributed random number</code></p><p><code>
</code></p><p><code>
int geometric::draw()</code></p><p><code>
{</code></p><p><code>
 for (int i=1;i&lt;geo_max;i++)</code></p><p><code>
	if(rand()&lt;ways_to_occur) return i;</code></p><p><code>
 return geo_max;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
Boolean geometric::e_agora(void)</code></p><p><code>
{</code></p><p><code>
return (rand()&lt;ways_to_occur);  //chances de entrar agora pela porta</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
<b></b></code></p><hr><p><code>
</code></p><p><code>
//File active.cpp</code></p><p><code>
//Source file for classes costumer and clerk</code></p><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
#include "repair.h"</code></p><p><code>
</code></p><p><code>
//Initialize costumer object and schedule first breakdown</code></p><p><code>
</code></p><p><code>
costumer::costumer(double mean,int max,scheduler* s,manager* m):g(mean,max)</code></p><p><code>
{</code></p><p><code>
 sp=s;</code></p><p><code>
 mp=m;</code></p><p><code>
 vivos++; //controle de alocacao dinamica.</code></p><p><code>
 tot_up_time=0;</code></p><p><code>
 is_up=TRUE;</code></p><p><code>
 sp-&gt;schedule(this,g.draw());</code></p><p><code>
 //up_time_start is not initialized here but when costumers enter in bank</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
//Request service for disabled costumer</code></p><p><code>
</code></p><p><code>
void costumer::event() //entering in the bank, start counting wait time</code></p><p><code>
{</code></p><p><code>
	is_up=FALSE; //not outside the bank</code></p><p><code>
	up_time_start=sp-&gt;time();</code></p><p><code>
	mp-&gt;request_service(this);  //entrou no banco, fica na fila ou vai direto
ao caixa</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
//Return repaired costumer to service</code></p><p><code>
</code></p><p><code>
void costumer::served()   //may be killed, deleted now.</code></p><p><code>
{</code></p><p><code>
	is_up=TRUE;</code></p><p><code>
	tot_up_time+=sp-&gt;time()-up_time_start;</code></p><p><code>
	waitedtime+=tot_up_time;</code></p><p><code>
	servedcost+=1;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
//Initialize clerk object and, if possible, get object's</code></p><p><code>
//First work assignment</code></p><p><code>
</code></p><p><code>
clerk::clerk(double mean,int max,scheduler* s,manager* m):g(mean,max)</code></p><p><code>
{</code></p><p><code>
	sp=s;</code></p><p><code>
	mp=m;</code></p><p><code>
	tot_busy_time=0;</code></p><p><code>
	workp=mp-&gt;request_work(this);</code></p><p><code>
	if (workp==0)</code></p><p><code>
		is_busy=FALSE;</code></p><p><code>
	else {</code></p><p><code>
		is_busy=TRUE;</code></p><p><code>
		busy_time_start=sp-&gt;time();</code></p><p><code>
		sp-&gt;schedule(this,g.draw());</code></p><p><code>
		}</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
//Complete repair on current costumer; if possible get</code></p><p><code>
//new work assignment</code></p><p><code>
</code></p><p><code>
void clerk::event()</code></p><p><code>
{</code></p><p><code>
	tot_busy_time+=sp-&gt;time()-busy_time_start;</code></p><p><code>
	workp-&gt;served(); //grava estatisticas.</code></p><p><code>
	delete workp;  //mata costumer</code></p><p><code>
	workp=mp-&gt;request_work(this);</code></p><p><code>
	if (workp==0) is_busy=FALSE;</code></p><p><code>
	else {</code></p><p><code>
			is_busy=TRUE;</code></p><p><code>
			busy_time_start=sp-&gt;time();</code></p><p><code>
			sp-&gt;schedule(this,g.draw());</code></p><p><code>
			}</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
//Acept work assignment</code></p><p><code>
</code></p><p><code>
void clerk::serve(costumer* p)</code></p><p><code>
{</code></p><p><code>
	workp=p;</code></p><p><code>
	is_busy=TRUE;</code></p><p><code>
	busy_time_start=sp-&gt;time();   //comeca contar tempo de ocupado</code></p><p><code>
	sp-&gt;schedule(this,g.draw()); //me tire do atendimente daqui a g.draw
tempos</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
//Return total busy time</code></p><p><code>
</code></p><p><code>
int clerk::busy_time()</code></p><p><code>
{</code></p><p><code>
	int t=tot_busy_time;</code></p><p><code>
	if (is_busy) t+=sp-&gt;time()-busy_time_start;</code></p><p><code>
	return t;</code></p><p><code>
}</code></p><p><code>
	</code></p><p><code>
<b></b></code></p><hr><p><code>
</code></p><p><code>
//File manager.cpp</code></p><p><code>
//Source file for class manager</code></p><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
#include "repair.h"</code></p><p><code>
</code></p><p><code>
//Handle service request from disabled costumer</code></p><p><code>
</code></p><p><code>
void manager::request_service(costumer* p)</code></p><p><code>
{</code></p><p><code>
	clerk* q;</code></p><p><code>
	switch(waiting) {</code></p><p><code>
	 case COSTUMERS:</code></p><p><code>
		insert(p);</code></p><p><code>
		return;</code></p><p><code>
	 case CLERKS:</code></p><p><code>
		q=escolhe_randomico(); //pega um clerk desocupado qualquer, ja converte
(clerk*)</code></p><p><code>
		if (first==NULL) waiting=NONE;</code></p><p><code>
		q-&gt;serve(p);</code></p><p><code>
		return;</code></p><p><code>
	 case NONE:</code></p><p><code>
		waiting=COSTUMERS;</code></p><p><code>
		insert_first(p);</code></p><p><code>
		return;</code></p><p><code>
	 }</code></p><p><code>
};</code></p><p><code>
</code></p><p><code>
//Handle work request from idle clerk</code></p><p><code>
</code></p><p><code>
costumer* manager::request_work(clerk* p)</code></p><p><code>
{</code></p><p><code>
 costumer* q;</code></p><p><code>
</code></p><p><code>
 switch (waiting){</code></p><p><code>
  case COSTUMERS:</code></p><p><code>
	q=(costumer*) first;</code></p><p><code>
	remove();</code></p><p><code>
	if (first==NULL) waiting=NONE;</code></p><p><code>
	return q;</code></p><p><code>
  case CLERKS:</code></p><p><code>
	insert(p);</code></p><p><code>
	return NULL;</code></p><p><code>
  case NONE:</code></p><p><code>
	waiting=CLERKS;</code></p><p><code>
	insert_first(p);</code></p><p><code>
	return NULL;</code></p><p><code>
  }</code></p><p><code>
  return NULL;</code></p><p><code>
}</code></p><p><code>
<b></b></code></p><p><code>
<b></b></code></p><hr><p><code>
</code></p><p><code>
//File schedule.cpp</code></p><p><code>
//Source file for class scheduler</code></p><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
#include "repair.h"</code></p><p><code>
</code></p><p><code>
//Create scheduler with calendar queue having sz elements</code></p><p><code>
</code></p><p><code>
scheduler::scheduler(int sz,front_door* fdp,manager* mngrp)</code></p><p><code>
{</code></p><p><code>
	fd=fdp; //armazena o front_door pointer</code></p><p><code>
	m=mngrp;   //armazena o manager pointer</code></p><p><code>
	clock=0;</code></p><p><code>
	calendar_size=sz;</code></p><p><code>
	calendar=new active*[sz];</code></p><p><code>
	for (int i=0;i&lt;sz;i++) calendar[i]=0;</code></p><p><code>
	index=0;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
//Schedule object *p to receive event message</code></p><p><code>
//after delay ticks have elapsed</code></p><p><code>
</code></p><p><code>
void scheduler::schedule(active* p,int delay)</code></p><p><code>
{</code></p><p><code>
	int t=index+delay;</code></p><p><code>
	if (t&gt;=calendar_size) t-=calendar_size;</code></p><p><code>
	p-&gt;set_next(calendar[t]);</code></p><p><code>
	calendar[t]=p;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
//Run simulation for given number of ticks</code></p><p><code>
</code></p><p><code>
void scheduler::run(int ticks)</code></p><p><code>
{</code></p><p><code>
	active* p;</code></p><p><code>
for (int i=0;i&lt;ticks;i++) {</code></p><p><code>
		fd-&gt;sorteia_cost(); //agenda entrada do novo costumer enquanto</code></p><p><code>
		//nao comecou a mexer em listas ainda, senao corrompe estado</code></p><p><code>
		m-&gt;tick(); //faz manager gravar estatisticas das listas</code></p><p><code>
		while((p=calendar[index])!=0)</code></p><p><code>
			{ calendar[index]=p-&gt;get_next();</code></p><p><code>
			  p-&gt;event();</code></p><p><code>
			}</code></p><p><code>
			clock++;</code></p><p><code>
			if (++index==calendar_size) index=0;</code></p><p><code>
		}</code></p><p><code>
}</code></p><p><code>
	</code></p><p><code>
<b></b></code></p><hr><p><code>
</code></p><p><code>
//File simula.cpp</code></p><p><code>
//programa demonstracao para simulacao de cliente-atendente</code></p><p><code>
</code></p><p><code>
#include &lt;iostream.h&gt;</code></p><p><code>
#include &lt;stdlib.h&gt;</code></p><p><code>
#include "repair.h"</code></p><p><code>
</code></p><p><code>
//inicializando os membros static da classe costumer</code></p><p><code>
double costumer::servedcost=0.0;</code></p><p><code>
double costumer::waitedtime=0.0;</code></p><p><code>
int costumer::vivos=0; //para controle da alocacao dinamica</code></p><p><code>
</code></p><p><code>
main()</code></p><p><code>
{</code></p><p><code>
//declaracao de variaveis obtencao de valores do usuario</code></p><p><code>
unsigned semente; //seed for rand()</code></p><p><code>
int num_adj;  //numero de clerks</code></p><p><code>
double m_mean; //tempo medio entre entradas no estabelecimento</code></p><p><code>
double a_mean; //tempo medio de atendimento</code></p><p><code>
</code></p><p><code>
cout &lt;&lt; "Numero de atendentes?";</code></p><p><code>
cin &gt;&gt; num_adj;</code></p><p><code>
cout &lt;&lt; "Tempo medio de entrada de clientes pela porta?";</code></p><p><code>
cin &gt;&gt; m_mean;</code></p><p><code>
cout &lt;&lt; "Tempo medio de servico, atendimento?";</code></p><p><code>
cin &gt;&gt; a_mean;</code></p><p><code>
cout &lt;&lt; "Semente de numeros randomicos?";</code></p><p><code>
cin &gt;&gt; semente;</code></p><p><code>
</code></p><p><code>
//Seed rand(); set max_time to ten times maximum of</code></p><p><code>
//m_mean and a_mean</code></p><p><code>
</code></p><p><code>
srand(semente);</code></p><p><code>
int max_time=10*int(m_mean&gt;a_mean?m_mean:a_mean);</code></p><p><code>
int i;</code></p><p><code>
</code></p><p><code>
//Cria manager e scheduler</code></p><p><code>
</code></p><p><code>
manager mngr;</code></p><p><code>
front_door criador;</code></p><p><code>
scheduler sch(max_time+1,&amp;criador,&amp;mngr);</code></p><p><code>
criador.init(m_mean,max_time,&amp;sch,&amp;mngr); //inicializa criador de
costumers</code></p><p><code>
//com as caracteristicas esperadas dos costumers, como nao e construtor,
posso</code></p><p><code>
//modificar as caracteristicas dos costumers durante programa.</code></p><p><code>
</code></p><p><code>
//Cria clerks</code></p><p><code>
clerk** a_list=new clerk*[num_adj];</code></p><p><code>
for (i=0;i&lt;num_adj;i++)</code></p><p><code>
	a_list[i]=new clerk(a_mean,max_time,&amp;sch,&amp;mngr);</code></p><p><code>
</code></p><p><code>
//Faz sucessivos loops da simulacao; imprime estatisticas cumulativas</code></p><p><code>
//depois de cada conjunto de iteracoes completo</code></p><p><code>
</code></p><p><code>
char ch;</code></p><p><code>
do</code></p><p><code>
	{</code></p><p><code>
	//Get number of ticks for this run</code></p><p><code>
	int duration;</code></p><p><code>
	cout &lt;&lt; "\nNumber of time steps?";</code></p><p><code>
	cin &gt;&gt; duration;</code></p><p><code>
</code></p><p><code>
	//Run duration</code></p><p><code>
</code></p><p><code>
sch.run(duration);</code></p><p><code>
</code></p><p><code>
//COMPUTA E IMPRIME TEMPO MEDIO DE FILA (por costumer)</code></p><p><code>
long tempo_medio=(costumer::g_waitedtime())/(costumer::g_servedcost());</code></p><p><code>
	cout &lt;&lt; "Tempo medio na fila:" &lt;&lt; tempo_medio &lt;&lt; endl;</code></p><p><code>
</code></p><p><code>
//computa e imprime utilizacao media dos atendentes</code></p><p><code>
</code></p><p><code>
double a_factor=100.0/double(sch.time())/double(num_adj);</code></p><p><code>
long tot_busy_time=0;</code></p><p><code>
for (i=0;i&lt;num_adj;i++)</code></p><p><code>
	tot_busy_time+=a_list[i]-&gt;busy_time();</code></p><p><code>
	cout &lt;&lt; "Media da utilizacao dos atendentes:" &lt;&lt;
tot_busy_time*a_factor&lt;&lt;"%\n";</code></p><p><code>
</code></p><p><code>
double avll; //average costumer line lenght</code></p><p><code>
avll=mngr.g_llsum()/sch.time();</code></p><p><code>
cout &lt;&lt; "Comprimento medio da fila:" &lt;&lt; avll &lt;&lt; endl;</code></p><p><code>
</code></p><p><code>
//Determine if user wants to do more runs</code></p><p><code>
</code></p><p><code>
cout &lt;&lt; "Clientes ainda nao atendidos:" &lt;&lt; costumer::vivos &lt;&lt;
endl;</code></p><p><code>
//estes ou estao na fila para serem atendidos, ou se penduraram no</code></p><p><code>
//calendar queue, e so para controle da alocacao dinamica.</code></p><p><code>
</code></p><p><code>
cout &lt;&lt; "Continue (Y/N)?";</code></p><p><code>
cin &gt;&gt; ch;</code></p><p><code>
} while (ch=='y' || ch=='y');</code></p><p><code>
</code></p><p><code>
delete []a_list;</code></p><p><code>
return 0;</code></p><p><code>
}</code></p><p><code>
</code></p><p><code>
//RESULTADOS DO PROGRAMA, A PARTIR DOS VALORES INICIAIS DO PRIMEIRO TESTE</code></p><p><code>
//(TESTE A SEGUIR) FUI VARIANDO UM PARAMETRO POR VEZ E VENDO SE O</code></p><p><code>
//RESULTADO ERA COERENTE.</code></p><p><code>
//Numero de atendentes?1</code></p><p><code>
//Tempo medio de entrada de clientes pela porta?8</code></p><p><code>
//Tempo medio de servico, atendimento?3</code></p><p><code>
//Semente de numeros randomicos?31416</code></p><p><code>
//</code></p><p><code>
//Number of time steps?5000</code></p><p><code>
//Tempo medio na fila:3</code></p><p><code>
//Media da utilizacao dos atendentes:36.14%</code></p><p><code>
//Comprimento medio da fila:0.1384</code></p><p><code>
//Clientes ainda nao atendidos:1</code></p><p><code>
//Continue (Y/N)?y</code></p><p><code>
//</code></p><p><code>
//Number of time steps?10000</code></p><p><code>
//Tempo medio na fila:4</code></p><p><code>
//Media da utilizacao dos atendentes:37.7933%</code></p><p><code>
//Comprimento medio da fila:0.153667</code></p><p><code>
//Clientes ainda nao atendidos:4</code></p><p><code>
//Continue (Y/N)?n</code></p><p><code>
//</code></p><p><code>
//Numero de atendentes?2</code></p><p><code>
//Tempo medio de entrada de clientes pela porta?8</code></p><p><code>
//Tempo medio de servico, atendimento?3</code></p><p><code>
//Semente de numeros randomicos?31416</code></p><p><code>
//</code></p><p><code>
//Number of time steps?5000</code></p><p><code>
//Tempo medio na fila:2</code></p><p><code>
//Media da utilizacao dos atendentes:18.3%</code></p><p><code>
//Comprimento medio da fila:0.0088</code></p><p><code>
//Clientes ainda nao atendidos:0</code></p><p><code>
//Continue (Y/N)?y</code></p><p><code>
//</code></p><p><code>
//Number of time steps?10000</code></p><p><code>
//Tempo medio na fila:3</code></p><p><code>
//Media da utilizacao dos atendentes:18.4033%</code></p><p><code>
//Comprimento medio da fila:0.0068</code></p><p><code>
//Clientes ainda nao atendidos:2</code></p><p><code>
//Continue (Y/N)?</code></p><p><code>
//</code></p><p><code>
//Numero de atendentes?1</code></p><p><code>
//Tempo medio de entrada de clientes pela porta?6</code></p><p><code>
//Tempo medio de servico, atendimento?3</code></p><p><code>
//Semente de numeros randomicos?31416</code></p><p><code>
//</code></p><p><code>
//Number of time steps?5000</code></p><p><code>
//Tempo medio na fila:4</code></p><p><code>
//Media da utilizacao dos atendentes:50.06%</code></p><p><code>
//Comprimento medio da fila:0.3104</code></p><p><code>
//Clientes ainda nao atendidos:0</code></p><p><code>
//Continue (Y/N)?y</code></p><p><code>
//</code></p><p><code>
//Number of time steps?10000</code></p><p><code>
//Tempo medio na fila:5</code></p><p><code>
//Media da utilizacao dos atendentes:51%</code></p><p><code>
//Comprimento medio da fila:0.356933</code></p><p><code>
//Clientes ainda nao atendidos:1</code></p><p><code>
//Continue (Y/N)?</code></p><p><code>
//</code></p><p><code>
//Numero de atendentes?1</code></p><p><code>
//Tempo medio de entrada de clientes pela porta?8</code></p><p><code>
//Tempo medio de servico, atendimento?5</code></p><p><code>
//Semente de numeros randomicos?31416</code></p><p><code>
//</code></p><p><code>
//Number of time steps?5000</code></p><p><code>
//Tempo medio na fila:11</code></p><p><code>
//Media da utilizacao dos atendentes:59.54%</code></p><p><code>
//Comprimento medio da fila:0.7616</code></p><p><code>
//Clientes ainda nao atendidos:1</code></p><p><code>
//Continue (Y/N)?y</code></p><p><code>
<b></b></code></p><hr><p><code>
</code></p><p>

<b>Conteúdo:</b></p><p>
<b></b></p><p>
<b>Bibliografia:</b></p><p>
<b></b>
<a name="ref1"></a></p><p>
[1]	Rumbaugh, Blaha M., Premerlani W., Eddy F. &amp; Lorensen W.
,"Object-Oriented Modeling and Design". Prentice Hall, 1991.    </p><p>
	       
<a name="ref2"></a></p><p>
[2]	Budd. T ,"Classical Data Structures  In C++". Addison-Wesley 1994.
</p><p>
	    
<a name="ref3"></a></p><p>
[3]	Mitchel M. ,"Data Abstraction in C++"           </p><p>
	
<a name="ref4"></a></p><p>
[4]	Graham. N.,"Learning C++". McGRAW-HILL, 1991.        </p><p>
	
<a name="ref5"></a></p><p>
[5]	 Stroustrup. B., "The C++ Programming Language". Addison-Wesley 1991.</p><p>
<a href="http://spidey.cs.rit.edu/exercises.html"> "Tutoriais e exercícios online sobre C++ e Eiffel" Departamento de ciência da computação, Rochester Institute of Technology </a>
</p><p>

</p><p>

</p></body></html>
