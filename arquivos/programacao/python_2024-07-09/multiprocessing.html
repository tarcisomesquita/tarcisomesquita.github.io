
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
>

<html>
  <head><meta charset="UTF-8" />
    <meta>
    <meta>
    <title>17.2. multiprocessing — Process-based parallelism &#8212; Python 3.6.5 documentation</title>
    <link>
    <link>
    <script></script>
    <script></script>
    <script></script>
    <script></script>
    <script></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Python 3.6.5 documentation"
>
    <link>
    <link>
    <link>
    <link>
    <link>
    <link>
    <link>
    <link>
    
    <script></script>
    <script></script>
    
    
 

  </head><body>  
    <div>
      <h3>Navigation</h3>
      <ul>
        <li>
          <a href="../genindex.html" title="General Index"
>index</a></li>
        <li>
          <a href="../py-modindex.html" title="Python Module Index"
>modules</a> |</li>
        <li>
          <a href="concurrent.html" title="17.3. The concurrent package"
>next</a> |</li>
        <li>
          <a href="threading.html" title="17.1. threading — Thread-based parallelism"
>previous</a> |</li>
        <li><img src="../_static/py.png" alt=""
      ></li>
        <li><a>Python</a> &#187;</li>
        <li>
          <span>en</span>
          <span>3.6.5</span>
          <a>Documentation </a> &#187;
        </li>

          <li><a>The Python Standard Library</a> &#187;</li>
          <li><a>17. Concurrent Execution</a> &#187;</li>
    <li>
        

    <div>
        <form>
          <input>
          <input>
          <input>
          <input>
        </form>
    </div>
    <script>$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div>
      <div>
        <div>
          <div>
            
  <div>
<span></span><h1>17.2. <a><code><span>multiprocessing</span></code></a> — Process-based parallelism<a>¶</a></h1>
<p><strong>Source code:</strong> <a>Lib/multiprocessing/</a></p>
<hr>
<div>
<h2>17.2.1. Introduction<a>¶</a></h2>
<p><a><code><span>multiprocessing</span></code></a> is a package that supports spawning processes using an
API similar to the <a><code><span>threading</span></code></a> module.  The <a><code><span>multiprocessing</span></code></a> package
offers both local and remote concurrency, effectively side-stepping the
<a><span>Global Interpreter Lock</span></a> by using subprocesses instead of threads.  Due
to this, the <a><code><span>multiprocessing</span></code></a> module allows the programmer to fully
leverage multiple processors on a given machine.  It runs on both Unix and
Windows.</p>
<p>The <a><code><span>multiprocessing</span></code></a> module also introduces APIs which do not have
analogs in the <a><code><span>threading</span></code></a> module.  A prime example of this is the
<a><code><span>Pool</span></code></a> object which offers a convenient means of
parallelizing the execution of a function across multiple input values,
distributing the input data across processes (data parallelism).  The following
example demonstrates the common practice of defining such functions in a module
so that child processes can successfully import that module.  This basic example
of data parallelism using <a><code><span>Pool</span></code></a>,</p>
<div><div><pre><span></span><span>from</span> <span>multiprocessing</span> <span>import</span> <span>Pool</span>

<span>def</span> <span>f</span><span>(</span><span>x</span><span>):</span>
    <span>return</span> <span>x</span><span>*</span><span>x</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#39;__main__&#39;</span><span>:</span>
    <span>with</span> <span>Pool</span><span>(</span><span>5</span><span>)</span> <span>as</span> <span>p</span><span>:</span>
        <span>print</span><span>(</span><span>p</span><span>.</span><span>map</span><span>(</span><span>f</span><span>,</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]))</span>
</pre></div>
</div>
<p>will print to standard output</p>
<div><div><pre><span></span><span>[</span><span>1</span><span>,</span> <span>4</span><span>,</span> <span>9</span><span>]</span>
</pre></div>
</div>
<div>
<h3>17.2.1.1. The <a><code><span>Process</span></code></a> class<a>¶</a></h3>
<p>In <a><code><span>multiprocessing</span></code></a>, processes are spawned by creating a <a><code><span>Process</span></code></a>
object and then calling its <a><code><span>start()</span></code></a> method.  <a><code><span>Process</span></code></a>
follows the API of <a><code><span>threading.Thread</span></code></a>.  A trivial example of a
multiprocess program is</p>
<div><div><pre><span></span><span>from</span> <span>multiprocessing</span> <span>import</span> <span>Process</span>

<span>def</span> <span>f</span><span>(</span><span>name</span><span>):</span>
    <span>print</span><span>(</span><span>&#39;hello&#39;</span><span>,</span> <span>name</span><span>)</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#39;__main__&#39;</span><span>:</span>
    <span>p</span> <span>=</span> <span>Process</span><span>(</span><span>target</span><span>=</span><span>f</span><span>,</span> <span>args</span><span>=</span><span>(</span><span>&#39;bob&#39;</span><span>,))</span>
    <span>p</span><span>.</span><span>start</span><span>()</span>
    <span>p</span><span>.</span><span>join</span><span>()</span>
</pre></div>
</div>
<p>To show the individual process IDs involved, here is an expanded example:</p>
<div><div><pre><span></span><span>from</span> <span>multiprocessing</span> <span>import</span> <span>Process</span>
<span>import</span> <span>os</span>

<span>def</span> <span>info</span><span>(</span><span>title</span><span>):</span>
    <span>print</span><span>(</span><span>title</span><span>)</span>
    <span>print</span><span>(</span><span>&#39;module name:&#39;</span><span>,</span> <span>__name__</span><span>)</span>
    <span>print</span><span>(</span><span>&#39;parent process:&#39;</span><span>,</span> <span>os</span><span>.</span><span>getppid</span><span>())</span>
    <span>print</span><span>(</span><span>&#39;process id:&#39;</span><span>,</span> <span>os</span><span>.</span><span>getpid</span><span>())</span>

<span>def</span> <span>f</span><span>(</span><span>name</span><span>):</span>
    <span>info</span><span>(</span><span>&#39;function f&#39;</span><span>)</span>
    <span>print</span><span>(</span><span>&#39;hello&#39;</span><span>,</span> <span>name</span><span>)</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#39;__main__&#39;</span><span>:</span>
    <span>info</span><span>(</span><span>&#39;main line&#39;</span><span>)</span>
    <span>p</span> <span>=</span> <span>Process</span><span>(</span><span>target</span><span>=</span><span>f</span><span>,</span> <span>args</span><span>=</span><span>(</span><span>&#39;bob&#39;</span><span>,))</span>
    <span>p</span><span>.</span><span>start</span><span>()</span>
    <span>p</span><span>.</span><span>join</span><span>()</span>
</pre></div>
</div>
<p>For an explanation of why the <code><span>if</span> <span>__name__</span> <span>==</span> <span>'__main__'</span></code> part is
necessary, see <a><span>Programming guidelines</span></a>.</p>
</div>
<div>
<h3>17.2.1.2. Contexts and start methods<a>¶</a></h3>
<p>Depending on the platform, <a><code><span>multiprocessing</span></code></a> supports three ways
to start a process.  These <em>start methods</em> are</p>
<blockquote>
<div><dl>
<dt><em>spawn</em></dt>
<dd><p>The parent process starts a fresh python interpreter process.  The
child process will only inherit those resources necessary to run
the process objects <a><code><span>run()</span></code></a> method.  In particular,
unnecessary file descriptors and handles from the parent process
will not be inherited.  Starting a process using this method is
rather slow compared to using <em>fork</em> or <em>forkserver</em>.</p>
<p>Available on Unix and Windows.  The default on Windows.</p>
</dd>
<dt><em>fork</em></dt>
<dd><p>The parent process uses <a><code><span>os.fork()</span></code></a> to fork the Python
interpreter.  The child process, when it begins, is effectively
identical to the parent process.  All resources of the parent are
inherited by the child process.  Note that safely forking a
multithreaded process is problematic.</p>
<p>Available on Unix only.  The default on Unix.</p>
</dd>
<dt><em>forkserver</em></dt>
<dd><p>When the program starts and selects the <em>forkserver</em> start method,
a server process is started.  From then on, whenever a new process
is needed, the parent process connects to the server and requests
that it fork a new process.  The fork server process is single
threaded so it is safe for it to use <a><code><span>os.fork()</span></code></a>.  No
unnecessary resources are inherited.</p>
<p>Available on Unix platforms which support passing file descriptors
over Unix pipes.</p>
</dd>
</dl>
</div></blockquote>
<div>
<p><span>Changed in version 3.4: </span><em>spawn</em> added on all unix platforms, and <em>forkserver</em> added for
some unix platforms.
Child processes no longer inherit all of the parents inheritable
handles on Windows.</p>
</div>
<p>On Unix using the <em>spawn</em> or <em>forkserver</em> start methods will also
start a <em>semaphore tracker</em> process which tracks the unlinked named
semaphores created by processes of the program.  When all processes
have exited the semaphore tracker unlinks any remaining semaphores.
Usually there should be none, but if a process was killed by a signal
there may some “leaked” semaphores.  (Unlinking the named semaphores
is a serious matter since the system allows only a limited number, and
they will not be automatically unlinked until the next reboot.)</p>
<p>To select a start method you use the <a><code><span>set_start_method()</span></code></a> in
the <code><span>if</span> <span>__name__</span> <span>==</span> <span>'__main__'</span></code> clause of the main module.  For
example:</p>
<div><div><pre><span></span><span>import</span> <span>multiprocessing</span> <span>as</span> <span>mp</span>

<span>def</span> <span>foo</span><span>(</span><span>q</span><span>):</span>
    <span>q</span><span>.</span><span>put</span><span>(</span><span>&#39;hello&#39;</span><span>)</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#39;__main__&#39;</span><span>:</span>
    <span>mp</span><span>.</span><span>set_start_method</span><span>(</span><span>&#39;spawn&#39;</span><span>)</span>
    <span>q</span> <span>=</span> <span>mp</span><span>.</span><span>Queue</span><span>()</span>
    <span>p</span> <span>=</span> <span>mp</span><span>.</span><span>Process</span><span>(</span><span>target</span><span>=</span><span>foo</span><span>,</span> <span>args</span><span>=</span><span>(</span><span>q</span><span>,))</span>
    <span>p</span><span>.</span><span>start</span><span>()</span>
    <span>print</span><span>(</span><span>q</span><span>.</span><span>get</span><span>())</span>
    <span>p</span><span>.</span><span>join</span><span>()</span>
</pre></div>
</div>
<p><a><code><span>set_start_method()</span></code></a> should not be used more than once in the
program.</p>
<p>Alternatively, you can use <a><code><span>get_context()</span></code></a> to obtain a context
object.  Context objects have the same API as the multiprocessing
module, and allow one to use multiple start methods in the same
program.</p>
<div><div><pre><span></span><span>import</span> <span>multiprocessing</span> <span>as</span> <span>mp</span>

<span>def</span> <span>foo</span><span>(</span><span>q</span><span>):</span>
    <span>q</span><span>.</span><span>put</span><span>(</span><span>&#39;hello&#39;</span><span>)</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#39;__main__&#39;</span><span>:</span>
    <span>ctx</span> <span>=</span> <span>mp</span><span>.</span><span>get_context</span><span>(</span><span>&#39;spawn&#39;</span><span>)</span>
    <span>q</span> <span>=</span> <span>ctx</span><span>.</span><span>Queue</span><span>()</span>
    <span>p</span> <span>=</span> <span>ctx</span><span>.</span><span>Process</span><span>(</span><span>target</span><span>=</span><span>foo</span><span>,</span> <span>args</span><span>=</span><span>(</span><span>q</span><span>,))</span>
    <span>p</span><span>.</span><span>start</span><span>()</span>
    <span>print</span><span>(</span><span>q</span><span>.</span><span>get</span><span>())</span>
    <span>p</span><span>.</span><span>join</span><span>()</span>
</pre></div>
</div>
<p>Note that objects related to one context may not be compatible with
processes for a different context.  In particular, locks created using
the <em>fork</em> context cannot be passed to a processes started using the
<em>spawn</em> or <em>forkserver</em> start methods.</p>
<p>A library which wants to use a particular start method should probably
use <a><code><span>get_context()</span></code></a> to avoid interfering with the choice of the
library user.</p>
</div>
<div>
<h3>17.2.1.3. Exchanging objects between processes<a>¶</a></h3>
<p><a><code><span>multiprocessing</span></code></a> supports two types of communication channel between
processes:</p>
<p><strong>Queues</strong></p>
<blockquote>
<div><p>The <a><code><span>Queue</span></code></a> class is a near clone of <a><code><span>queue.Queue</span></code></a>.  For
example:</p>
<div><div><pre><span></span><span>from</span> <span>multiprocessing</span> <span>import</span> <span>Process</span><span>,</span> <span>Queue</span>

<span>def</span> <span>f</span><span>(</span><span>q</span><span>):</span>
    <span>q</span><span>.</span><span>put</span><span>([</span><span>42</span><span>,</span> <span>None</span><span>,</span> <span>&#39;hello&#39;</span><span>])</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#39;__main__&#39;</span><span>:</span>
    <span>q</span> <span>=</span> <span>Queue</span><span>()</span>
    <span>p</span> <span>=</span> <span>Process</span><span>(</span><span>target</span><span>=</span><span>f</span><span>,</span> <span>args</span><span>=</span><span>(</span><span>q</span><span>,))</span>
    <span>p</span><span>.</span><span>start</span><span>()</span>
    <span>print</span><span>(</span><span>q</span><span>.</span><span>get</span><span>())</span>    <span># prints &quot;[42, None, &#39;hello&#39;]&quot;</span>
    <span>p</span><span>.</span><span>join</span><span>()</span>
</pre></div>
</div>
<p>Queues are thread and process safe.</p>
</div></blockquote>
<p><strong>Pipes</strong></p>
<blockquote>
<div><p>The <a><code><span>Pipe()</span></code></a> function returns a pair of connection objects connected by a
pipe which by default is duplex (two-way).  For example:</p>
<div><div><pre><span></span><span>from</span> <span>multiprocessing</span> <span>import</span> <span>Process</span><span>,</span> <span>Pipe</span>

<span>def</span> <span>f</span><span>(</span><span>conn</span><span>):</span>
    <span>conn</span><span>.</span><span>send</span><span>([</span><span>42</span><span>,</span> <span>None</span><span>,</span> <span>&#39;hello&#39;</span><span>])</span>
    <span>conn</span><span>.</span><span>close</span><span>()</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#39;__main__&#39;</span><span>:</span>
    <span>parent_conn</span><span>,</span> <span>child_conn</span> <span>=</span> <span>Pipe</span><span>()</span>
    <span>p</span> <span>=</span> <span>Process</span><span>(</span><span>target</span><span>=</span><span>f</span><span>,</span> <span>args</span><span>=</span><span>(</span><span>child_conn</span><span>,))</span>
    <span>p</span><span>.</span><span>start</span><span>()</span>
    <span>print</span><span>(</span><span>parent_conn</span><span>.</span><span>recv</span><span>())</span>   <span># prints &quot;[42, None, &#39;hello&#39;]&quot;</span>
    <span>p</span><span>.</span><span>join</span><span>()</span>
</pre></div>
</div>
<p>The two connection objects returned by <a><code><span>Pipe()</span></code></a> represent the two ends of
the pipe.  Each connection object has <code><span>send()</span></code> and
<code><span>recv()</span></code> methods (among others).  Note that data in a pipe
may become corrupted if two processes (or threads) try to read from or write
to the <em>same</em> end of the pipe at the same time.  Of course there is no risk
of corruption from processes using different ends of the pipe at the same
time.</p>
</div></blockquote>
</div>
<div>
<h3>17.2.1.4. Synchronization between processes<a>¶</a></h3>
<p><a><code><span>multiprocessing</span></code></a> contains equivalents of all the synchronization
primitives from <a><code><span>threading</span></code></a>.  For instance one can use a lock to ensure
that only one process prints to standard output at a time:</p>
<div><div><pre><span></span><span>from</span> <span>multiprocessing</span> <span>import</span> <span>Process</span><span>,</span> <span>Lock</span>

<span>def</span> <span>f</span><span>(</span><span>l</span><span>,</span> <span>i</span><span>):</span>
    <span>l</span><span>.</span><span>acquire</span><span>()</span>
    <span>try</span><span>:</span>
        <span>print</span><span>(</span><span>&#39;hello world&#39;</span><span>,</span> <span>i</span><span>)</span>
    <span>finally</span><span>:</span>
        <span>l</span><span>.</span><span>release</span><span>()</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#39;__main__&#39;</span><span>:</span>
    <span>lock</span> <span>=</span> <span>Lock</span><span>()</span>

    <span>for</span> <span>num</span> <span>in</span> <span>range</span><span>(</span><span>10</span><span>):</span>
        <span>Process</span><span>(</span><span>target</span><span>=</span><span>f</span><span>,</span> <span>args</span><span>=</span><span>(</span><span>lock</span><span>,</span> <span>num</span><span>))</span><span>.</span><span>start</span><span>()</span>
</pre></div>
</div>
<p>Without using the lock output from the different processes is liable to get all
mixed up.</p>
</div>
<div>
<h3>17.2.1.5. Sharing state between processes<a>¶</a></h3>
<p>As mentioned above, when doing concurrent programming it is usually best to
avoid using shared state as far as possible.  This is particularly true when
using multiple processes.</p>
<p>However, if you really do need to use some shared data then
<a><code><span>multiprocessing</span></code></a> provides a couple of ways of doing so.</p>
<p><strong>Shared memory</strong></p>
<blockquote>
<div><p>Data can be stored in a shared memory map using <a><code><span>Value</span></code></a> or
<a><code><span>Array</span></code></a>.  For example, the following code</p>
<div><div><pre><span></span><span>from</span> <span>multiprocessing</span> <span>import</span> <span>Process</span><span>,</span> <span>Value</span><span>,</span> <span>Array</span>

<span>def</span> <span>f</span><span>(</span><span>n</span><span>,</span> <span>a</span><span>):</span>
    <span>n</span><span>.</span><span>value</span> <span>=</span> <span>3.1415927</span>
    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>len</span><span>(</span><span>a</span><span>)):</span>
        <span>a</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>-</span><span>a</span><span>[</span><span>i</span><span>]</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#39;__main__&#39;</span><span>:</span>
    <span>num</span> <span>=</span> <span>Value</span><span>(</span><span>&#39;d&#39;</span><span>,</span> <span>0.0</span><span>)</span>
    <span>arr</span> <span>=</span> <span>Array</span><span>(</span><span>&#39;i&#39;</span><span>,</span> <span>range</span><span>(</span><span>10</span><span>))</span>

    <span>p</span> <span>=</span> <span>Process</span><span>(</span><span>target</span><span>=</span><span>f</span><span>,</span> <span>args</span><span>=</span><span>(</span><span>num</span><span>,</span> <span>arr</span><span>))</span>
    <span>p</span><span>.</span><span>start</span><span>()</span>
    <span>p</span><span>.</span><span>join</span><span>()</span>

    <span>print</span><span>(</span><span>num</span><span>.</span><span>value</span><span>)</span>
    <span>print</span><span>(</span><span>arr</span><span>[:])</span>
</pre></div>
</div>
<p>will print</p>
<div><div><pre><span></span><span>3.1415927</span>
<span>[</span><span>0</span><span>,</span> <span>-</span><span>1</span><span>,</span> <span>-</span><span>2</span><span>,</span> <span>-</span><span>3</span><span>,</span> <span>-</span><span>4</span><span>,</span> <span>-</span><span>5</span><span>,</span> <span>-</span><span>6</span><span>,</span> <span>-</span><span>7</span><span>,</span> <span>-</span><span>8</span><span>,</span> <span>-</span><span>9</span><span>]</span>
</pre></div>
</div>
<p>The <code><span>'d'</span></code> and <code><span>'i'</span></code> arguments used when creating <code><span>num</span></code> and <code><span>arr</span></code> are
typecodes of the kind used by the <a><code><span>array</span></code></a> module: <code><span>'d'</span></code> indicates a
double precision float and <code><span>'i'</span></code> indicates a signed integer.  These shared
objects will be process and thread-safe.</p>
<p>For more flexibility in using shared memory one can use the
<a><code><span>multiprocessing.sharedctypes</span></code></a> module which supports the creation of
arbitrary ctypes objects allocated from shared memory.</p>
</div></blockquote>
<p><strong>Server process</strong></p>
<blockquote>
<div><p>A manager object returned by <code><span>Manager()</span></code> controls a server process which
holds Python objects and allows other processes to manipulate them using
proxies.</p>
<p>A manager returned by <code><span>Manager()</span></code> will support types
<a><code><span>list</span></code></a>, <a><code><span>dict</span></code></a>, <a><code><span>Namespace</span></code></a>, <a><code><span>Lock</span></code></a>,
<a><code><span>RLock</span></code></a>, <a><code><span>Semaphore</span></code></a>, <a><code><span>BoundedSemaphore</span></code></a>,
<a><code><span>Condition</span></code></a>, <a><code><span>Event</span></code></a>, <a><code><span>Barrier</span></code></a>,
<a><code><span>Queue</span></code></a>, <a><code><span>Value</span></code></a> and <a><code><span>Array</span></code></a>.  For example,</p>
<div><div><pre><span></span><span>from</span> <span>multiprocessing</span> <span>import</span> <span>Process</span><span>,</span> <span>Manager</span>

<span>def</span> <span>f</span><span>(</span><span>d</span><span>,</span> <span>l</span><span>):</span>
    <span>d</span><span>[</span><span>1</span><span>]</span> <span>=</span> <span>&#39;1&#39;</span>
    <span>d</span><span>[</span><span>&#39;2&#39;</span><span>]</span> <span>=</span> <span>2</span>
    <span>d</span><span>[</span><span>0.25</span><span>]</span> <span>=</span> <span>None</span>
    <span>l</span><span>.</span><span>reverse</span><span>()</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#39;__main__&#39;</span><span>:</span>
    <span>with</span> <span>Manager</span><span>()</span> <span>as</span> <span>manager</span><span>:</span>
        <span>d</span> <span>=</span> <span>manager</span><span>.</span><span>dict</span><span>()</span>
        <span>l</span> <span>=</span> <span>manager</span><span>.</span><span>list</span><span>(</span><span>range</span><span>(</span><span>10</span><span>))</span>

        <span>p</span> <span>=</span> <span>Process</span><span>(</span><span>target</span><span>=</span><span>f</span><span>,</span> <span>args</span><span>=</span><span>(</span><span>d</span><span>,</span> <span>l</span><span>))</span>
        <span>p</span><span>.</span><span>start</span><span>()</span>
        <span>p</span><span>.</span><span>join</span><span>()</span>

        <span>print</span><span>(</span><span>d</span><span>)</span>
        <span>print</span><span>(</span><span>l</span><span>)</span>
</pre></div>
</div>
<p>will print</p>
<div><div><pre><span></span><span>{</span><span>0.25</span><span>:</span> <span>None</span><span>,</span> <span>1</span><span>:</span> <span>&#39;1&#39;</span><span>,</span> <span>&#39;2&#39;</span><span>:</span> <span>2</span><span>}</span>
<span>[</span><span>9</span><span>,</span> <span>8</span><span>,</span> <span>7</span><span>,</span> <span>6</span><span>,</span> <span>5</span><span>,</span> <span>4</span><span>,</span> <span>3</span><span>,</span> <span>2</span><span>,</span> <span>1</span><span>,</span> <span>0</span><span>]</span>
</pre></div>
</div>
<p>Server process managers are more flexible than using shared memory objects
because they can be made to support arbitrary object types.  Also, a single
manager can be shared by processes on different computers over a network.
They are, however, slower than using shared memory.</p>
</div></blockquote>
</div>
<div>
<h3>17.2.1.6. Using a pool of workers<a>¶</a></h3>
<p>The <a><code><span>Pool</span></code></a> class represents a pool of worker
processes.  It has methods which allows tasks to be offloaded to the worker
processes in a few different ways.</p>
<p>For example:</p>
<div><div><pre><span></span><span>from</span> <span>multiprocessing</span> <span>import</span> <span>Pool</span><span>,</span> <span>TimeoutError</span>
<span>import</span> <span>time</span>
<span>import</span> <span>os</span>

<span>def</span> <span>f</span><span>(</span><span>x</span><span>):</span>
    <span>return</span> <span>x</span><span>*</span><span>x</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#39;__main__&#39;</span><span>:</span>
    <span># start 4 worker processes</span>
    <span>with</span> <span>Pool</span><span>(</span><span>processes</span><span>=</span><span>4</span><span>)</span> <span>as</span> <span>pool</span><span>:</span>

        <span># print &quot;[0, 1, 4,..., 81]&quot;</span>
        <span>print</span><span>(</span><span>pool</span><span>.</span><span>map</span><span>(</span><span>f</span><span>,</span> <span>range</span><span>(</span><span>10</span><span>)))</span>

        <span># print same numbers in arbitrary order</span>
        <span>for</span> <span>i</span> <span>in</span> <span>pool</span><span>.</span><span>imap_unordered</span><span>(</span><span>f</span><span>,</span> <span>range</span><span>(</span><span>10</span><span>)):</span>
            <span>print</span><span>(</span><span>i</span><span>)</span>

        <span># evaluate &quot;f(20)&quot; asynchronously</span>
        <span>res</span> <span>=</span> <span>pool</span><span>.</span><span>apply_async</span><span>(</span><span>f</span><span>,</span> <span>(</span><span>20</span><span>,))</span>      <span># runs in *only* one process</span>
        <span>print</span><span>(</span><span>res</span><span>.</span><span>get</span><span>(</span><span>timeout</span><span>=</span><span>1</span><span>))</span>             <span># prints &quot;400&quot;</span>

        <span># evaluate &quot;os.getpid()&quot; asynchronously</span>
        <span>res</span> <span>=</span> <span>pool</span><span>.</span><span>apply_async</span><span>(</span><span>os</span><span>.</span><span>getpid</span><span>,</span> <span>())</span> <span># runs in *only* one process</span>
        <span>print</span><span>(</span><span>res</span><span>.</span><span>get</span><span>(</span><span>timeout</span><span>=</span><span>1</span><span>))</span>             <span># prints the PID of that process</span>

        <span># launching multiple evaluations asynchronously *may* use more processes</span>
        <span>multiple_results</span> <span>=</span> <span>[</span><span>pool</span><span>.</span><span>apply_async</span><span>(</span><span>os</span><span>.</span><span>getpid</span><span>,</span> <span>())</span> <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>4</span><span>)]</span>
        <span>print</span><span>([</span><span>res</span><span>.</span><span>get</span><span>(</span><span>timeout</span><span>=</span><span>1</span><span>)</span> <span>for</span> <span>res</span> <span>in</span> <span>multiple_results</span><span>])</span>

        <span># make a single worker sleep for 10 secs</span>
        <span>res</span> <span>=</span> <span>pool</span><span>.</span><span>apply_async</span><span>(</span><span>time</span><span>.</span><span>sleep</span><span>,</span> <span>(</span><span>10</span><span>,))</span>
        <span>try</span><span>:</span>
            <span>print</span><span>(</span><span>res</span><span>.</span><span>get</span><span>(</span><span>timeout</span><span>=</span><span>1</span><span>))</span>
        <span>except</span> <span>TimeoutError</span><span>:</span>
            <span>print</span><span>(</span><span>&quot;We lacked patience and got a multiprocessing.TimeoutError&quot;</span><span>)</span>

        <span>print</span><span>(</span><span>&quot;For the moment, the pool remains available for more work&quot;</span><span>)</span>

    <span># exiting the &#39;with&#39;-block has stopped the pool</span>
    <span>print</span><span>(</span><span>&quot;Now the pool is closed and no longer available&quot;</span><span>)</span>
</pre></div>
</div>
<p>Note that the methods of a pool should only ever be used by the
process which created it.</p>
<div>
<p>Note</p>
<p>Functionality within this package requires that the <code><span>__main__</span></code> module be
importable by the children. This is covered in <a><span>Programming guidelines</span></a>
however it is worth pointing out here. This means that some examples, such
as the <a><code><span>multiprocessing.pool.Pool</span></code></a> examples will not work in the
interactive interpreter. For example:</p>
<div><div><pre><span></span><span>&gt;&gt;&gt; </span><span>from</span> <span>multiprocessing</span> <span>import</span> <span>Pool</span>
<span>&gt;&gt;&gt; </span><span>p</span> <span>=</span> <span>Pool</span><span>(</span><span>5</span><span>)</span>
<span>&gt;&gt;&gt; </span><span>def</span> <span>f</span><span>(</span><span>x</span><span>):</span>
<span>... </span>    <span>return</span> <span>x</span><span>*</span><span>x</span>
<span>...</span>
<span>&gt;&gt;&gt; </span><span>p</span><span>.</span><span>map</span><span>(</span><span>f</span><span>,</span> <span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>])</span>
<span>Process PoolWorker-1:</span>
<span>Process PoolWorker-2:</span>
<span>Process PoolWorker-3:</span>
<span>Traceback (most recent call last):</span>
<span>AttributeError</span>: <span>&#39;module&#39; object has no attribute &#39;f&#39;</span>
<span>AttributeError: &#39;module&#39; object has no attribute &#39;f&#39;</span>
<span>AttributeError: &#39;module&#39; object has no attribute &#39;f&#39;</span>
</pre></div>
</div>
<p>(If you try this it will actually output three full tracebacks
interleaved in a semi-random fashion, and then you may have to
stop the master process somehow.)</p>
</div>
</div>
</div>
<div>
<h2>17.2.2. Reference<a>¶</a></h2>
<p>The <a><code><span>multiprocessing</span></code></a> package mostly replicates the API of the
<a><code><span>threading</span></code></a> module.</p>
<div>
<h3>17.2.2.1. <a><code><span>Process</span></code></a> and exceptions<a>¶</a></h3>
<dl>
<dt>
<em>class </em><code>multiprocessing.</code><code>Process</code><span>(</span><em>group=None</em>, <em>target=None</em>, <em>name=None</em>, <em>args=()</em>, <em>kwargs={}</em>, <em>*</em>, <em>daemon=None</em><span>)</span><a>¶</a></dt>
<dd><p>Process objects represent activity that is run in a separate process. The
<a><code><span>Process</span></code></a> class has equivalents of all the methods of
<a><code><span>threading.Thread</span></code></a>.</p>
<p>The constructor should always be called with keyword arguments. <em>group</em>
should always be <code><span>None</span></code>; it exists solely for compatibility with
<a><code><span>threading.Thread</span></code></a>.  <em>target</em> is the callable object to be invoked by
the <a><code><span>run()</span></code></a> method.  It defaults to <code><span>None</span></code>, meaning nothing is
called. <em>name</em> is the process name (see <a><code><span>name</span></code></a> for more details).
<em>args</em> is the argument tuple for the target invocation.  <em>kwargs</em> is a
dictionary of keyword arguments for the target invocation.  If provided,
the keyword-only <em>daemon</em> argument sets the process <a><code><span>daemon</span></code></a> flag
to <code><span>True</span></code> or <code><span>False</span></code>.  If <code><span>None</span></code> (the default), this flag will be
inherited from the creating process.</p>
<p>By default, no arguments are passed to <em>target</em>.</p>
<p>If a subclass overrides the constructor, it must make sure it invokes the
base class constructor (<code><span>Process.__init__()</span></code>) before doing anything else
to the process.</p>
<div>
<p><span>Changed in version 3.3: </span>Added the <em>daemon</em> argument.</p>
</div>
<dl>
<dt>
<code>run</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Method representing the process’s activity.</p>
<p>You may override this method in a subclass.  The standard <a><code><span>run()</span></code></a>
method invokes the callable object passed to the object’s constructor as
the target argument, if any, with sequential and keyword arguments taken
from the <em>args</em> and <em>kwargs</em> arguments, respectively.</p>
</dd></dl>

<dl>
<dt>
<code>start</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Start the process’s activity.</p>
<p>This must be called at most once per process object.  It arranges for the
object’s <a><code><span>run()</span></code></a> method to be invoked in a separate process.</p>
</dd></dl>

<dl>
<dt>
<code>join</code><span>(</span><span>[</span><em>timeout</em><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>If the optional argument <em>timeout</em> is <code><span>None</span></code> (the default), the method
blocks until the process whose <a><code><span>join()</span></code></a> method is called terminates.
If <em>timeout</em> is a positive number, it blocks at most <em>timeout</em> seconds.
Note that the method returns <code><span>None</span></code> if its process terminates or if the
method times out.  Check the process’s <a><code><span>exitcode</span></code></a> to determine if
it terminated.</p>
<p>A process can be joined many times.</p>
<p>A process cannot join itself because this would cause a deadlock.  It is
an error to attempt to join a process before it has been started.</p>
</dd></dl>

<dl>
<dt>
<code>name</code><a>¶</a></dt>
<dd><p>The process’s name.  The name is a string used for identification purposes
only.  It has no semantics.  Multiple processes may be given the same
name.</p>
<p>The initial name is set by the constructor.  If no explicit name is
provided to the constructor, a name of the form
‘Process-N<sub>1</sub>:N<sub>2</sub>:…:N<sub>k</sub>’ is constructed, where
each N<sub>k</sub> is the N-th child of its parent.</p>
</dd></dl>

<dl>
<dt>
<code>is_alive</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Return whether the process is alive.</p>
<p>Roughly, a process object is alive from the moment the <a><code><span>start()</span></code></a>
method returns until the child process terminates.</p>
</dd></dl>

<dl>
<dt>
<code>daemon</code><a>¶</a></dt>
<dd><p>The process’s daemon flag, a Boolean value.  This must be set before
<a><code><span>start()</span></code></a> is called.</p>
<p>The initial value is inherited from the creating process.</p>
<p>When a process exits, it attempts to terminate all of its daemonic child
processes.</p>
<p>Note that a daemonic process is not allowed to create child processes.
Otherwise a daemonic process would leave its children orphaned if it gets
terminated when its parent process exits. Additionally, these are <strong>not</strong>
Unix daemons or services, they are normal processes that will be
terminated (and not joined) if non-daemonic processes have exited.</p>
</dd></dl>

<p>In addition to the  <a><code><span>threading.Thread</span></code></a> API, <a><code><span>Process</span></code></a> objects
also support the following attributes and methods:</p>
<dl>
<dt>
<code>pid</code><a>¶</a></dt>
<dd><p>Return the process ID.  Before the process is spawned, this will be
<code><span>None</span></code>.</p>
</dd></dl>

<dl>
<dt>
<code>exitcode</code><a>¶</a></dt>
<dd><p>The child’s exit code.  This will be <code><span>None</span></code> if the process has not yet
terminated.  A negative value <em>-N</em> indicates that the child was terminated
by signal <em>N</em>.</p>
</dd></dl>

<dl>
<dt>
<code>authkey</code><a>¶</a></dt>
<dd><p>The process’s authentication key (a byte string).</p>
<p>When <a><code><span>multiprocessing</span></code></a> is initialized the main process is assigned a
random string using <a><code><span>os.urandom()</span></code></a>.</p>
<p>When a <a><code><span>Process</span></code></a> object is created, it will inherit the
authentication key of its parent process, although this may be changed by
setting <a><code><span>authkey</span></code></a> to another byte string.</p>
<p>See <a><span>Authentication keys</span></a>.</p>
</dd></dl>

<dl>
<dt>
<code>sentinel</code><a>¶</a></dt>
<dd><p>A numeric handle of a system object which will become “ready” when
the process ends.</p>
<p>You can use this value if you want to wait on several events at
once using <a><code><span>multiprocessing.connection.wait()</span></code></a>.  Otherwise
calling <a><code><span>join()</span></code></a> is simpler.</p>
<p>On Windows, this is an OS handle usable with the <code><span>WaitForSingleObject</span></code>
and <code><span>WaitForMultipleObjects</span></code> family of API calls.  On Unix, this is
a file descriptor usable with primitives from the <a><code><span>select</span></code></a> module.</p>
<div>
<p><span>New in version 3.3.</span></p>
</div>
</dd></dl>

<dl>
<dt>
<code>terminate</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Terminate the process.  On Unix this is done using the <code><span>SIGTERM</span></code> signal;
on Windows <code><span>TerminateProcess()</span></code> is used.  Note that exit handlers and
finally clauses, etc., will not be executed.</p>
<p>Note that descendant processes of the process will <em>not</em> be terminated –
they will simply become orphaned.</p>
<div>
<p>Warning</p>
<p>If this method is used when the associated process is using a pipe or
queue then the pipe or queue is liable to become corrupted and may
become unusable by other process.  Similarly, if the process has
acquired a lock or semaphore etc. then terminating it is liable to
cause other processes to deadlock.</p>
</div>
</dd></dl>

<p>Note that the <a><code><span>start()</span></code></a>, <a><code><span>join()</span></code></a>, <a><code><span>is_alive()</span></code></a>,
<a><code><span>terminate()</span></code></a> and <a><code><span>exitcode</span></code></a> methods should only be called by
the process that created the process object.</p>
<p>Example usage of some of the methods of <a><code><span>Process</span></code></a>:</p>
<div><div><pre><span></span><span>&gt;&gt;&gt; </span><span>import</span> <span>multiprocessing</span><span>,</span> <span>time</span><span>,</span> <span>signal</span>
<span>&gt;&gt;&gt; </span><span>p</span> <span>=</span> <span>multiprocessing</span><span>.</span><span>Process</span><span>(</span><span>target</span><span>=</span><span>time</span><span>.</span><span>sleep</span><span>,</span> <span>args</span><span>=</span><span>(</span><span>1000</span><span>,))</span>
<span>&gt;&gt;&gt; </span><span>print</span><span>(</span><span>p</span><span>,</span> <span>p</span><span>.</span><span>is_alive</span><span>())</span>
<span>&lt;Process(Process-1, initial)&gt; False</span>
<span>&gt;&gt;&gt; </span><span>p</span><span>.</span><span>start</span><span>()</span>
<span>&gt;&gt;&gt; </span><span>print</span><span>(</span><span>p</span><span>,</span> <span>p</span><span>.</span><span>is_alive</span><span>())</span>
<span>&lt;Process(Process-1, started)&gt; True</span>
<span>&gt;&gt;&gt; </span><span>p</span><span>.</span><span>terminate</span><span>()</span>
<span>&gt;&gt;&gt; </span><span>time</span><span>.</span><span>sleep</span><span>(</span><span>0.1</span><span>)</span>
<span>&gt;&gt;&gt; </span><span>print</span><span>(</span><span>p</span><span>,</span> <span>p</span><span>.</span><span>is_alive</span><span>())</span>
<span>&lt;Process(Process-1, stopped[SIGTERM])&gt; False</span>
<span>&gt;&gt;&gt; </span><span>p</span><span>.</span><span>exitcode</span> <span>==</span> <span>-</span><span>signal</span><span>.</span><span>SIGTERM</span>
<span>True</span>
</pre></div>
</div>
</dd></dl>

<dl>
<dt>
<em>exception </em><code>multiprocessing.</code><code>ProcessError</code><a>¶</a></dt>
<dd><p>The base class of all <a><code><span>multiprocessing</span></code></a> exceptions.</p>
</dd></dl>

<dl>
<dt>
<em>exception </em><code>multiprocessing.</code><code>BufferTooShort</code><a>¶</a></dt>
<dd><p>Exception raised by <code><span>Connection.recv_bytes_into()</span></code> when the supplied
buffer object is too small for the message read.</p>
<p>If <code><span>e</span></code> is an instance of <a><code><span>BufferTooShort</span></code></a> then <code><span>e.args[0]</span></code> will give
the message as a byte string.</p>
</dd></dl>

<dl>
<dt>
<em>exception </em><code>multiprocessing.</code><code>AuthenticationError</code><a>¶</a></dt>
<dd><p>Raised when there is an authentication error.</p>
</dd></dl>

<dl>
<dt>
<em>exception </em><code>multiprocessing.</code><code>TimeoutError</code><a>¶</a></dt>
<dd><p>Raised by methods with a timeout when the timeout expires.</p>
</dd></dl>

</div>
<div>
<h3>17.2.2.2. Pipes and Queues<a>¶</a></h3>
<p>When using multiple processes, one generally uses message passing for
communication between processes and avoids having to use any synchronization
primitives like locks.</p>
<p>For passing messages one can use <a><code><span>Pipe()</span></code></a> (for a connection between two
processes) or a queue (which allows multiple producers and consumers).</p>
<p>The <a><code><span>Queue</span></code></a>, <a><code><span>SimpleQueue</span></code></a> and <a><code><span>JoinableQueue</span></code></a> types
are multi-producer, multi-consumer <abbr>FIFO</abbr>
queues modelled on the <a><code><span>queue.Queue</span></code></a> class in the
standard library.  They differ in that <a><code><span>Queue</span></code></a> lacks the
<a><code><span>task_done()</span></code></a> and <a><code><span>join()</span></code></a> methods introduced
into Python 2.5’s <a><code><span>queue.Queue</span></code></a> class.</p>
<p>If you use <a><code><span>JoinableQueue</span></code></a> then you <strong>must</strong> call
<a><code><span>JoinableQueue.task_done()</span></code></a> for each task removed from the queue or else the
semaphore used to count the number of unfinished tasks may eventually overflow,
raising an exception.</p>
<p>Note that one can also create a shared queue by using a manager object – see
<a><span>Managers</span></a>.</p>
<div>
<p>Note</p>
<p><a><code><span>multiprocessing</span></code></a> uses the usual <a><code><span>queue.Empty</span></code></a> and
<a><code><span>queue.Full</span></code></a> exceptions to signal a timeout.  They are not available in
the <a><code><span>multiprocessing</span></code></a> namespace so you need to import them from
<a><code><span>queue</span></code></a>.</p>
</div>
<div>
<p>Note</p>
<p>When an object is put on a queue, the object is pickled and a
background thread later flushes the pickled data to an underlying
pipe.  This has some consequences which are a little surprising,
but should not cause any practical difficulties – if they really
bother you then you can instead use a queue created with a
<a><span>manager</span></a>.</p>
<ol>
<li>After putting an object on an empty queue there may be an
infinitesimal delay before the queue’s <a><code><span>empty()</span></code></a>
method returns <a><code><span>False</span></code></a> and <a><code><span>get_nowait()</span></code></a> can
return without raising <a><code><span>queue.Empty</span></code></a>.</li>
<li>If multiple processes are enqueuing objects, it is possible for
the objects to be received at the other end out-of-order.
However, objects enqueued by the same process will always be in
the expected order with respect to each other.</li>
</ol>
</div>
<div>
<p>Warning</p>
<p>If a process is killed using <a><code><span>Process.terminate()</span></code></a> or <a><code><span>os.kill()</span></code></a>
while it is trying to use a <a><code><span>Queue</span></code></a>, then the data in the queue is
likely to become corrupted.  This may cause any other process to get an
exception when it tries to use the queue later on.</p>
</div>
<div>
<p>Warning</p>
<p>As mentioned above, if a child process has put items on a queue (and it has
not used <a><code><span>JoinableQueue.cancel_join_thread</span></code></a>), then that process will
not terminate until all buffered items have been flushed to the pipe.</p>
<p>This means that if you try joining that process you may get a deadlock unless
you are sure that all items which have been put on the queue have been
consumed.  Similarly, if the child process is non-daemonic then the parent
process may hang on exit when it tries to join all its non-daemonic children.</p>
<p>Note that a queue created using a manager does not have this issue.  See
<a><span>Programming guidelines</span></a>.</p>
</div>
<p>For an example of the usage of queues for interprocess communication see
<a><span>Examples</span></a>.</p>
<dl>
<dt>
<code>multiprocessing.</code><code>Pipe</code><span>(</span><span>[</span><em>duplex</em><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>Returns a pair <code><span>(conn1,</span> <span>conn2)</span></code> of
<a><code><span>Connection</span></code></a> objects representing the
ends of a pipe.</p>
<p>If <em>duplex</em> is <code><span>True</span></code> (the default) then the pipe is bidirectional.  If
<em>duplex</em> is <code><span>False</span></code> then the pipe is unidirectional: <code><span>conn1</span></code> can only be
used for receiving messages and <code><span>conn2</span></code> can only be used for sending
messages.</p>
</dd></dl>

<dl>
<dt>
<em>class </em><code>multiprocessing.</code><code>Queue</code><span>(</span><span>[</span><em>maxsize</em><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>Returns a process shared queue implemented using a pipe and a few
locks/semaphores.  When a process first puts an item on the queue a feeder
thread is started which transfers objects from a buffer into the pipe.</p>
<p>The usual <a><code><span>queue.Empty</span></code></a> and <a><code><span>queue.Full</span></code></a> exceptions from the
standard library’s <a><code><span>queue</span></code></a> module are raised to signal timeouts.</p>
<p><a><code><span>Queue</span></code></a> implements all the methods of <a><code><span>queue.Queue</span></code></a> except for
<a><code><span>task_done()</span></code></a> and <a><code><span>join()</span></code></a>.</p>
<dl>
<dt>
<code>qsize</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Return the approximate size of the queue.  Because of
multithreading/multiprocessing semantics, this number is not reliable.</p>
<p>Note that this may raise <a><code><span>NotImplementedError</span></code></a> on Unix platforms like
Mac OS X where <code><span>sem_getvalue()</span></code> is not implemented.</p>
</dd></dl>

<dl>
<dt>
<code>empty</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Return <code><span>True</span></code> if the queue is empty, <code><span>False</span></code> otherwise.  Because of
multithreading/multiprocessing semantics, this is not reliable.</p>
</dd></dl>

<dl>
<dt>
<code>full</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Return <code><span>True</span></code> if the queue is full, <code><span>False</span></code> otherwise.  Because of
multithreading/multiprocessing semantics, this is not reliable.</p>
</dd></dl>

<dl>
<dt>
<code>put</code><span>(</span><em>obj</em><span>[</span>, <em>block</em><span>[</span>, <em>timeout</em><span>]</span><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>Put obj into the queue.  If the optional argument <em>block</em> is <code><span>True</span></code>
(the default) and <em>timeout</em> is <code><span>None</span></code> (the default), block if necessary until
a free slot is available.  If <em>timeout</em> is a positive number, it blocks at
most <em>timeout</em> seconds and raises the <a><code><span>queue.Full</span></code></a> exception if no
free slot was available within that time.  Otherwise (<em>block</em> is
<code><span>False</span></code>), put an item on the queue if a free slot is immediately
available, else raise the <a><code><span>queue.Full</span></code></a> exception (<em>timeout</em> is
ignored in that case).</p>
</dd></dl>

<dl>
<dt>
<code>put_nowait</code><span>(</span><em>obj</em><span>)</span><a>¶</a></dt>
<dd><p>Equivalent to <code><span>put(obj,</span> <span>False)</span></code>.</p>
</dd></dl>

<dl>
<dt>
<code>get</code><span>(</span><span>[</span><em>block</em><span>[</span>, <em>timeout</em><span>]</span><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>Remove and return an item from the queue.  If optional args <em>block</em> is
<code><span>True</span></code> (the default) and <em>timeout</em> is <code><span>None</span></code> (the default), block if
necessary until an item is available.  If <em>timeout</em> is a positive number,
it blocks at most <em>timeout</em> seconds and raises the <a><code><span>queue.Empty</span></code></a>
exception if no item was available within that time.  Otherwise (block is
<code><span>False</span></code>), return an item if one is immediately available, else raise the
<a><code><span>queue.Empty</span></code></a> exception (<em>timeout</em> is ignored in that case).</p>
</dd></dl>

<dl>
<dt>
<code>get_nowait</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Equivalent to <code><span>get(False)</span></code>.</p>
</dd></dl>

<p><a><code><span>multiprocessing.Queue</span></code></a> has a few additional methods not found in
<a><code><span>queue.Queue</span></code></a>.  These methods are usually unnecessary for most
code:</p>
<dl>
<dt>
<code>close</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Indicate that no more data will be put on this queue by the current
process.  The background thread will quit once it has flushed all buffered
data to the pipe.  This is called automatically when the queue is garbage
collected.</p>
</dd></dl>

<dl>
<dt>
<code>join_thread</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Join the background thread.  This can only be used after <a><code><span>close()</span></code></a> has
been called.  It blocks until the background thread exits, ensuring that
all data in the buffer has been flushed to the pipe.</p>
<p>By default if a process is not the creator of the queue then on exit it
will attempt to join the queue’s background thread.  The process can call
<a><code><span>cancel_join_thread()</span></code></a> to make <a><code><span>join_thread()</span></code></a> do nothing.</p>
</dd></dl>

<dl>
<dt>
<code>cancel_join_thread</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Prevent <a><code><span>join_thread()</span></code></a> from blocking.  In particular, this prevents
the background thread from being joined automatically when the process
exits – see <a><code><span>join_thread()</span></code></a>.</p>
<p>A better name for this method might be
<code><span>allow_exit_without_flush()</span></code>.  It is likely to cause enqueued
data to lost, and you almost certainly will not need to use it.
It is really only there if you need the current process to exit
immediately without waiting to flush enqueued data to the
underlying pipe, and you don’t care about lost data.</p>
</dd></dl>

<div>
<p>Note</p>
<p>This class’s functionality requires a functioning shared semaphore
implementation on the host operating system. Without one, the
functionality in this class will be disabled, and attempts to
instantiate a <a><code><span>Queue</span></code></a> will result in an <a><code><span>ImportError</span></code></a>. See
<a>bpo-3770</a> for additional information.  The same holds true for any
of the specialized queue types listed below.</p>
</div>
</dd></dl>

<dl>
<dt>
<em>class </em><code>multiprocessing.</code><code>SimpleQueue</code><a>¶</a></dt>
<dd><p>It is a simplified <a><code><span>Queue</span></code></a> type, very close to a locked <a><code><span>Pipe</span></code></a>.</p>
<dl>
<dt>
<code>empty</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Return <code><span>True</span></code> if the queue is empty, <code><span>False</span></code> otherwise.</p>
</dd></dl>

<dl>
<dt>
<code>get</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Remove and return an item from the queue.</p>
</dd></dl>

<dl>
<dt>
<code>put</code><span>(</span><em>item</em><span>)</span><a>¶</a></dt>
<dd><p>Put <em>item</em> into the queue.</p>
</dd></dl>

</dd></dl>

<dl>
<dt>
<em>class </em><code>multiprocessing.</code><code>JoinableQueue</code><span>(</span><span>[</span><em>maxsize</em><span>]</span><span>)</span><a>¶</a></dt>
<dd><p><a><code><span>JoinableQueue</span></code></a>, a <a><code><span>Queue</span></code></a> subclass, is a queue which
additionally has <a><code><span>task_done()</span></code></a> and <a><code><span>join()</span></code></a> methods.</p>
<dl>
<dt>
<code>task_done</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Indicate that a formerly enqueued task is complete. Used by queue
consumers.  For each <a><code><span>get()</span></code></a> used to fetch a task, a subsequent
call to <a><code><span>task_done()</span></code></a> tells the queue that the processing on the task
is complete.</p>
<p>If a <a><code><span>join()</span></code></a> is currently blocking, it will resume when all
items have been processed (meaning that a <a><code><span>task_done()</span></code></a> call was
received for every item that had been <a><code><span>put()</span></code></a> into the queue).</p>
<p>Raises a <a><code><span>ValueError</span></code></a> if called more times than there were items
placed in the queue.</p>
</dd></dl>

<dl>
<dt>
<code>join</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Block until all items in the queue have been gotten and processed.</p>
<p>The count of unfinished tasks goes up whenever an item is added to the
queue.  The count goes down whenever a consumer calls
<a><code><span>task_done()</span></code></a> to indicate that the item was retrieved and all work on
it is complete.  When the count of unfinished tasks drops to zero,
<a><code><span>join()</span></code></a> unblocks.</p>
</dd></dl>

</dd></dl>

</div>
<div>
<h3>17.2.2.3. Miscellaneous<a>¶</a></h3>
<dl>
<dt>
<code>multiprocessing.</code><code>active_children</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Return list of all live children of the current process.</p>
<p>Calling this has the side effect of “joining” any processes which have
already finished.</p>
</dd></dl>

<dl>
<dt>
<code>multiprocessing.</code><code>cpu_count</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Return the number of CPUs in the system.</p>
<p>This number is not equivalent to the number of CPUs the current process can
use.  The number of usable CPUs can be obtained with
<code><span>len(os.sched_getaffinity(0))</span></code></p>
<p>May raise <a><code><span>NotImplementedError</span></code></a>.</p>
<div>
<p>See also</p>
<p><a><code><span>os.cpu_count()</span></code></a></p>
</div>
</dd></dl>

<dl>
<dt>
<code>multiprocessing.</code><code>current_process</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Return the <a><code><span>Process</span></code></a> object corresponding to the current process.</p>
<p>An analogue of <a><code><span>threading.current_thread()</span></code></a>.</p>
</dd></dl>

<dl>
<dt>
<code>multiprocessing.</code><code>freeze_support</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Add support for when a program which uses <a><code><span>multiprocessing</span></code></a> has been
frozen to produce a Windows executable.  (Has been tested with <strong>py2exe</strong>,
<strong>PyInstaller</strong> and <strong>cx_Freeze</strong>.)</p>
<p>One needs to call this function straight after the <code><span>if</span> <span>__name__</span> <span>==</span>
<span>'__main__'</span></code> line of the main module.  For example:</p>
<div><div><pre><span></span><span>from</span> <span>multiprocessing</span> <span>import</span> <span>Process</span><span>,</span> <span>freeze_support</span>

<span>def</span> <span>f</span><span>():</span>
    <span>print</span><span>(</span><span>&#39;hello world!&#39;</span><span>)</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#39;__main__&#39;</span><span>:</span>
    <span>freeze_support</span><span>()</span>
    <span>Process</span><span>(</span><span>target</span><span>=</span><span>f</span><span>)</span><span>.</span><span>start</span><span>()</span>
</pre></div>
</div>
<p>If the <code><span>freeze_support()</span></code> line is omitted then trying to run the frozen
executable will raise <a><code><span>RuntimeError</span></code></a>.</p>
<p>Calling <code><span>freeze_support()</span></code> has no effect when invoked on any operating
system other than Windows.  In addition, if the module is being run
normally by the Python interpreter on Windows (the program has not been
frozen), then <code><span>freeze_support()</span></code> has no effect.</p>
</dd></dl>

<dl>
<dt>
<code>multiprocessing.</code><code>get_all_start_methods</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Returns a list of the supported start methods, the first of which
is the default.  The possible start methods are <code><span>'fork'</span></code>,
<code><span>'spawn'</span></code> and <code><span>'forkserver'</span></code>.  On Windows only <code><span>'spawn'</span></code> is
available.  On Unix <code><span>'fork'</span></code> and <code><span>'spawn'</span></code> are always
supported, with <code><span>'fork'</span></code> being the default.</p>
<div>
<p><span>New in version 3.4.</span></p>
</div>
</dd></dl>

<dl>
<dt>
<code>multiprocessing.</code><code>get_context</code><span>(</span><em>method=None</em><span>)</span><a>¶</a></dt>
<dd><p>Return a context object which has the same attributes as the
<a><code><span>multiprocessing</span></code></a> module.</p>
<p>If <em>method</em> is <code><span>None</span></code> then the default context is returned.
Otherwise <em>method</em> should be <code><span>'fork'</span></code>, <code><span>'spawn'</span></code>,
<code><span>'forkserver'</span></code>.  <a><code><span>ValueError</span></code></a> is raised if the specified
start method is not available.</p>
<div>
<p><span>New in version 3.4.</span></p>
</div>
</dd></dl>

<dl>
<dt>
<code>multiprocessing.</code><code>get_start_method</code><span>(</span><em>allow_none=False</em><span>)</span><a>¶</a></dt>
<dd><p>Return the name of start method used for starting processes.</p>
<p>If the start method has not been fixed and <em>allow_none</em> is false,
then the start method is fixed to the default and the name is
returned.  If the start method has not been fixed and <em>allow_none</em>
is true then <code><span>None</span></code> is returned.</p>
<p>The return value can be <code><span>'fork'</span></code>, <code><span>'spawn'</span></code>, <code><span>'forkserver'</span></code>
or <code><span>None</span></code>.  <code><span>'fork'</span></code> is the default on Unix, while <code><span>'spawn'</span></code> is
the default on Windows.</p>
<div>
<p><span>New in version 3.4.</span></p>
</div>
</dd></dl>

<dl>
<dt>
<code>multiprocessing.</code><code>set_executable</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Sets the path of the Python interpreter to use when starting a child process.
(By default <a><code><span>sys.executable</span></code></a> is used).  Embedders will probably need to
do some thing like</p>
<div><div><pre><span></span><span>set_executable</span><span>(</span><span>os</span><span>.</span><span>path</span><span>.</span><span>join</span><span>(</span><span>sys</span><span>.</span><span>exec_prefix</span><span>,</span> <span>&#39;pythonw.exe&#39;</span><span>))</span>
</pre></div>
</div>
<p>before they can create child processes.</p>
<div>
<p><span>Changed in version 3.4: </span>Now supported on Unix when the <code><span>'spawn'</span></code> start method is used.</p>
</div>
</dd></dl>

<dl>
<dt>
<code>multiprocessing.</code><code>set_start_method</code><span>(</span><em>method</em><span>)</span><a>¶</a></dt>
<dd><p>Set the method which should be used to start child processes.
<em>method</em> can be <code><span>'fork'</span></code>, <code><span>'spawn'</span></code> or <code><span>'forkserver'</span></code>.</p>
<p>Note that this should be called at most once, and it should be
protected inside the <code><span>if</span> <span>__name__</span> <span>==</span> <span>'__main__'</span></code> clause of the
main module.</p>
<div>
<p><span>New in version 3.4.</span></p>
</div>
</dd></dl>

<div>
<p>Note</p>
<p><a><code><span>multiprocessing</span></code></a> contains no analogues of
<a><code><span>threading.active_count()</span></code></a>, <a><code><span>threading.enumerate()</span></code></a>,
<a><code><span>threading.settrace()</span></code></a>, <a><code><span>threading.setprofile()</span></code></a>,
<a><code><span>threading.Timer</span></code></a>, or <a><code><span>threading.local</span></code></a>.</p>
</div>
</div>
<div>
<h3>17.2.2.4. Connection Objects<a>¶</a></h3>
<p>Connection objects allow the sending and receiving of picklable objects or
strings.  They can be thought of as message oriented connected sockets.</p>
<p>Connection objects are usually created using
<a><code><span>Pipe</span></code></a> – see also
<a><span>Listeners and Clients</span></a>.</p>
<dl>
<dt>
<em>class </em><code>multiprocessing.connection.</code><code>Connection</code><a>¶</a></dt>
<dd><dl>
<dt>
<code>send</code><span>(</span><em>obj</em><span>)</span><a>¶</a></dt>
<dd><p>Send an object to the other end of the connection which should be read
using <a><code><span>recv()</span></code></a>.</p>
<p>The object must be picklable.  Very large pickles (approximately 32 MB+,
though it depends on the OS) may raise a <a><code><span>ValueError</span></code></a> exception.</p>
</dd></dl>

<dl>
<dt>
<code>recv</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Return an object sent from the other end of the connection using
<a><code><span>send()</span></code></a>.  Blocks until there is something to receive.  Raises
<a><code><span>EOFError</span></code></a> if there is nothing left to receive
and the other end was closed.</p>
</dd></dl>

<dl>
<dt>
<code>fileno</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Return the file descriptor or handle used by the connection.</p>
</dd></dl>

<dl>
<dt>
<code>close</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Close the connection.</p>
<p>This is called automatically when the connection is garbage collected.</p>
</dd></dl>

<dl>
<dt>
<code>poll</code><span>(</span><span>[</span><em>timeout</em><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>Return whether there is any data available to be read.</p>
<p>If <em>timeout</em> is not specified then it will return immediately.  If
<em>timeout</em> is a number then this specifies the maximum time in seconds to
block.  If <em>timeout</em> is <code><span>None</span></code> then an infinite timeout is used.</p>
<p>Note that multiple connection objects may be polled at once by
using <a><code><span>multiprocessing.connection.wait()</span></code></a>.</p>
</dd></dl>

<dl>
<dt>
<code>send_bytes</code><span>(</span><em>buffer</em><span>[</span>, <em>offset</em><span>[</span>, <em>size</em><span>]</span><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>Send byte data from a <a><span>bytes-like object</span></a> as a complete message.</p>
<p>If <em>offset</em> is given then data is read from that position in <em>buffer</em>.  If
<em>size</em> is given then that many bytes will be read from buffer.  Very large
buffers (approximately 32 MB+, though it depends on the OS) may raise a
<a><code><span>ValueError</span></code></a> exception</p>
</dd></dl>

<dl>
<dt>
<code>recv_bytes</code><span>(</span><span>[</span><em>maxlength</em><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>Return a complete message of byte data sent from the other end of the
connection as a string.  Blocks until there is something to receive.
Raises <a><code><span>EOFError</span></code></a> if there is nothing left
to receive and the other end has closed.</p>
<p>If <em>maxlength</em> is specified and the message is longer than <em>maxlength</em>
then <a><code><span>OSError</span></code></a> is raised and the connection will no longer be
readable.</p>
<div>
<p><span>Changed in version 3.3: </span>This function used to raise <a><code><span>IOError</span></code></a>, which is now an
alias of <a><code><span>OSError</span></code></a>.</p>
</div>
</dd></dl>

<dl>
<dt>
<code>recv_bytes_into</code><span>(</span><em>buffer</em><span>[</span>, <em>offset</em><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>Read into <em>buffer</em> a complete message of byte data sent from the other end
of the connection and return the number of bytes in the message.  Blocks
until there is something to receive.  Raises
<a><code><span>EOFError</span></code></a> if there is nothing left to receive and the other end was
closed.</p>
<p><em>buffer</em> must be a writable <a><span>bytes-like object</span></a>.  If
<em>offset</em> is given then the message will be written into the buffer from
that position.  Offset must be a non-negative integer less than the
length of <em>buffer</em> (in bytes).</p>
<p>If the buffer is too short then a <code><span>BufferTooShort</span></code> exception is
raised and the complete message is available as <code><span>e.args[0]</span></code> where <code><span>e</span></code>
is the exception instance.</p>
</dd></dl>

<div>
<p><span>Changed in version 3.3: </span>Connection objects themselves can now be transferred between processes
using <a><code><span>Connection.send()</span></code></a> and <a><code><span>Connection.recv()</span></code></a>.</p>
</div>
<div>
<p><span>New in version 3.3: </span>Connection objects now support the context management protocol – see
<a><span>Context Manager Types</span></a>.  <a><code><span>__enter__()</span></code></a> returns the
connection object, and <a><code><span>__exit__()</span></code></a> calls <a><code><span>close()</span></code></a>.</p>
</div>
</dd></dl>

<p>For example:</p>
<div><div><pre><span></span><span>&gt;&gt;&gt; </span><span>from</span> <span>multiprocessing</span> <span>import</span> <span>Pipe</span>
<span>&gt;&gt;&gt; </span><span>a</span><span>,</span> <span>b</span> <span>=</span> <span>Pipe</span><span>()</span>
<span>&gt;&gt;&gt; </span><span>a</span><span>.</span><span>send</span><span>([</span><span>1</span><span>,</span> <span>&#39;hello&#39;</span><span>,</span> <span>None</span><span>])</span>
<span>&gt;&gt;&gt; </span><span>b</span><span>.</span><span>recv</span><span>()</span>
<span>[1, &#39;hello&#39;, None]</span>
<span>&gt;&gt;&gt; </span><span>b</span><span>.</span><span>send_bytes</span><span>(</span><span>b</span><span>&#39;thank you&#39;</span><span>)</span>
<span>&gt;&gt;&gt; </span><span>a</span><span>.</span><span>recv_bytes</span><span>()</span>
<span>b&#39;thank you&#39;</span>
<span>&gt;&gt;&gt; </span><span>import</span> <span>array</span>
<span>&gt;&gt;&gt; </span><span>arr1</span> <span>=</span> <span>array</span><span>.</span><span>array</span><span>(</span><span>&#39;i&#39;</span><span>,</span> <span>range</span><span>(</span><span>5</span><span>))</span>
<span>&gt;&gt;&gt; </span><span>arr2</span> <span>=</span> <span>array</span><span>.</span><span>array</span><span>(</span><span>&#39;i&#39;</span><span>,</span> <span>[</span><span>0</span><span>]</span> <span>*</span> <span>10</span><span>)</span>
<span>&gt;&gt;&gt; </span><span>a</span><span>.</span><span>send_bytes</span><span>(</span><span>arr1</span><span>)</span>
<span>&gt;&gt;&gt; </span><span>count</span> <span>=</span> <span>b</span><span>.</span><span>recv_bytes_into</span><span>(</span><span>arr2</span><span>)</span>
<span>&gt;&gt;&gt; </span><span>assert</span> <span>count</span> <span>==</span> <span>len</span><span>(</span><span>arr1</span><span>)</span> <span>*</span> <span>arr1</span><span>.</span><span>itemsize</span>
<span>&gt;&gt;&gt; </span><span>arr2</span>
<span>array(&#39;i&#39;, [0, 1, 2, 3, 4, 0, 0, 0, 0, 0])</span>
</pre></div>
</div>
<div>
<p>Warning</p>
<p>The <a><code><span>Connection.recv()</span></code></a> method automatically unpickles the data it
receives, which can be a security risk unless you can trust the process
which sent the message.</p>
<p>Therefore, unless the connection object was produced using <code><span>Pipe()</span></code> you
should only use the <a><code><span>recv()</span></code></a> and <a><code><span>send()</span></code></a>
methods after performing some sort of authentication.  See
<a><span>Authentication keys</span></a>.</p>
</div>
<div>
<p>Warning</p>
<p>If a process is killed while it is trying to read or write to a pipe then
the data in the pipe is likely to become corrupted, because it may become
impossible to be sure where the message boundaries lie.</p>
</div>
</div>
<div>
<h3>17.2.2.5. Synchronization primitives<a>¶</a></h3>
<p>Generally synchronization primitives are not as necessary in a multiprocess
program as they are in a multithreaded program.  See the documentation for
<a><code><span>threading</span></code></a> module.</p>
<p>Note that one can also create synchronization primitives by using a manager
object – see <a><span>Managers</span></a>.</p>
<dl>
<dt>
<em>class </em><code>multiprocessing.</code><code>Barrier</code><span>(</span><em>parties</em><span>[</span>, <em>action</em><span>[</span>, <em>timeout</em><span>]</span><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>A barrier object: a clone of <a><code><span>threading.Barrier</span></code></a>.</p>
<div>
<p><span>New in version 3.3.</span></p>
</div>
</dd></dl>

<dl>
<dt>
<em>class </em><code>multiprocessing.</code><code>BoundedSemaphore</code><span>(</span><span>[</span><em>value</em><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>A bounded semaphore object: a close analog of
<a><code><span>threading.BoundedSemaphore</span></code></a>.</p>
<p>A solitary difference from its close analog exists: its <code><span>acquire</span></code> method’s
first argument is named <em>block</em>, as is consistent with <a><code><span>Lock.acquire()</span></code></a>.</p>
<div>
<p>Note</p>
<p>On Mac OS X, this is indistinguishable from <a><code><span>Semaphore</span></code></a> because
<code><span>sem_getvalue()</span></code> is not implemented on that platform.</p>
</div>
</dd></dl>

<dl>
<dt>
<em>class </em><code>multiprocessing.</code><code>Condition</code><span>(</span><span>[</span><em>lock</em><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>A condition variable: an alias for <a><code><span>threading.Condition</span></code></a>.</p>
<p>If <em>lock</em> is specified then it should be a <a><code><span>Lock</span></code></a> or <a><code><span>RLock</span></code></a>
object from <a><code><span>multiprocessing</span></code></a>.</p>
<div>
<p><span>Changed in version 3.3: </span>The <a><code><span>wait_for()</span></code></a> method was added.</p>
</div>
</dd></dl>

<dl>
<dt>
<em>class </em><code>multiprocessing.</code><code>Event</code><a>¶</a></dt>
<dd><p>A clone of <a><code><span>threading.Event</span></code></a>.</p>
</dd></dl>

<dl>
<dt>
<em>class </em><code>multiprocessing.</code><code>Lock</code><a>¶</a></dt>
<dd><p>A non-recursive lock object: a close analog of <a><code><span>threading.Lock</span></code></a>.
Once a process or thread has acquired a lock, subsequent attempts to
acquire it from any process or thread will block until it is released;
any process or thread may release it.  The concepts and behaviors of
<a><code><span>threading.Lock</span></code></a> as it applies to threads are replicated here in
<a><code><span>multiprocessing.Lock</span></code></a> as it applies to either processes or threads,
except as noted.</p>
<p>Note that <a><code><span>Lock</span></code></a> is actually a factory function which returns an
instance of <code><span>multiprocessing.synchronize.Lock</span></code> initialized with a
default context.</p>
<p><a><code><span>Lock</span></code></a> supports the <a><span>context manager</span></a> protocol and thus may be
used in <a><code><span>with</span></code></a> statements.</p>
<dl>
<dt>
<code>acquire</code><span>(</span><em>block=True</em>, <em>timeout=None</em><span>)</span><a>¶</a></dt>
<dd><p>Acquire a lock, blocking or non-blocking.</p>
<p>With the <em>block</em> argument set to <code><span>True</span></code> (the default), the method call
will block until the lock is in an unlocked state, then set it to locked
and return <code><span>True</span></code>.  Note that the name of this first argument differs
from that in <a><code><span>threading.Lock.acquire()</span></code></a>.</p>
<p>With the <em>block</em> argument set to <code><span>False</span></code>, the method call does not
block.  If the lock is currently in a locked state, return <code><span>False</span></code>;
otherwise set the lock to a locked state and return <code><span>True</span></code>.</p>
<p>When invoked with a positive, floating-point value for <em>timeout</em>, block
for at most the number of seconds specified by <em>timeout</em> as long as
the lock can not be acquired.  Invocations with a negative value for
<em>timeout</em> are equivalent to a <em>timeout</em> of zero.  Invocations with a
<em>timeout</em> value of <code><span>None</span></code> (the default) set the timeout period to
infinite.  Note that the treatment of negative or <code><span>None</span></code> values for
<em>timeout</em> differs from the implemented behavior in
<a><code><span>threading.Lock.acquire()</span></code></a>.  The <em>timeout</em> argument has no practical
implications if the <em>block</em> argument is set to <code><span>False</span></code> and is thus
ignored.  Returns <code><span>True</span></code> if the lock has been acquired or <code><span>False</span></code> if
the timeout period has elapsed.</p>
</dd></dl>

<dl>
<dt>
<code>release</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Release a lock.  This can be called from any process or thread, not only
the process or thread which originally acquired the lock.</p>
<p>Behavior is the same as in <a><code><span>threading.Lock.release()</span></code></a> except that
when invoked on an unlocked lock, a <a><code><span>ValueError</span></code></a> is raised.</p>
</dd></dl>

</dd></dl>

<dl>
<dt>
<em>class </em><code>multiprocessing.</code><code>RLock</code><a>¶</a></dt>
<dd><p>A recursive lock object: a close analog of <a><code><span>threading.RLock</span></code></a>.  A
recursive lock must be released by the process or thread that acquired it.
Once a process or thread has acquired a recursive lock, the same process
or thread may acquire it again without blocking; that process or thread
must release it once for each time it has been acquired.</p>
<p>Note that <a><code><span>RLock</span></code></a> is actually a factory function which returns an
instance of <code><span>multiprocessing.synchronize.RLock</span></code> initialized with a
default context.</p>
<p><a><code><span>RLock</span></code></a> supports the <a><span>context manager</span></a> protocol and thus may be
used in <a><code><span>with</span></code></a> statements.</p>
<dl>
<dt>
<code>acquire</code><span>(</span><em>block=True</em>, <em>timeout=None</em><span>)</span><a>¶</a></dt>
<dd><p>Acquire a lock, blocking or non-blocking.</p>
<p>When invoked with the <em>block</em> argument set to <code><span>True</span></code>, block until the
lock is in an unlocked state (not owned by any process or thread) unless
the lock is already owned by the current process or thread.  The current
process or thread then takes ownership of the lock (if it does not
already have ownership) and the recursion level inside the lock increments
by one, resulting in a return value of <code><span>True</span></code>.  Note that there are
several differences in this first argument’s behavior compared to the
implementation of <a><code><span>threading.RLock.acquire()</span></code></a>, starting with the name
of the argument itself.</p>
<p>When invoked with the <em>block</em> argument set to <code><span>False</span></code>, do not block.
If the lock has already been acquired (and thus is owned) by another
process or thread, the current process or thread does not take ownership
and the recursion level within the lock is not changed, resulting in
a return value of <code><span>False</span></code>.  If the lock is in an unlocked state, the
current process or thread takes ownership and the recursion level is
incremented, resulting in a return value of <code><span>True</span></code>.</p>
<p>Use and behaviors of the <em>timeout</em> argument are the same as in
<a><code><span>Lock.acquire()</span></code></a>.  Note that some of these behaviors of <em>timeout</em>
differ from the implemented behaviors in <a><code><span>threading.RLock.acquire()</span></code></a>.</p>
</dd></dl>

<dl>
<dt>
<code>release</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Release a lock, decrementing the recursion level.  If after the
decrement the recursion level is zero, reset the lock to unlocked (not
owned by any process or thread) and if any other processes or threads
are blocked waiting for the lock to become unlocked, allow exactly one
of them to proceed.  If after the decrement the recursion level is still
nonzero, the lock remains locked and owned by the calling process or
thread.</p>
<p>Only call this method when the calling process or thread owns the lock.
An <a><code><span>AssertionError</span></code></a> is raised if this method is called by a process
or thread other than the owner or if the lock is in an unlocked (unowned)
state.  Note that the type of exception raised in this situation
differs from the implemented behavior in <a><code><span>threading.RLock.release()</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl>
<dt>
<em>class </em><code>multiprocessing.</code><code>Semaphore</code><span>(</span><span>[</span><em>value</em><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>A semaphore object: a close analog of <a><code><span>threading.Semaphore</span></code></a>.</p>
<p>A solitary difference from its close analog exists: its <code><span>acquire</span></code> method’s
first argument is named <em>block</em>, as is consistent with <a><code><span>Lock.acquire()</span></code></a>.</p>
</dd></dl>

<div>
<p>Note</p>
<p>On Mac OS X, <code><span>sem_timedwait</span></code> is unsupported, so calling <code><span>acquire()</span></code> with
a timeout will emulate that function’s behavior using a sleeping loop.</p>
</div>
<div>
<p>Note</p>
<p>If the SIGINT signal generated by <kbd>Ctrl-C</kbd> arrives while the main thread is
blocked by a call to <code><span>BoundedSemaphore.acquire()</span></code>, <a><code><span>Lock.acquire()</span></code></a>,
<a><code><span>RLock.acquire()</span></code></a>, <code><span>Semaphore.acquire()</span></code>, <code><span>Condition.acquire()</span></code>
or <code><span>Condition.wait()</span></code> then the call will be immediately interrupted and
<a><code><span>KeyboardInterrupt</span></code></a> will be raised.</p>
<p>This differs from the behaviour of <a><code><span>threading</span></code></a> where SIGINT will be
ignored while the equivalent blocking calls are in progress.</p>
</div>
<div>
<p>Note</p>
<p>Some of this package’s functionality requires a functioning shared semaphore
implementation on the host operating system. Without one, the
<code><span>multiprocessing.synchronize</span></code> module will be disabled, and attempts to
import it will result in an <a><code><span>ImportError</span></code></a>. See
<a>bpo-3770</a> for additional information.</p>
</div>
</div>
<div>
<h3>17.2.2.6. Shared <a><code><span>ctypes</span></code></a> Objects<a>¶</a></h3>
<p>It is possible to create shared objects using shared memory which can be
inherited by child processes.</p>
<dl>
<dt>
<code>multiprocessing.</code><code>Value</code><span>(</span><em>typecode_or_type</em>, <em>*args</em>, <em>lock=True</em><span>)</span><a>¶</a></dt>
<dd><p>Return a <a><code><span>ctypes</span></code></a> object allocated from shared memory.  By default the
return value is actually a synchronized wrapper for the object.  The object
itself can be accessed via the <em>value</em> attribute of a <a><code><span>Value</span></code></a>.</p>
<p><em>typecode_or_type</em> determines the type of the returned object: it is either a
ctypes type or a one character typecode of the kind used by the <a><code><span>array</span></code></a>
module.  <em>*args</em> is passed on to the constructor for the type.</p>
<p>If <em>lock</em> is <code><span>True</span></code> (the default) then a new recursive lock
object is created to synchronize access to the value.  If <em>lock</em> is
a <a><code><span>Lock</span></code></a> or <a><code><span>RLock</span></code></a> object then that will be used to
synchronize access to the value.  If <em>lock</em> is <code><span>False</span></code> then
access to the returned object will not be automatically protected
by a lock, so it will not necessarily be “process-safe”.</p>
<p>Operations like <code><span>+=</span></code> which involve a read and write are not
atomic.  So if, for instance, you want to atomically increment a
shared value it is insufficient to just do</p>
<div><div><pre><span></span><span>counter</span><span>.</span><span>value</span> <span>+=</span> <span>1</span>
</pre></div>
</div>
<p>Assuming the associated lock is recursive (which it is by default)
you can instead do</p>
<div><div><pre><span></span><span>with</span> <span>counter</span><span>.</span><span>get_lock</span><span>():</span>
    <span>counter</span><span>.</span><span>value</span> <span>+=</span> <span>1</span>
</pre></div>
</div>
<p>Note that <em>lock</em> is a keyword-only argument.</p>
</dd></dl>

<dl>
<dt>
<code>multiprocessing.</code><code>Array</code><span>(</span><em>typecode_or_type</em>, <em>size_or_initializer</em>, <em>*</em>, <em>lock=True</em><span>)</span><a>¶</a></dt>
<dd><p>Return a ctypes array allocated from shared memory.  By default the return
value is actually a synchronized wrapper for the array.</p>
<p><em>typecode_or_type</em> determines the type of the elements of the returned array:
it is either a ctypes type or a one character typecode of the kind used by
the <a><code><span>array</span></code></a> module.  If <em>size_or_initializer</em> is an integer, then it
determines the length of the array, and the array will be initially zeroed.
Otherwise, <em>size_or_initializer</em> is a sequence which is used to initialize
the array and whose length determines the length of the array.</p>
<p>If <em>lock</em> is <code><span>True</span></code> (the default) then a new lock object is created to
synchronize access to the value.  If <em>lock</em> is a <a><code><span>Lock</span></code></a> or
<a><code><span>RLock</span></code></a> object then that will be used to synchronize access to the
value.  If <em>lock</em> is <code><span>False</span></code> then access to the returned object will not be
automatically protected by a lock, so it will not necessarily be
“process-safe”.</p>
<p>Note that <em>lock</em> is a keyword only argument.</p>
<p>Note that an array of <a><code><span>ctypes.c_char</span></code></a> has <em>value</em> and <em>raw</em>
attributes which allow one to use it to store and retrieve strings.</p>
</dd></dl>

<div>
<span></span><h4>17.2.2.6.1. The <a><code><span>multiprocessing.sharedctypes</span></code></a> module<a>¶</a></h4>
<p>The <a><code><span>multiprocessing.sharedctypes</span></code></a> module provides functions for allocating
<a><code><span>ctypes</span></code></a> objects from shared memory which can be inherited by child
processes.</p>
<div>
<p>Note</p>
<p>Although it is possible to store a pointer in shared memory remember that
this will refer to a location in the address space of a specific process.
However, the pointer is quite likely to be invalid in the context of a second
process and trying to dereference the pointer from the second process may
cause a crash.</p>
</div>
<dl>
<dt>
<code>multiprocessing.sharedctypes.</code><code>RawArray</code><span>(</span><em>typecode_or_type</em>, <em>size_or_initializer</em><span>)</span><a>¶</a></dt>
<dd><p>Return a ctypes array allocated from shared memory.</p>
<p><em>typecode_or_type</em> determines the type of the elements of the returned array:
it is either a ctypes type or a one character typecode of the kind used by
the <a><code><span>array</span></code></a> module.  If <em>size_or_initializer</em> is an integer then it
determines the length of the array, and the array will be initially zeroed.
Otherwise <em>size_or_initializer</em> is a sequence which is used to initialize the
array and whose length determines the length of the array.</p>
<p>Note that setting and getting an element is potentially non-atomic – use
<a><code><span>Array()</span></code></a> instead to make sure that access is automatically synchronized
using a lock.</p>
</dd></dl>

<dl>
<dt>
<code>multiprocessing.sharedctypes.</code><code>RawValue</code><span>(</span><em>typecode_or_type</em>, <em>*args</em><span>)</span><a>¶</a></dt>
<dd><p>Return a ctypes object allocated from shared memory.</p>
<p><em>typecode_or_type</em> determines the type of the returned object: it is either a
ctypes type or a one character typecode of the kind used by the <a><code><span>array</span></code></a>
module.  <em>*args</em> is passed on to the constructor for the type.</p>
<p>Note that setting and getting the value is potentially non-atomic – use
<a><code><span>Value()</span></code></a> instead to make sure that access is automatically synchronized
using a lock.</p>
<p>Note that an array of <a><code><span>ctypes.c_char</span></code></a> has <code><span>value</span></code> and <code><span>raw</span></code>
attributes which allow one to use it to store and retrieve strings – see
documentation for <a><code><span>ctypes</span></code></a>.</p>
</dd></dl>

<dl>
<dt>
<code>multiprocessing.sharedctypes.</code><code>Array</code><span>(</span><em>typecode_or_type</em>, <em>size_or_initializer</em>, <em>*</em>, <em>lock=True</em><span>)</span><a>¶</a></dt>
<dd><p>The same as <a><code><span>RawArray()</span></code></a> except that depending on the value of <em>lock</em> a
process-safe synchronization wrapper may be returned instead of a raw ctypes
array.</p>
<p>If <em>lock</em> is <code><span>True</span></code> (the default) then a new lock object is created to
synchronize access to the value.  If <em>lock</em> is a
<a><code><span>Lock</span></code></a> or <a><code><span>RLock</span></code></a> object
then that will be used to synchronize access to the
value.  If <em>lock</em> is <code><span>False</span></code> then access to the returned object will not be
automatically protected by a lock, so it will not necessarily be
“process-safe”.</p>
<p>Note that <em>lock</em> is a keyword-only argument.</p>
</dd></dl>

<dl>
<dt>
<code>multiprocessing.sharedctypes.</code><code>Value</code><span>(</span><em>typecode_or_type</em>, <em>*args</em>, <em>lock=True</em><span>)</span><a>¶</a></dt>
<dd><p>The same as <a><code><span>RawValue()</span></code></a> except that depending on the value of <em>lock</em> a
process-safe synchronization wrapper may be returned instead of a raw ctypes
object.</p>
<p>If <em>lock</em> is <code><span>True</span></code> (the default) then a new lock object is created to
synchronize access to the value.  If <em>lock</em> is a <a><code><span>Lock</span></code></a> or
<a><code><span>RLock</span></code></a> object then that will be used to synchronize access to the
value.  If <em>lock</em> is <code><span>False</span></code> then access to the returned object will not be
automatically protected by a lock, so it will not necessarily be
“process-safe”.</p>
<p>Note that <em>lock</em> is a keyword-only argument.</p>
</dd></dl>

<dl>
<dt>
<code>multiprocessing.sharedctypes.</code><code>copy</code><span>(</span><em>obj</em><span>)</span><a>¶</a></dt>
<dd><p>Return a ctypes object allocated from shared memory which is a copy of the
ctypes object <em>obj</em>.</p>
</dd></dl>

<dl>
<dt>
<code>multiprocessing.sharedctypes.</code><code>synchronized</code><span>(</span><em>obj</em><span>[</span>, <em>lock</em><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>Return a process-safe wrapper object for a ctypes object which uses <em>lock</em> to
synchronize access.  If <em>lock</em> is <code><span>None</span></code> (the default) then a
<a><code><span>multiprocessing.RLock</span></code></a> object is created automatically.</p>
<p>A synchronized wrapper will have two methods in addition to those of the
object it wraps: <code><span>get_obj()</span></code> returns the wrapped object and
<code><span>get_lock()</span></code> returns the lock object used for synchronization.</p>
<p>Note that accessing the ctypes object through the wrapper can be a lot slower
than accessing the raw ctypes object.</p>
<div>
<p><span>Changed in version 3.5: </span>Synchronized objects support the <a><span>context manager</span></a> protocol.</p>
</div>
</dd></dl>

<p>The table below compares the syntax for creating shared ctypes objects from
shared memory with the normal ctypes syntax.  (In the table <code><span>MyStruct</span></code> is some
subclass of <a><code><span>ctypes.Structure</span></code></a>.)</p>
<table>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr><th>ctypes</th>
<th>sharedctypes using type</th>
<th>sharedctypes using typecode</th>
</tr>
</thead>
<tbody>
<tr><td>c_double(2.4)</td>
<td>RawValue(c_double, 2.4)</td>
<td>RawValue(‘d’, 2.4)</td>
</tr>
<tr><td>MyStruct(4, 6)</td>
<td>RawValue(MyStruct, 4, 6)</td>
<td>&#160;</td>
</tr>
<tr><td>(c_short * 7)()</td>
<td>RawArray(c_short, 7)</td>
<td>RawArray(‘h’, 7)</td>
</tr>
<tr><td>(c_int * 3)(9, 2, 8)</td>
<td>RawArray(c_int, (9, 2, 8))</td>
<td>RawArray(‘i’, (9, 2, 8))</td>
</tr>
</tbody>
</table>
<p>Below is an example where a number of ctypes objects are modified by a child
process:</p>
<div><div><pre><span></span><span>from</span> <span>multiprocessing</span> <span>import</span> <span>Process</span><span>,</span> <span>Lock</span>
<span>from</span> <span>multiprocessing.sharedctypes</span> <span>import</span> <span>Value</span><span>,</span> <span>Array</span>
<span>from</span> <span>ctypes</span> <span>import</span> <span>Structure</span><span>,</span> <span>c_double</span>

<span>class</span> <span>Point</span><span>(</span><span>Structure</span><span>):</span>
    <span>_fields_</span> <span>=</span> <span>[(</span><span>&#39;x&#39;</span><span>,</span> <span>c_double</span><span>),</span> <span>(</span><span>&#39;y&#39;</span><span>,</span> <span>c_double</span><span>)]</span>

<span>def</span> <span>modify</span><span>(</span><span>n</span><span>,</span> <span>x</span><span>,</span> <span>s</span><span>,</span> <span>A</span><span>):</span>
    <span>n</span><span>.</span><span>value</span> <span>**=</span> <span>2</span>
    <span>x</span><span>.</span><span>value</span> <span>**=</span> <span>2</span>
    <span>s</span><span>.</span><span>value</span> <span>=</span> <span>s</span><span>.</span><span>value</span><span>.</span><span>upper</span><span>()</span>
    <span>for</span> <span>a</span> <span>in</span> <span>A</span><span>:</span>
        <span>a</span><span>.</span><span>x</span> <span>**=</span> <span>2</span>
        <span>a</span><span>.</span><span>y</span> <span>**=</span> <span>2</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#39;__main__&#39;</span><span>:</span>
    <span>lock</span> <span>=</span> <span>Lock</span><span>()</span>

    <span>n</span> <span>=</span> <span>Value</span><span>(</span><span>&#39;i&#39;</span><span>,</span> <span>7</span><span>)</span>
    <span>x</span> <span>=</span> <span>Value</span><span>(</span><span>c_double</span><span>,</span> <span>1.0</span><span>/</span><span>3.0</span><span>,</span> <span>lock</span><span>=</span><span>False</span><span>)</span>
    <span>s</span> <span>=</span> <span>Array</span><span>(</span><span>&#39;c&#39;</span><span>,</span> <span>b</span><span>&#39;hello world&#39;</span><span>,</span> <span>lock</span><span>=</span><span>lock</span><span>)</span>
    <span>A</span> <span>=</span> <span>Array</span><span>(</span><span>Point</span><span>,</span> <span>[(</span><span>1.875</span><span>,</span><span>-</span><span>6.25</span><span>),</span> <span>(</span><span>-</span><span>5.75</span><span>,</span><span>2.0</span><span>),</span> <span>(</span><span>2.375</span><span>,</span><span>9.5</span><span>)],</span> <span>lock</span><span>=</span><span>lock</span><span>)</span>

    <span>p</span> <span>=</span> <span>Process</span><span>(</span><span>target</span><span>=</span><span>modify</span><span>,</span> <span>args</span><span>=</span><span>(</span><span>n</span><span>,</span> <span>x</span><span>,</span> <span>s</span><span>,</span> <span>A</span><span>))</span>
    <span>p</span><span>.</span><span>start</span><span>()</span>
    <span>p</span><span>.</span><span>join</span><span>()</span>

    <span>print</span><span>(</span><span>n</span><span>.</span><span>value</span><span>)</span>
    <span>print</span><span>(</span><span>x</span><span>.</span><span>value</span><span>)</span>
    <span>print</span><span>(</span><span>s</span><span>.</span><span>value</span><span>)</span>
    <span>print</span><span>([(</span><span>a</span><span>.</span><span>x</span><span>,</span> <span>a</span><span>.</span><span>y</span><span>)</span> <span>for</span> <span>a</span> <span>in</span> <span>A</span><span>])</span>
</pre></div>
</div>
<p>The results printed are</p>
<div><div><pre><span></span>49
0.1111111111111111
HELLO WORLD
[(3.515625, 39.0625), (33.0625, 4.0), (5.640625, 90.25)]
</pre></div>
</div>
</div>
</div>
<div>
<span></span><h3>17.2.2.7. Managers<a>¶</a></h3>
<p>Managers provide a way to create data which can be shared between different
processes, including sharing over a network between processes running on
different machines. A manager object controls a server process which manages
<em>shared objects</em>.  Other processes can access the shared objects by using
proxies.</p>
<dl>
<dt>
<code>multiprocessing.</code><code>Manager</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Returns a started <a><code><span>SyncManager</span></code></a> object which
can be used for sharing objects between processes.  The returned manager
object corresponds to a spawned child process and has methods which will
create shared objects and return corresponding proxies.</p>
</dd></dl>

<span></span><p>Manager processes will be shutdown as soon as they are garbage collected or
their parent process exits.  The manager classes are defined in the
<a><code><span>multiprocessing.managers</span></code></a> module:</p>
<dl>
<dt>
<em>class </em><code>multiprocessing.managers.</code><code>BaseManager</code><span>(</span><span>[</span><em>address</em><span>[</span>, <em>authkey</em><span>]</span><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>Create a BaseManager object.</p>
<p>Once created one should call <a><code><span>start()</span></code></a> or <code><span>get_server().serve_forever()</span></code> to ensure
that the manager object refers to a started manager process.</p>
<p><em>address</em> is the address on which the manager process listens for new
connections.  If <em>address</em> is <code><span>None</span></code> then an arbitrary one is chosen.</p>
<p><em>authkey</em> is the authentication key which will be used to check the
validity of incoming connections to the server process.  If
<em>authkey</em> is <code><span>None</span></code> then <code><span>current_process().authkey</span></code> is used.
Otherwise <em>authkey</em> is used and it must be a byte string.</p>
<dl>
<dt>
<code>start</code><span>(</span><span>[</span><em>initializer</em><span>[</span>, <em>initargs</em><span>]</span><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>Start a subprocess to start the manager.  If <em>initializer</em> is not <code><span>None</span></code>
then the subprocess will call <code><span>initializer(*initargs)</span></code> when it starts.</p>
</dd></dl>

<dl>
<dt>
<code>get_server</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Returns a <code><span>Server</span></code> object which represents the actual server under
the control of the Manager. The <code><span>Server</span></code> object supports the
<code><span>serve_forever()</span></code> method:</p>
<div><div><pre><span></span><span>&gt;&gt;&gt; </span><span>from</span> <span>multiprocessing.managers</span> <span>import</span> <span>BaseManager</span>
<span>&gt;&gt;&gt; </span><span>manager</span> <span>=</span> <span>BaseManager</span><span>(</span><span>address</span><span>=</span><span>(</span><span>&#39;&#39;</span><span>,</span> <span>50000</span><span>),</span> <span>authkey</span><span>=</span><span>b</span><span>&#39;abc&#39;</span><span>)</span>
<span>&gt;&gt;&gt; </span><span>server</span> <span>=</span> <span>manager</span><span>.</span><span>get_server</span><span>()</span>
<span>&gt;&gt;&gt; </span><span>server</span><span>.</span><span>serve_forever</span><span>()</span>
</pre></div>
</div>
<p><code><span>Server</span></code> additionally has an <a><code><span>address</span></code></a> attribute.</p>
</dd></dl>

<dl>
<dt>
<code>connect</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Connect a local manager object to a remote manager process:</p>
<div><div><pre><span></span><span>&gt;&gt;&gt; </span><span>from</span> <span>multiprocessing.managers</span> <span>import</span> <span>BaseManager</span>
<span>&gt;&gt;&gt; </span><span>m</span> <span>=</span> <span>BaseManager</span><span>(</span><span>address</span><span>=</span><span>(</span><span>&#39;127.0.0.1&#39;</span><span>,</span> <span>5000</span><span>),</span> <span>authkey</span><span>=</span><span>b</span><span>&#39;abc&#39;</span><span>)</span>
<span>&gt;&gt;&gt; </span><span>m</span><span>.</span><span>connect</span><span>()</span>
</pre></div>
</div>
</dd></dl>

<dl>
<dt>
<code>shutdown</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Stop the process used by the manager.  This is only available if
<a><code><span>start()</span></code></a> has been used to start the server process.</p>
<p>This can be called multiple times.</p>
</dd></dl>

<dl>
<dt>
<code>register</code><span>(</span><em>typeid</em><span>[</span>, <em>callable</em><span>[</span>, <em>proxytype</em><span>[</span>, <em>exposed</em><span>[</span>, <em>method_to_typeid</em><span>[</span>, <em>create_method</em><span>]</span><span>]</span><span>]</span><span>]</span><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>A classmethod which can be used for registering a type or callable with
the manager class.</p>
<p><em>typeid</em> is a “type identifier” which is used to identify a particular
type of shared object.  This must be a string.</p>
<p><em>callable</em> is a callable used for creating objects for this type
identifier.  If a manager instance will be connected to the
server using the <a><code><span>connect()</span></code></a> method, or if the
<em>create_method</em> argument is <code><span>False</span></code> then this can be left as
<code><span>None</span></code>.</p>
<p><em>proxytype</em> is a subclass of <a><code><span>BaseProxy</span></code></a> which is used to create
proxies for shared objects with this <em>typeid</em>.  If <code><span>None</span></code> then a proxy
class is created automatically.</p>
<p><em>exposed</em> is used to specify a sequence of method names which proxies for
this typeid should be allowed to access using
<a><code><span>BaseProxy._callmethod()</span></code></a>.  (If <em>exposed</em> is <code><span>None</span></code> then
<code><span>proxytype._exposed_</span></code> is used instead if it exists.)  In the case
where no exposed list is specified, all “public methods” of the shared
object will be accessible.  (Here a “public method” means any attribute
which has a <a><code><span>__call__()</span></code></a> method and whose name does not begin
with <code><span>'_'</span></code>.)</p>
<p><em>method_to_typeid</em> is a mapping used to specify the return type of those
exposed methods which should return a proxy.  It maps method names to
typeid strings.  (If <em>method_to_typeid</em> is <code><span>None</span></code> then
<code><span>proxytype._method_to_typeid_</span></code> is used instead if it exists.)  If a
method’s name is not a key of this mapping or if the mapping is <code><span>None</span></code>
then the object returned by the method will be copied by value.</p>
<p><em>create_method</em> determines whether a method should be created with name
<em>typeid</em> which can be used to tell the server process to create a new
shared object and return a proxy for it.  By default it is <code><span>True</span></code>.</p>
</dd></dl>

<p><a><code><span>BaseManager</span></code></a> instances also have one read-only property:</p>
<dl>
<dt>
<code>address</code><a>¶</a></dt>
<dd><p>The address used by the manager.</p>
</dd></dl>

<div>
<p><span>Changed in version 3.3: </span>Manager objects support the context management protocol – see
<a><span>Context Manager Types</span></a>.  <a><code><span>__enter__()</span></code></a> starts the
server process (if it has not already started) and then returns the
manager object.  <a><code><span>__exit__()</span></code></a> calls <a><code><span>shutdown()</span></code></a>.</p>
<p>In previous versions <a><code><span>__enter__()</span></code></a> did not start the
manager’s server process if it was not already started.</p>
</div>
</dd></dl>

<dl>
<dt>
<em>class </em><code>multiprocessing.managers.</code><code>SyncManager</code><a>¶</a></dt>
<dd><p>A subclass of <a><code><span>BaseManager</span></code></a> which can be used for the synchronization
of processes.  Objects of this type are returned by
<code><span>multiprocessing.Manager()</span></code>.</p>
<p>Its methods create and return <a><span>Proxy Objects</span></a> for a
number of commonly used data types to be synchronized across processes.
This notably includes shared lists and dictionaries.</p>
<dl>
<dt>
<code>Barrier</code><span>(</span><em>parties</em><span>[</span>, <em>action</em><span>[</span>, <em>timeout</em><span>]</span><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>Create a shared <a><code><span>threading.Barrier</span></code></a> object and return a
proxy for it.</p>
<div>
<p><span>New in version 3.3.</span></p>
</div>
</dd></dl>

<dl>
<dt>
<code>BoundedSemaphore</code><span>(</span><span>[</span><em>value</em><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>Create a shared <a><code><span>threading.BoundedSemaphore</span></code></a> object and return a
proxy for it.</p>
</dd></dl>

<dl>
<dt>
<code>Condition</code><span>(</span><span>[</span><em>lock</em><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>Create a shared <a><code><span>threading.Condition</span></code></a> object and return a proxy for
it.</p>
<p>If <em>lock</em> is supplied then it should be a proxy for a
<a><code><span>threading.Lock</span></code></a> or <a><code><span>threading.RLock</span></code></a> object.</p>
<div>
<p><span>Changed in version 3.3: </span>The <a><code><span>wait_for()</span></code></a> method was added.</p>
</div>
</dd></dl>

<dl>
<dt>
<code>Event</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Create a shared <a><code><span>threading.Event</span></code></a> object and return a proxy for it.</p>
</dd></dl>

<dl>
<dt>
<code>Lock</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Create a shared <a><code><span>threading.Lock</span></code></a> object and return a proxy for it.</p>
</dd></dl>

<dl>
<dt>
<code>Namespace</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Create a shared <a><code><span>Namespace</span></code></a> object and return a proxy for it.</p>
</dd></dl>

<dl>
<dt>
<code>Queue</code><span>(</span><span>[</span><em>maxsize</em><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>Create a shared <a><code><span>queue.Queue</span></code></a> object and return a proxy for it.</p>
</dd></dl>

<dl>
<dt>
<code>RLock</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Create a shared <a><code><span>threading.RLock</span></code></a> object and return a proxy for it.</p>
</dd></dl>

<dl>
<dt>
<code>Semaphore</code><span>(</span><span>[</span><em>value</em><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>Create a shared <a><code><span>threading.Semaphore</span></code></a> object and return a proxy for
it.</p>
</dd></dl>

<dl>
<dt>
<code>Array</code><span>(</span><em>typecode</em>, <em>sequence</em><span>)</span><a>¶</a></dt>
<dd><p>Create an array and return a proxy for it.</p>
</dd></dl>

<dl>
<dt>
<code>Value</code><span>(</span><em>typecode</em>, <em>value</em><span>)</span><a>¶</a></dt>
<dd><p>Create an object with a writable <code><span>value</span></code> attribute and return a proxy
for it.</p>
</dd></dl>

<dl>
<dt>
<code>dict</code><span>(</span><span>)</span><a>¶</a></dt>
<dt>
<code>dict</code><span>(</span><em>mapping</em><span>)</span></dt>
<dt>
<code>dict</code><span>(</span><em>sequence</em><span>)</span></dt>
<dd><p>Create a shared <a><code><span>dict</span></code></a> object and return a proxy for it.</p>
</dd></dl>

<dl>
<dt>
<code>list</code><span>(</span><span>)</span><a>¶</a></dt>
<dt>
<code>list</code><span>(</span><em>sequence</em><span>)</span></dt>
<dd><p>Create a shared <a><code><span>list</span></code></a> object and return a proxy for it.</p>
</dd></dl>

<div>
<p><span>Changed in version 3.6: </span>Shared objects are capable of being nested.  For example, a shared
container object such as a shared list can contain other shared objects
which will all be managed and synchronized by the <a><code><span>SyncManager</span></code></a>.</p>
</div>
</dd></dl>

<dl>
<dt>
<em>class </em><code>multiprocessing.managers.</code><code>Namespace</code><a>¶</a></dt>
<dd><p>A type that can register with <a><code><span>SyncManager</span></code></a>.</p>
<p>A namespace object has no public methods, but does have writable attributes.
Its representation shows the values of its attributes.</p>
<p>However, when using a proxy for a namespace object, an attribute beginning
with <code><span>'_'</span></code> will be an attribute of the proxy and not an attribute of the
referent:</p>
<div><div><pre><span></span><span>&gt;&gt;&gt; </span><span>manager</span> <span>=</span> <span>multiprocessing</span><span>.</span><span>Manager</span><span>()</span>
<span>&gt;&gt;&gt; </span><span>Global</span> <span>=</span> <span>manager</span><span>.</span><span>Namespace</span><span>()</span>
<span>&gt;&gt;&gt; </span><span>Global</span><span>.</span><span>x</span> <span>=</span> <span>10</span>
<span>&gt;&gt;&gt; </span><span>Global</span><span>.</span><span>y</span> <span>=</span> <span>&#39;hello&#39;</span>
<span>&gt;&gt;&gt; </span><span>Global</span><span>.</span><span>_z</span> <span>=</span> <span>12.3</span>    <span># this is an attribute of the proxy</span>
<span>&gt;&gt;&gt; </span><span>print</span><span>(</span><span>Global</span><span>)</span>
<span>Namespace(x=10, y=&#39;hello&#39;)</span>
</pre></div>
</div>
</dd></dl>

<div>
<h4>17.2.2.7.1. Customized managers<a>¶</a></h4>
<p>To create one’s own manager, one creates a subclass of <a><code><span>BaseManager</span></code></a> and
uses the <a><code><span>register()</span></code></a> classmethod to register new types or
callables with the manager class.  For example:</p>
<div><div><pre><span></span><span>from</span> <span>multiprocessing.managers</span> <span>import</span> <span>BaseManager</span>

<span>class</span> <span>MathsClass</span><span>:</span>
    <span>def</span> <span>add</span><span>(</span><span>self</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>):</span>
        <span>return</span> <span>x</span> <span>+</span> <span>y</span>
    <span>def</span> <span>mul</span><span>(</span><span>self</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>):</span>
        <span>return</span> <span>x</span> <span>*</span> <span>y</span>

<span>class</span> <span>MyManager</span><span>(</span><span>BaseManager</span><span>):</span>
    <span>pass</span>

<span>MyManager</span><span>.</span><span>register</span><span>(</span><span>&#39;Maths&#39;</span><span>,</span> <span>MathsClass</span><span>)</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#39;__main__&#39;</span><span>:</span>
    <span>with</span> <span>MyManager</span><span>()</span> <span>as</span> <span>manager</span><span>:</span>
        <span>maths</span> <span>=</span> <span>manager</span><span>.</span><span>Maths</span><span>()</span>
        <span>print</span><span>(</span><span>maths</span><span>.</span><span>add</span><span>(</span><span>4</span><span>,</span> <span>3</span><span>))</span>         <span># prints 7</span>
        <span>print</span><span>(</span><span>maths</span><span>.</span><span>mul</span><span>(</span><span>7</span><span>,</span> <span>8</span><span>))</span>         <span># prints 56</span>
</pre></div>
</div>
</div>
<div>
<h4>17.2.2.7.2. Using a remote manager<a>¶</a></h4>
<p>It is possible to run a manager server on one machine and have clients use it
from other machines (assuming that the firewalls involved allow it).</p>
<p>Running the following commands creates a server for a single shared queue which
remote clients can access:</p>
<div><div><pre><span></span><span>&gt;&gt;&gt; </span><span>from</span> <span>multiprocessing.managers</span> <span>import</span> <span>BaseManager</span>
<span>&gt;&gt;&gt; </span><span>from</span> <span>queue</span> <span>import</span> <span>Queue</span>
<span>&gt;&gt;&gt; </span><span>queue</span> <span>=</span> <span>Queue</span><span>()</span>
<span>&gt;&gt;&gt; </span><span>class</span> <span>QueueManager</span><span>(</span><span>BaseManager</span><span>):</span> <span>pass</span>
<span>&gt;&gt;&gt; </span><span>QueueManager</span><span>.</span><span>register</span><span>(</span><span>&#39;get_queue&#39;</span><span>,</span> <span>callable</span><span>=</span><span>lambda</span><span>:</span><span>queue</span><span>)</span>
<span>&gt;&gt;&gt; </span><span>m</span> <span>=</span> <span>QueueManager</span><span>(</span><span>address</span><span>=</span><span>(</span><span>&#39;&#39;</span><span>,</span> <span>50000</span><span>),</span> <span>authkey</span><span>=</span><span>b</span><span>&#39;abracadabra&#39;</span><span>)</span>
<span>&gt;&gt;&gt; </span><span>s</span> <span>=</span> <span>m</span><span>.</span><span>get_server</span><span>()</span>
<span>&gt;&gt;&gt; </span><span>s</span><span>.</span><span>serve_forever</span><span>()</span>
</pre></div>
</div>
<p>One client can access the server as follows:</p>
<div><div><pre><span></span><span>&gt;&gt;&gt; </span><span>from</span> <span>multiprocessing.managers</span> <span>import</span> <span>BaseManager</span>
<span>&gt;&gt;&gt; </span><span>class</span> <span>QueueManager</span><span>(</span><span>BaseManager</span><span>):</span> <span>pass</span>
<span>&gt;&gt;&gt; </span><span>QueueManager</span><span>.</span><span>register</span><span>(</span><span>&#39;get_queue&#39;</span><span>)</span>
<span>&gt;&gt;&gt; </span><span>m</span> <span>=</span> <span>QueueManager</span><span>(</span><span>address</span><span>=</span><span>(</span><span>&#39;foo.bar.org&#39;</span><span>,</span> <span>50000</span><span>),</span> <span>authkey</span><span>=</span><span>b</span><span>&#39;abracadabra&#39;</span><span>)</span>
<span>&gt;&gt;&gt; </span><span>m</span><span>.</span><span>connect</span><span>()</span>
<span>&gt;&gt;&gt; </span><span>queue</span> <span>=</span> <span>m</span><span>.</span><span>get_queue</span><span>()</span>
<span>&gt;&gt;&gt; </span><span>queue</span><span>.</span><span>put</span><span>(</span><span>&#39;hello&#39;</span><span>)</span>
</pre></div>
</div>
<p>Another client can also use it:</p>
<div><div><pre><span></span><span>&gt;&gt;&gt; </span><span>from</span> <span>multiprocessing.managers</span> <span>import</span> <span>BaseManager</span>
<span>&gt;&gt;&gt; </span><span>class</span> <span>QueueManager</span><span>(</span><span>BaseManager</span><span>):</span> <span>pass</span>
<span>&gt;&gt;&gt; </span><span>QueueManager</span><span>.</span><span>register</span><span>(</span><span>&#39;get_queue&#39;</span><span>)</span>
<span>&gt;&gt;&gt; </span><span>m</span> <span>=</span> <span>QueueManager</span><span>(</span><span>address</span><span>=</span><span>(</span><span>&#39;foo.bar.org&#39;</span><span>,</span> <span>50000</span><span>),</span> <span>authkey</span><span>=</span><span>b</span><span>&#39;abracadabra&#39;</span><span>)</span>
<span>&gt;&gt;&gt; </span><span>m</span><span>.</span><span>connect</span><span>()</span>
<span>&gt;&gt;&gt; </span><span>queue</span> <span>=</span> <span>m</span><span>.</span><span>get_queue</span><span>()</span>
<span>&gt;&gt;&gt; </span><span>queue</span><span>.</span><span>get</span><span>()</span>
<span>&#39;hello&#39;</span>
</pre></div>
</div>
<p>Local processes can also access that queue, using the code from above on the
client to access it remotely:</p>
<div><div><pre><span></span><span>&gt;&gt;&gt; </span><span>from</span> <span>multiprocessing</span> <span>import</span> <span>Process</span><span>,</span> <span>Queue</span>
<span>&gt;&gt;&gt; </span><span>from</span> <span>multiprocessing.managers</span> <span>import</span> <span>BaseManager</span>
<span>&gt;&gt;&gt; </span><span>class</span> <span>Worker</span><span>(</span><span>Process</span><span>):</span>
<span>... </span>    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>q</span><span>):</span>
<span>... </span>        <span>self</span><span>.</span><span>q</span> <span>=</span> <span>q</span>
<span>... </span>        <span>super</span><span>(</span><span>Worker</span><span>,</span> <span>self</span><span>)</span><span>.</span><span>__init__</span><span>()</span>
<span>... </span>    <span>def</span> <span>run</span><span>(</span><span>self</span><span>):</span>
<span>... </span>        <span>self</span><span>.</span><span>q</span><span>.</span><span>put</span><span>(</span><span>&#39;local hello&#39;</span><span>)</span>
<span>...</span>
<span>&gt;&gt;&gt; </span><span>queue</span> <span>=</span> <span>Queue</span><span>()</span>
<span>&gt;&gt;&gt; </span><span>w</span> <span>=</span> <span>Worker</span><span>(</span><span>queue</span><span>)</span>
<span>&gt;&gt;&gt; </span><span>w</span><span>.</span><span>start</span><span>()</span>
<span>&gt;&gt;&gt; </span><span>class</span> <span>QueueManager</span><span>(</span><span>BaseManager</span><span>):</span> <span>pass</span>
<span>...</span>
<span>&gt;&gt;&gt; </span><span>QueueManager</span><span>.</span><span>register</span><span>(</span><span>&#39;get_queue&#39;</span><span>,</span> <span>callable</span><span>=</span><span>lambda</span><span>:</span> <span>queue</span><span>)</span>
<span>&gt;&gt;&gt; </span><span>m</span> <span>=</span> <span>QueueManager</span><span>(</span><span>address</span><span>=</span><span>(</span><span>&#39;&#39;</span><span>,</span> <span>50000</span><span>),</span> <span>authkey</span><span>=</span><span>b</span><span>&#39;abracadabra&#39;</span><span>)</span>
<span>&gt;&gt;&gt; </span><span>s</span> <span>=</span> <span>m</span><span>.</span><span>get_server</span><span>()</span>
<span>&gt;&gt;&gt; </span><span>s</span><span>.</span><span>serve_forever</span><span>()</span>
</pre></div>
</div>
</div>
</div>
<div>
<span></span><h3>17.2.2.8. Proxy Objects<a>¶</a></h3>
<p>A proxy is an object which <em>refers</em> to a shared object which lives (presumably)
in a different process.  The shared object is said to be the <em>referent</em> of the
proxy.  Multiple proxy objects may have the same referent.</p>
<p>A proxy object has methods which invoke corresponding methods of its referent
(although not every method of the referent will necessarily be available through
the proxy).  In this way, a proxy can be used just like its referent can:</p>
<div><div><pre><span></span><span>&gt;&gt;&gt; </span><span>from</span> <span>multiprocessing</span> <span>import</span> <span>Manager</span>
<span>&gt;&gt;&gt; </span><span>manager</span> <span>=</span> <span>Manager</span><span>()</span>
<span>&gt;&gt;&gt; </span><span>l</span> <span>=</span> <span>manager</span><span>.</span><span>list</span><span>([</span><span>i</span><span>*</span><span>i</span> <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>10</span><span>)])</span>
<span>&gt;&gt;&gt; </span><span>print</span><span>(</span><span>l</span><span>)</span>
<span>[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span>
<span>&gt;&gt;&gt; </span><span>print</span><span>(</span><span>repr</span><span>(</span><span>l</span><span>))</span>
<span>&lt;ListProxy object, typeid &#39;list&#39; at 0x...&gt;</span>
<span>&gt;&gt;&gt; </span><span>l</span><span>[</span><span>4</span><span>]</span>
<span>16</span>
<span>&gt;&gt;&gt; </span><span>l</span><span>[</span><span>2</span><span>:</span><span>5</span><span>]</span>
<span>[4, 9, 16]</span>
</pre></div>
</div>
<p>Notice that applying <a><code><span>str()</span></code></a> to a proxy will return the representation of
the referent, whereas applying <a><code><span>repr()</span></code></a> will return the representation of
the proxy.</p>
<p>An important feature of proxy objects is that they are picklable so they can be
passed between processes.  As such, a referent can contain
<a><span>Proxy Objects</span></a>.  This permits nesting of these managed
lists, dicts, and other <a><span>Proxy Objects</span></a>:</p>
<div><div><pre><span></span><span>&gt;&gt;&gt; </span><span>a</span> <span>=</span> <span>manager</span><span>.</span><span>list</span><span>()</span>
<span>&gt;&gt;&gt; </span><span>b</span> <span>=</span> <span>manager</span><span>.</span><span>list</span><span>()</span>
<span>&gt;&gt;&gt; </span><span>a</span><span>.</span><span>append</span><span>(</span><span>b</span><span>)</span>         <span># referent of a now contains referent of b</span>
<span>&gt;&gt;&gt; </span><span>print</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span>
<span>[&lt;ListProxy object, typeid &#39;list&#39; at ...&gt;] []</span>
<span>&gt;&gt;&gt; </span><span>b</span><span>.</span><span>append</span><span>(</span><span>&#39;hello&#39;</span><span>)</span>
<span>&gt;&gt;&gt; </span><span>print</span><span>(</span><span>a</span><span>[</span><span>0</span><span>],</span> <span>b</span><span>)</span>
<span>[&#39;hello&#39;] [&#39;hello&#39;]</span>
</pre></div>
</div>
<p>Similarly, dict and list proxies may be nested inside one another:</p>
<div><div><pre><span></span><span>&gt;&gt;&gt; </span><span>l_outer</span> <span>=</span> <span>manager</span><span>.</span><span>list</span><span>([</span> <span>manager</span><span>.</span><span>dict</span><span>()</span> <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>2</span><span>)</span> <span>])</span>
<span>&gt;&gt;&gt; </span><span>d_first_inner</span> <span>=</span> <span>l_outer</span><span>[</span><span>0</span><span>]</span>
<span>&gt;&gt;&gt; </span><span>d_first_inner</span><span>[</span><span>&#39;a&#39;</span><span>]</span> <span>=</span> <span>1</span>
<span>&gt;&gt;&gt; </span><span>d_first_inner</span><span>[</span><span>&#39;b&#39;</span><span>]</span> <span>=</span> <span>2</span>
<span>&gt;&gt;&gt; </span><span>l_outer</span><span>[</span><span>1</span><span>][</span><span>&#39;c&#39;</span><span>]</span> <span>=</span> <span>3</span>
<span>&gt;&gt;&gt; </span><span>l_outer</span><span>[</span><span>1</span><span>][</span><span>&#39;z&#39;</span><span>]</span> <span>=</span> <span>26</span>
<span>&gt;&gt;&gt; </span><span>print</span><span>(</span><span>l_outer</span><span>[</span><span>0</span><span>])</span>
<span>{&#39;a&#39;: 1, &#39;b&#39;: 2}</span>
<span>&gt;&gt;&gt; </span><span>print</span><span>(</span><span>l_outer</span><span>[</span><span>1</span><span>])</span>
<span>{&#39;c&#39;: 3, &#39;z&#39;: 26}</span>
</pre></div>
</div>
<p>If standard (non-proxy) <a><code><span>list</span></code></a> or <a><code><span>dict</span></code></a> objects are contained
in a referent, modifications to those mutable values will not be propagated
through the manager because the proxy has no way of knowing when the values
contained within are modified.  However, storing a value in a container proxy
(which triggers a <code><span>__setitem__</span></code> on the proxy object) does propagate through
the manager and so to effectively modify such an item, one could re-assign the
modified value to the container proxy:</p>
<div><div><pre><span></span><span># create a list proxy and append a mutable object (a dictionary)</span>
<span>lproxy</span> <span>=</span> <span>manager</span><span>.</span><span>list</span><span>()</span>
<span>lproxy</span><span>.</span><span>append</span><span>({})</span>
<span># now mutate the dictionary</span>
<span>d</span> <span>=</span> <span>lproxy</span><span>[</span><span>0</span><span>]</span>
<span>d</span><span>[</span><span>&#39;a&#39;</span><span>]</span> <span>=</span> <span>1</span>
<span>d</span><span>[</span><span>&#39;b&#39;</span><span>]</span> <span>=</span> <span>2</span>
<span># at this point, the changes to d are not yet synced, but by</span>
<span># updating the dictionary, the proxy is notified of the change</span>
<span>lproxy</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>d</span>
</pre></div>
</div>
<p>This approach is perhaps less convenient than employing nested
<a><span>Proxy Objects</span></a> for most use cases but also
demonstrates a level of control over the synchronization.</p>
<div>
<p>Note</p>
<p>The proxy types in <a><code><span>multiprocessing</span></code></a> do nothing to support comparisons
by value.  So, for instance, we have:</p>
<div><div><pre><span></span><span>&gt;&gt;&gt; </span><span>manager</span><span>.</span><span>list</span><span>([</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>])</span> <span>==</span> <span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>]</span>
<span>False</span>
</pre></div>
</div>
<p>One should just use a copy of the referent instead when making comparisons.</p>
</div>
<dl>
<dt>
<em>class </em><code>multiprocessing.managers.</code><code>BaseProxy</code><a>¶</a></dt>
<dd><p>Proxy objects are instances of subclasses of <a><code><span>BaseProxy</span></code></a>.</p>
<dl>
<dt>
<code>_callmethod</code><span>(</span><em>methodname</em><span>[</span>, <em>args</em><span>[</span>, <em>kwds</em><span>]</span><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>Call and return the result of a method of the proxy’s referent.</p>
<p>If <code><span>proxy</span></code> is a proxy whose referent is <code><span>obj</span></code> then the expression</p>
<div><div><pre><span></span><span>proxy</span><span>.</span><span>_callmethod</span><span>(</span><span>methodname</span><span>,</span> <span>args</span><span>,</span> <span>kwds</span><span>)</span>
</pre></div>
</div>
<p>will evaluate the expression</p>
<div><div><pre><span></span><span>getattr</span><span>(</span><span>obj</span><span>,</span> <span>methodname</span><span>)(</span><span>*</span><span>args</span><span>,</span> <span>**</span><span>kwds</span><span>)</span>
</pre></div>
</div>
<p>in the manager’s process.</p>
<p>The returned value will be a copy of the result of the call or a proxy to
a new shared object – see documentation for the <em>method_to_typeid</em>
argument of <a><code><span>BaseManager.register()</span></code></a>.</p>
<p>If an exception is raised by the call, then is re-raised by
<a><code><span>_callmethod()</span></code></a>.  If some other exception is raised in the manager’s
process then this is converted into a <code><span>RemoteError</span></code> exception and is
raised by <a><code><span>_callmethod()</span></code></a>.</p>
<p>Note in particular that an exception will be raised if <em>methodname</em> has
not been <em>exposed</em>.</p>
<p>An example of the usage of <a><code><span>_callmethod()</span></code></a>:</p>
<div><div><pre><span></span><span>&gt;&gt;&gt; </span><span>l</span> <span>=</span> <span>manager</span><span>.</span><span>list</span><span>(</span><span>range</span><span>(</span><span>10</span><span>))</span>
<span>&gt;&gt;&gt; </span><span>l</span><span>.</span><span>_callmethod</span><span>(</span><span>&#39;__len__&#39;</span><span>)</span>
<span>10</span>
<span>&gt;&gt;&gt; </span><span>l</span><span>.</span><span>_callmethod</span><span>(</span><span>&#39;__getitem__&#39;</span><span>,</span> <span>(</span><span>slice</span><span>(</span><span>2</span><span>,</span> <span>7</span><span>),))</span> <span># equivalent to l[2:7]</span>
<span>[2, 3, 4, 5, 6]</span>
<span>&gt;&gt;&gt; </span><span>l</span><span>.</span><span>_callmethod</span><span>(</span><span>&#39;__getitem__&#39;</span><span>,</span> <span>(</span><span>20</span><span>,))</span>          <span># equivalent to l[20]</span>
<span>Traceback (most recent call last):</span>
<span>...</span>
<span>IndexError</span>: <span>list index out of range</span>
</pre></div>
</div>
</dd></dl>

<dl>
<dt>
<code>_getvalue</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Return a copy of the referent.</p>
<p>If the referent is unpicklable then this will raise an exception.</p>
</dd></dl>

<dl>
<dt>
<code>__repr__</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Return a representation of the proxy object.</p>
</dd></dl>

<dl>
<dt>
<code>__str__</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Return the representation of the referent.</p>
</dd></dl>

</dd></dl>

<div>
<h4>17.2.2.8.1. Cleanup<a>¶</a></h4>
<p>A proxy object uses a weakref callback so that when it gets garbage collected it
deregisters itself from the manager which owns its referent.</p>
<p>A shared object gets deleted from the manager process when there are no longer
any proxies referring to it.</p>
</div>
</div>
<div>
<span></span><h3>17.2.2.9. Process Pools<a>¶</a></h3>
<p>One can create a pool of processes which will carry out tasks submitted to it
with the <a><code><span>Pool</span></code></a> class.</p>
<dl>
<dt>
<em>class </em><code>multiprocessing.pool.</code><code>Pool</code><span>(</span><span>[</span><em>processes</em><span>[</span>, <em>initializer</em><span>[</span>, <em>initargs</em><span>[</span>, <em>maxtasksperchild</em><span>[</span>, <em>context</em><span>]</span><span>]</span><span>]</span><span>]</span><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>A process pool object which controls a pool of worker processes to which jobs
can be submitted.  It supports asynchronous results with timeouts and
callbacks and has a parallel map implementation.</p>
<p><em>processes</em> is the number of worker processes to use.  If <em>processes</em> is
<code><span>None</span></code> then the number returned by <a><code><span>os.cpu_count()</span></code></a> is used.</p>
<p>If <em>initializer</em> is not <code><span>None</span></code> then each worker process will call
<code><span>initializer(*initargs)</span></code> when it starts.</p>
<p><em>maxtasksperchild</em> is the number of tasks a worker process can complete
before it will exit and be replaced with a fresh worker process, to enable
unused resources to be freed. The default <em>maxtasksperchild</em> is <code><span>None</span></code>, which
means worker processes will live as long as the pool.</p>
<p><em>context</em> can be used to specify the context used for starting
the worker processes.  Usually a pool is created using the
function <code><span>multiprocessing.Pool()</span></code> or the <a><code><span>Pool()</span></code></a> method
of a context object.  In both cases <em>context</em> is set
appropriately.</p>
<p>Note that the methods of the pool object should only be called by
the process which created the pool.</p>
<div>
<p><span>New in version 3.2: </span><em>maxtasksperchild</em></p>
</div>
<div>
<p><span>New in version 3.4: </span><em>context</em></p>
</div>
<div>
<p>Note</p>
<p>Worker processes within a <a><code><span>Pool</span></code></a> typically live for the complete
duration of the Pool’s work queue. A frequent pattern found in other
systems (such as Apache, mod_wsgi, etc) to free resources held by
workers is to allow a worker within a pool to complete only a set
amount of work before being exiting, being cleaned up and a new
process spawned to replace the old one. The <em>maxtasksperchild</em>
argument to the <a><code><span>Pool</span></code></a> exposes this ability to the end user.</p>
</div>
<dl>
<dt>
<code>apply</code><span>(</span><em>func</em><span>[</span>, <em>args</em><span>[</span>, <em>kwds</em><span>]</span><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>Call <em>func</em> with arguments <em>args</em> and keyword arguments <em>kwds</em>.  It blocks
until the result is ready. Given this blocks, <a><code><span>apply_async()</span></code></a> is
better suited for performing work in parallel. Additionally, <em>func</em>
is only executed in one of the workers of the pool.</p>
</dd></dl>

<dl>
<dt>
<code>apply_async</code><span>(</span><em>func</em><span>[</span>, <em>args</em><span>[</span>, <em>kwds</em><span>[</span>, <em>callback</em><span>[</span>, <em>error_callback</em><span>]</span><span>]</span><span>]</span><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>A variant of the <a><code><span>apply()</span></code></a> method which returns a result object.</p>
<p>If <em>callback</em> is specified then it should be a callable which accepts a
single argument.  When the result becomes ready <em>callback</em> is applied to
it, that is unless the call failed, in which case the <em>error_callback</em>
is applied instead.</p>
<p>If <em>error_callback</em> is specified then it should be a callable which
accepts a single argument.  If the target function fails, then
the <em>error_callback</em> is called with the exception instance.</p>
<p>Callbacks should complete immediately since otherwise the thread which
handles the results will get blocked.</p>
</dd></dl>

<dl>
<dt>
<code>map</code><span>(</span><em>func</em>, <em>iterable</em><span>[</span>, <em>chunksize</em><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>A parallel equivalent of the <a><code><span>map()</span></code></a> built-in function (it supports only
one <em>iterable</em> argument though).  It blocks until the result is ready.</p>
<p>This method chops the iterable into a number of chunks which it submits to
the process pool as separate tasks.  The (approximate) size of these
chunks can be specified by setting <em>chunksize</em> to a positive integer.</p>
</dd></dl>

<dl>
<dt>
<code>map_async</code><span>(</span><em>func</em>, <em>iterable</em><span>[</span>, <em>chunksize</em><span>[</span>, <em>callback</em><span>[</span>, <em>error_callback</em><span>]</span><span>]</span><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>A variant of the <a><code><span>map()</span></code></a> method which returns a result object.</p>
<p>If <em>callback</em> is specified then it should be a callable which accepts a
single argument.  When the result becomes ready <em>callback</em> is applied to
it, that is unless the call failed, in which case the <em>error_callback</em>
is applied instead.</p>
<p>If <em>error_callback</em> is specified then it should be a callable which
accepts a single argument.  If the target function fails, then
the <em>error_callback</em> is called with the exception instance.</p>
<p>Callbacks should complete immediately since otherwise the thread which
handles the results will get blocked.</p>
</dd></dl>

<dl>
<dt>
<code>imap</code><span>(</span><em>func</em>, <em>iterable</em><span>[</span>, <em>chunksize</em><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>A lazier version of <a><code><span>map()</span></code></a>.</p>
<p>The <em>chunksize</em> argument is the same as the one used by the <a><code><span>map()</span></code></a>
method.  For very long iterables using a large value for <em>chunksize</em> can
make the job complete <strong>much</strong> faster than using the default value of
<code><span>1</span></code>.</p>
<p>Also if <em>chunksize</em> is <code><span>1</span></code> then the <code><span>next()</span></code> method of the iterator
returned by the <a><code><span>imap()</span></code></a> method has an optional <em>timeout</em> parameter:
<code><span>next(timeout)</span></code> will raise <a><code><span>multiprocessing.TimeoutError</span></code></a> if the
result cannot be returned within <em>timeout</em> seconds.</p>
</dd></dl>

<dl>
<dt>
<code>imap_unordered</code><span>(</span><em>func</em>, <em>iterable</em><span>[</span>, <em>chunksize</em><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>The same as <a><code><span>imap()</span></code></a> except that the ordering of the results from the
returned iterator should be considered arbitrary.  (Only when there is
only one worker process is the order guaranteed to be “correct”.)</p>
</dd></dl>

<dl>
<dt>
<code>starmap</code><span>(</span><em>func</em>, <em>iterable</em><span>[</span>, <em>chunksize</em><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>Like <a><code><span>map()</span></code></a> except that the elements of the <em>iterable</em> are expected
to be iterables that are unpacked as arguments.</p>
<p>Hence an <em>iterable</em> of <code><span>[(1,2),</span> <span>(3,</span> <span>4)]</span></code> results in <code><span>[func(1,2),</span>
<span>func(3,4)]</span></code>.</p>
<div>
<p><span>New in version 3.3.</span></p>
</div>
</dd></dl>

<dl>
<dt>
<code>starmap_async</code><span>(</span><em>func</em>, <em>iterable</em><span>[</span>, <em>chunksize</em><span>[</span>, <em>callback</em><span>[</span>, <em>error_callback</em><span>]</span><span>]</span><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>A combination of <a><code><span>starmap()</span></code></a> and <a><code><span>map_async()</span></code></a> that iterates over
<em>iterable</em> of iterables and calls <em>func</em> with the iterables unpacked.
Returns a result object.</p>
<div>
<p><span>New in version 3.3.</span></p>
</div>
</dd></dl>

<dl>
<dt>
<code>close</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Prevents any more tasks from being submitted to the pool.  Once all the
tasks have been completed the worker processes will exit.</p>
</dd></dl>

<dl>
<dt>
<code>terminate</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Stops the worker processes immediately without completing outstanding
work.  When the pool object is garbage collected <a><code><span>terminate()</span></code></a> will be
called immediately.</p>
</dd></dl>

<dl>
<dt>
<code>join</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Wait for the worker processes to exit.  One must call <a><code><span>close()</span></code></a> or
<a><code><span>terminate()</span></code></a> before using <a><code><span>join()</span></code></a>.</p>
</dd></dl>

<div>
<p><span>New in version 3.3: </span>Pool objects now support the context management protocol – see
<a><span>Context Manager Types</span></a>.  <a><code><span>__enter__()</span></code></a> returns the
pool object, and <a><code><span>__exit__()</span></code></a> calls <a><code><span>terminate()</span></code></a>.</p>
</div>
</dd></dl>

<dl>
<dt>
<em>class </em><code>multiprocessing.pool.</code><code>AsyncResult</code><a>¶</a></dt>
<dd><p>The class of the result returned by <a><code><span>Pool.apply_async()</span></code></a> and
<a><code><span>Pool.map_async()</span></code></a>.</p>
<dl>
<dt>
<code>get</code><span>(</span><span>[</span><em>timeout</em><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>Return the result when it arrives.  If <em>timeout</em> is not <code><span>None</span></code> and the
result does not arrive within <em>timeout</em> seconds then
<a><code><span>multiprocessing.TimeoutError</span></code></a> is raised.  If the remote call raised
an exception then that exception will be reraised by <a><code><span>get()</span></code></a>.</p>
</dd></dl>

<dl>
<dt>
<code>wait</code><span>(</span><span>[</span><em>timeout</em><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>Wait until the result is available or until <em>timeout</em> seconds pass.</p>
</dd></dl>

<dl>
<dt>
<code>ready</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Return whether the call has completed.</p>
</dd></dl>

<dl>
<dt>
<code>successful</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Return whether the call completed without raising an exception.  Will
raise <a><code><span>AssertionError</span></code></a> if the result is not ready.</p>
</dd></dl>

</dd></dl>

<p>The following example demonstrates the use of a pool:</p>
<div><div><pre><span></span><span>from</span> <span>multiprocessing</span> <span>import</span> <span>Pool</span>
<span>import</span> <span>time</span>

<span>def</span> <span>f</span><span>(</span><span>x</span><span>):</span>
    <span>return</span> <span>x</span><span>*</span><span>x</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#39;__main__&#39;</span><span>:</span>
    <span>with</span> <span>Pool</span><span>(</span><span>processes</span><span>=</span><span>4</span><span>)</span> <span>as</span> <span>pool</span><span>:</span>         <span># start 4 worker processes</span>
        <span>result</span> <span>=</span> <span>pool</span><span>.</span><span>apply_async</span><span>(</span><span>f</span><span>,</span> <span>(</span><span>10</span><span>,))</span> <span># evaluate &quot;f(10)&quot; asynchronously in a single process</span>
        <span>print</span><span>(</span><span>result</span><span>.</span><span>get</span><span>(</span><span>timeout</span><span>=</span><span>1</span><span>))</span>        <span># prints &quot;100&quot; unless your computer is *very* slow</span>

        <span>print</span><span>(</span><span>pool</span><span>.</span><span>map</span><span>(</span><span>f</span><span>,</span> <span>range</span><span>(</span><span>10</span><span>)))</span>       <span># prints &quot;[0, 1, 4,..., 81]&quot;</span>

        <span>it</span> <span>=</span> <span>pool</span><span>.</span><span>imap</span><span>(</span><span>f</span><span>,</span> <span>range</span><span>(</span><span>10</span><span>))</span>
        <span>print</span><span>(</span><span>next</span><span>(</span><span>it</span><span>))</span>                     <span># prints &quot;0&quot;</span>
        <span>print</span><span>(</span><span>next</span><span>(</span><span>it</span><span>))</span>                     <span># prints &quot;1&quot;</span>
        <span>print</span><span>(</span><span>it</span><span>.</span><span>next</span><span>(</span><span>timeout</span><span>=</span><span>1</span><span>))</span>           <span># prints &quot;4&quot; unless your computer is *very* slow</span>

        <span>result</span> <span>=</span> <span>pool</span><span>.</span><span>apply_async</span><span>(</span><span>time</span><span>.</span><span>sleep</span><span>,</span> <span>(</span><span>10</span><span>,))</span>
        <span>print</span><span>(</span><span>result</span><span>.</span><span>get</span><span>(</span><span>timeout</span><span>=</span><span>1</span><span>))</span>        <span># raises multiprocessing.TimeoutError</span>
</pre></div>
</div>
</div>
<div>
<span></span><span></span><h3>17.2.2.10. Listeners and Clients<a>¶</a></h3>
<p>Usually message passing between processes is done using queues or by using
<a><code><span>Connection</span></code></a> objects returned by
<a><code><span>Pipe()</span></code></a>.</p>
<p>However, the <a><code><span>multiprocessing.connection</span></code></a> module allows some extra
flexibility.  It basically gives a high level message oriented API for dealing
with sockets or Windows named pipes.  It also has support for <em>digest
authentication</em> using the <a><code><span>hmac</span></code></a> module, and for polling
multiple connections at the same time.</p>
<dl>
<dt>
<code>multiprocessing.connection.</code><code>deliver_challenge</code><span>(</span><em>connection</em>, <em>authkey</em><span>)</span><a>¶</a></dt>
<dd><p>Send a randomly generated message to the other end of the connection and wait
for a reply.</p>
<p>If the reply matches the digest of the message using <em>authkey</em> as the key
then a welcome message is sent to the other end of the connection.  Otherwise
<a><code><span>AuthenticationError</span></code></a> is raised.</p>
</dd></dl>

<dl>
<dt>
<code>multiprocessing.connection.</code><code>answer_challenge</code><span>(</span><em>connection</em>, <em>authkey</em><span>)</span><a>¶</a></dt>
<dd><p>Receive a message, calculate the digest of the message using <em>authkey</em> as the
key, and then send the digest back.</p>
<p>If a welcome message is not received, then
<a><code><span>AuthenticationError</span></code></a> is raised.</p>
</dd></dl>

<dl>
<dt>
<code>multiprocessing.connection.</code><code>Client</code><span>(</span><em>address</em><span>[</span>, <em>family</em><span>[</span>, <em>authkey</em><span>]</span><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>Attempt to set up a connection to the listener which is using address
<em>address</em>, returning a <a><code><span>Connection</span></code></a>.</p>
<p>The type of the connection is determined by <em>family</em> argument, but this can
generally be omitted since it can usually be inferred from the format of
<em>address</em>. (See <a><span>Address Formats</span></a>)</p>
<p>If <em>authkey</em> is given and not None, it should be a byte string and will be
used as the secret key for an HMAC-based authentication challenge. No
authentication is done if <em>authkey</em> is None.
<a><code><span>AuthenticationError</span></code></a> is raised if authentication fails.
See <a><span>Authentication keys</span></a>.</p>
</dd></dl>

<dl>
<dt>
<em>class </em><code>multiprocessing.connection.</code><code>Listener</code><span>(</span><span>[</span><em>address</em><span>[</span>, <em>family</em><span>[</span>, <em>backlog</em><span>[</span>, <em>authkey</em><span>]</span><span>]</span><span>]</span><span>]</span><span>)</span><a>¶</a></dt>
<dd><p>A wrapper for a bound socket or Windows named pipe which is ‘listening’ for
connections.</p>
<p><em>address</em> is the address to be used by the bound socket or named pipe of the
listener object.</p>
<div>
<p>Note</p>
<p>If an address of ‘0.0.0.0’ is used, the address will not be a connectable
end point on Windows. If you require a connectable end-point,
you should use ‘127.0.0.1’.</p>
</div>
<p><em>family</em> is the type of socket (or named pipe) to use.  This can be one of
the strings <code><span>'AF_INET'</span></code> (for a TCP socket), <code><span>'AF_UNIX'</span></code> (for a Unix
domain socket) or <code><span>'AF_PIPE'</span></code> (for a Windows named pipe).  Of these only
the first is guaranteed to be available.  If <em>family</em> is <code><span>None</span></code> then the
family is inferred from the format of <em>address</em>.  If <em>address</em> is also
<code><span>None</span></code> then a default is chosen.  This default is the family which is
assumed to be the fastest available.  See
<a><span>Address Formats</span></a>.  Note that if <em>family</em> is
<code><span>'AF_UNIX'</span></code> and address is <code><span>None</span></code> then the socket will be created in a
private temporary directory created using <a><code><span>tempfile.mkstemp()</span></code></a>.</p>
<p>If the listener object uses a socket then <em>backlog</em> (1 by default) is passed
to the <a><code><span>listen()</span></code></a> method of the socket once it has been
bound.</p>
<p>If <em>authkey</em> is given and not None, it should be a byte string and will be
used as the secret key for an HMAC-based authentication challenge. No
authentication is done if <em>authkey</em> is None.
<a><code><span>AuthenticationError</span></code></a> is raised if authentication fails.
See <a><span>Authentication keys</span></a>.</p>
<dl>
<dt>
<code>accept</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Accept a connection on the bound socket or named pipe of the listener
object and return a <a><code><span>Connection</span></code></a> object.
If authentication is attempted and fails, then
<a><code><span>AuthenticationError</span></code></a> is raised.</p>
</dd></dl>

<dl>
<dt>
<code>close</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Close the bound socket or named pipe of the listener object.  This is
called automatically when the listener is garbage collected.  However it
is advisable to call it explicitly.</p>
</dd></dl>

<p>Listener objects have the following read-only properties:</p>
<dl>
<dt>
<code>address</code><a>¶</a></dt>
<dd><p>The address which is being used by the Listener object.</p>
</dd></dl>

<dl>
<dt>
<code>last_accepted</code><a>¶</a></dt>
<dd><p>The address from which the last accepted connection came.  If this is
unavailable then it is <code><span>None</span></code>.</p>
</dd></dl>

<div>
<p><span>New in version 3.3: </span>Listener objects now support the context management protocol – see
<a><span>Context Manager Types</span></a>.  <a><code><span>__enter__()</span></code></a> returns the
listener object, and <a><code><span>__exit__()</span></code></a> calls <a><code><span>close()</span></code></a>.</p>
</div>
</dd></dl>

<dl>
<dt>
<code>multiprocessing.connection.</code><code>wait</code><span>(</span><em>object_list</em>, <em>timeout=None</em><span>)</span><a>¶</a></dt>
<dd><p>Wait till an object in <em>object_list</em> is ready.  Returns the list of
those objects in <em>object_list</em> which are ready.  If <em>timeout</em> is a
float then the call blocks for at most that many seconds.  If
<em>timeout</em> is <code><span>None</span></code> then it will block for an unlimited period.
A negative timeout is equivalent to a zero timeout.</p>
<p>For both Unix and Windows, an object can appear in <em>object_list</em> if
it is</p>
<ul>
<li>a readable <a><code><span>Connection</span></code></a> object;</li>
<li>a connected and readable <a><code><span>socket.socket</span></code></a> object; or</li>
<li>the <a><code><span>sentinel</span></code></a> attribute of a
<a><code><span>Process</span></code></a> object.</li>
</ul>
<p>A connection or socket object is ready when there is data available
to be read from it, or the other end has been closed.</p>
<p><strong>Unix</strong>: <code><span>wait(object_list,</span> <span>timeout)</span></code> almost equivalent
<code><span>select.select(object_list,</span> <span>[],</span> <span>[],</span> <span>timeout)</span></code>.  The difference is
that, if <a><code><span>select.select()</span></code></a> is interrupted by a signal, it can
raise <a><code><span>OSError</span></code></a> with an error number of <code><span>EINTR</span></code>, whereas
<a><code><span>wait()</span></code></a> will not.</p>
<p><strong>Windows</strong>: An item in <em>object_list</em> must either be an integer
handle which is waitable (according to the definition used by the
documentation of the Win32 function <code><span>WaitForMultipleObjects()</span></code>)
or it can be an object with a <code><span>fileno()</span></code> method which returns a
socket handle or pipe handle.  (Note that pipe handles and socket
handles are <strong>not</strong> waitable handles.)</p>
<div>
<p><span>New in version 3.3.</span></p>
</div>
</dd></dl>

<p><strong>Examples</strong></p>
<p>The following server code creates a listener which uses <code><span>'secret</span> <span>password'</span></code> as
an authentication key.  It then waits for a connection and sends some data to
the client:</p>
<div><div><pre><span></span><span>from</span> <span>multiprocessing.connection</span> <span>import</span> <span>Listener</span>
<span>from</span> <span>array</span> <span>import</span> <span>array</span>

<span>address</span> <span>=</span> <span>(</span><span>&#39;localhost&#39;</span><span>,</span> <span>6000</span><span>)</span>     <span># family is deduced to be &#39;AF_INET&#39;</span>

<span>with</span> <span>Listener</span><span>(</span><span>address</span><span>,</span> <span>authkey</span><span>=</span><span>b</span><span>&#39;secret password&#39;</span><span>)</span> <span>as</span> <span>listener</span><span>:</span>
    <span>with</span> <span>listener</span><span>.</span><span>accept</span><span>()</span> <span>as</span> <span>conn</span><span>:</span>
        <span>print</span><span>(</span><span>&#39;connection accepted from&#39;</span><span>,</span> <span>listener</span><span>.</span><span>last_accepted</span><span>)</span>

        <span>conn</span><span>.</span><span>send</span><span>([</span><span>2.25</span><span>,</span> <span>None</span><span>,</span> <span>&#39;junk&#39;</span><span>,</span> <span>float</span><span>])</span>

        <span>conn</span><span>.</span><span>send_bytes</span><span>(</span><span>b</span><span>&#39;hello&#39;</span><span>)</span>

        <span>conn</span><span>.</span><span>send_bytes</span><span>(</span><span>array</span><span>(</span><span>&#39;i&#39;</span><span>,</span> <span>[</span><span>42</span><span>,</span> <span>1729</span><span>]))</span>
</pre></div>
</div>
<p>The following code connects to the server and receives some data from the
server:</p>
<div><div><pre><span></span><span>from</span> <span>multiprocessing.connection</span> <span>import</span> <span>Client</span>
<span>from</span> <span>array</span> <span>import</span> <span>array</span>

<span>address</span> <span>=</span> <span>(</span><span>&#39;localhost&#39;</span><span>,</span> <span>6000</span><span>)</span>

<span>with</span> <span>Client</span><span>(</span><span>address</span><span>,</span> <span>authkey</span><span>=</span><span>b</span><span>&#39;secret password&#39;</span><span>)</span> <span>as</span> <span>conn</span><span>:</span>
    <span>print</span><span>(</span><span>conn</span><span>.</span><span>recv</span><span>())</span>                  <span># =&gt; [2.25, None, &#39;junk&#39;, float]</span>

    <span>print</span><span>(</span><span>conn</span><span>.</span><span>recv_bytes</span><span>())</span>            <span># =&gt; &#39;hello&#39;</span>

    <span>arr</span> <span>=</span> <span>array</span><span>(</span><span>&#39;i&#39;</span><span>,</span> <span>[</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>])</span>
    <span>print</span><span>(</span><span>conn</span><span>.</span><span>recv_bytes_into</span><span>(</span><span>arr</span><span>))</span>    <span># =&gt; 8</span>
    <span>print</span><span>(</span><span>arr</span><span>)</span>                          <span># =&gt; array(&#39;i&#39;, [42, 1729, 0, 0, 0])</span>
</pre></div>
</div>
<p>The following code uses <a><code><span>wait()</span></code></a> to
wait for messages from multiple processes at once:</p>
<div><div><pre><span></span><span>import</span> <span>time</span><span>,</span> <span>random</span>
<span>from</span> <span>multiprocessing</span> <span>import</span> <span>Process</span><span>,</span> <span>Pipe</span><span>,</span> <span>current_process</span>
<span>from</span> <span>multiprocessing.connection</span> <span>import</span> <span>wait</span>

<span>def</span> <span>foo</span><span>(</span><span>w</span><span>):</span>
    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>10</span><span>):</span>
        <span>w</span><span>.</span><span>send</span><span>((</span><span>i</span><span>,</span> <span>current_process</span><span>()</span><span>.</span><span>name</span><span>))</span>
    <span>w</span><span>.</span><span>close</span><span>()</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#39;__main__&#39;</span><span>:</span>
    <span>readers</span> <span>=</span> <span>[]</span>

    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>4</span><span>):</span>
        <span>r</span><span>,</span> <span>w</span> <span>=</span> <span>Pipe</span><span>(</span><span>duplex</span><span>=</span><span>False</span><span>)</span>
        <span>readers</span><span>.</span><span>append</span><span>(</span><span>r</span><span>)</span>
        <span>p</span> <span>=</span> <span>Process</span><span>(</span><span>target</span><span>=</span><span>foo</span><span>,</span> <span>args</span><span>=</span><span>(</span><span>w</span><span>,))</span>
        <span>p</span><span>.</span><span>start</span><span>()</span>
        <span># We close the writable end of the pipe now to be sure that</span>
        <span># p is the only process which owns a handle for it.  This</span>
        <span># ensures that when p closes its handle for the writable end,</span>
        <span># wait() will promptly report the readable end as being ready.</span>
        <span>w</span><span>.</span><span>close</span><span>()</span>

    <span>while</span> <span>readers</span><span>:</span>
        <span>for</span> <span>r</span> <span>in</span> <span>wait</span><span>(</span><span>readers</span><span>):</span>
            <span>try</span><span>:</span>
                <span>msg</span> <span>=</span> <span>r</span><span>.</span><span>recv</span><span>()</span>
            <span>except</span> <span>EOFError</span><span>:</span>
                <span>readers</span><span>.</span><span>remove</span><span>(</span><span>r</span><span>)</span>
            <span>else</span><span>:</span>
                <span>print</span><span>(</span><span>msg</span><span>)</span>
</pre></div>
</div>
<div>
<span></span><h4>17.2.2.10.1. Address Formats<a>¶</a></h4>
<ul>
<li>An <code><span>'AF_INET'</span></code> address is a tuple of the form <code><span>(hostname,</span> <span>port)</span></code> where
<em>hostname</em> is a string and <em>port</em> is an integer.</li>
<li>An <code><span>'AF_UNIX'</span></code> address is a string representing a filename on the
filesystem.</li>
<li><dl>
<dt>An <code><span>'AF_PIPE'</span></code> address is a string of the form</dt>
<dd><code><span>r'\\.\pipe\</span><em><span>PipeName</span></em><span>'</span></code>.  To use <a><code><span>Client()</span></code></a> to connect to a named
pipe on a remote computer called <em>ServerName</em> one should use an address of the
form <code><span>r'\\</span><em><span>ServerName</span></em><span>\pipe\</span><em><span>PipeName</span></em><span>'</span></code> instead.</dd>
</dl>
</li>
</ul>
<p>Note that any string beginning with two backslashes is assumed by default to be
an <code><span>'AF_PIPE'</span></code> address rather than an <code><span>'AF_UNIX'</span></code> address.</p>
</div>
</div>
<div>
<span></span><h3>17.2.2.11. Authentication keys<a>¶</a></h3>
<p>When one uses <a><code><span>Connection.recv</span></code></a>, the
data received is automatically
unpickled. Unfortunately unpickling data from an untrusted source is a security
risk. Therefore <a><code><span>Listener</span></code></a> and <a><code><span>Client()</span></code></a> use the <a><code><span>hmac</span></code></a> module
to provide digest authentication.</p>
<p>An authentication key is a byte string which can be thought of as a
password: once a connection is established both ends will demand proof
that the other knows the authentication key.  (Demonstrating that both
ends are using the same key does <strong>not</strong> involve sending the key over
the connection.)</p>
<p>If authentication is requested but no authentication key is specified then the
return value of <code><span>current_process().authkey</span></code> is used (see
<a><code><span>Process</span></code></a>).  This value will be automatically inherited by
any <a><code><span>Process</span></code></a> object that the current process creates.
This means that (by default) all processes of a multi-process program will share
a single authentication key which can be used when setting up connections
between themselves.</p>
<p>Suitable authentication keys can also be generated by using <a><code><span>os.urandom()</span></code></a>.</p>
</div>
<div>
<h3>17.2.2.12. Logging<a>¶</a></h3>
<p>Some support for logging is available.  Note, however, that the <a><code><span>logging</span></code></a>
package does not use process shared locks so it is possible (depending on the
handler type) for messages from different processes to get mixed up.</p>
<dl>
<dt>
<code>multiprocessing.</code><code>get_logger</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>Returns the logger used by <a><code><span>multiprocessing</span></code></a>.  If necessary, a new one
will be created.</p>
<p>When first created the logger has level <code><span>logging.NOTSET</span></code> and no
default handler. Messages sent to this logger will not by default propagate
to the root logger.</p>
<p>Note that on Windows child processes will only inherit the level of the
parent process’s logger – any other customization of the logger will not be
inherited.</p>
</dd></dl>

<dl>
<dt>
<code>multiprocessing.</code><code>log_to_stderr</code><span>(</span><span>)</span><a>¶</a></dt>
<dd><p>This function performs a call to <a><code><span>get_logger()</span></code></a> but in addition to
returning the logger created by get_logger, it adds a handler which sends
output to <a><code><span>sys.stderr</span></code></a> using format
<code><span>'[%(levelname)s/%(processName)s]</span> <span>%(message)s'</span></code>.</p>
</dd></dl>

<p>Below is an example session with logging turned on:</p>
<div><div><pre><span></span><span>&gt;&gt;&gt; </span><span>import</span> <span>multiprocessing</span><span>,</span> <span>logging</span>
<span>&gt;&gt;&gt; </span><span>logger</span> <span>=</span> <span>multiprocessing</span><span>.</span><span>log_to_stderr</span><span>()</span>
<span>&gt;&gt;&gt; </span><span>logger</span><span>.</span><span>setLevel</span><span>(</span><span>logging</span><span>.</span><span>INFO</span><span>)</span>
<span>&gt;&gt;&gt; </span><span>logger</span><span>.</span><span>warning</span><span>(</span><span>&#39;doomed&#39;</span><span>)</span>
<span>[WARNING/MainProcess] doomed</span>
<span>&gt;&gt;&gt; </span><span>m</span> <span>=</span> <span>multiprocessing</span><span>.</span><span>Manager</span><span>()</span>
<span>[INFO/SyncManager-...] child process calling self.run()</span>
<span>[INFO/SyncManager-...] created temp directory /.../pymp-...</span>
<span>[INFO/SyncManager-...] manager serving at &#39;/.../listener-...&#39;</span>
<span>&gt;&gt;&gt; </span><span>del</span> <span>m</span>
<span>[INFO/MainProcess] sending shutdown message to manager</span>
<span>[INFO/SyncManager-...] manager exiting with exitcode 0</span>
</pre></div>
</div>
<p>For a full table of logging levels, see the <a><code><span>logging</span></code></a> module.</p>
</div>
<div>
<span></span><h3>17.2.2.13. The <a><code><span>multiprocessing.dummy</span></code></a> module<a>¶</a></h3>
<p><a><code><span>multiprocessing.dummy</span></code></a> replicates the API of <a><code><span>multiprocessing</span></code></a> but is
no more than a wrapper around the <a><code><span>threading</span></code></a> module.</p>
</div>
</div>
<div>
<span></span><h2>17.2.3. Programming guidelines<a>¶</a></h2>
<p>There are certain guidelines and idioms which should be adhered to when using
<a><code><span>multiprocessing</span></code></a>.</p>
<div>
<h3>17.2.3.1. All start methods<a>¶</a></h3>
<p>The following applies to all start methods.</p>
<p>Avoid shared state</p>
<blockquote>
<div><p>As far as possible one should try to avoid shifting large amounts of data
between processes.</p>
<p>It is probably best to stick to using queues or pipes for communication
between processes rather than using the lower level synchronization
primitives.</p>
</div></blockquote>
<p>Picklability</p>
<blockquote>
<div>Ensure that the arguments to the methods of proxies are picklable.</div></blockquote>
<p>Thread safety of proxies</p>
<blockquote>
<div><p>Do not use a proxy object from more than one thread unless you protect it
with a lock.</p>
<p>(There is never a problem with different processes using the <em>same</em> proxy.)</p>
</div></blockquote>
<p>Joining zombie processes</p>
<blockquote>
<div>On Unix when a process finishes but has not been joined it becomes a zombie.
There should never be very many because each time a new process starts (or
<a><code><span>active_children()</span></code></a> is called) all completed processes
which have not yet been joined will be joined.  Also calling a finished
process’s <a><code><span>Process.is_alive</span></code></a> will
join the process.  Even so it is probably good
practice to explicitly join all the processes that you start.</div></blockquote>
<p>Better to inherit than pickle/unpickle</p>
<blockquote>
<div>When using the <em>spawn</em> or <em>forkserver</em> start methods many types
from <a><code><span>multiprocessing</span></code></a> need to be picklable so that child
processes can use them.  However, one should generally avoid
sending shared objects to other processes using pipes or queues.
Instead you should arrange the program so that a process which
needs access to a shared resource created elsewhere can inherit it
from an ancestor process.</div></blockquote>
<p>Avoid terminating processes</p>
<blockquote>
<div><p>Using the <a><code><span>Process.terminate</span></code></a>
method to stop a process is liable to
cause any shared resources (such as locks, semaphores, pipes and queues)
currently being used by the process to become broken or unavailable to other
processes.</p>
<p>Therefore it is probably best to only consider using
<a><code><span>Process.terminate</span></code></a> on processes
which never use any shared resources.</p>
</div></blockquote>
<p>Joining processes that use queues</p>
<blockquote>
<div><p>Bear in mind that a process that has put items in a queue will wait before
terminating until all the buffered items are fed by the “feeder” thread to
the underlying pipe.  (The child process can call the
<a><code><span>Queue.cancel_join_thread</span></code></a>
method of the queue to avoid this behaviour.)</p>
<p>This means that whenever you use a queue you need to make sure that all
items which have been put on the queue will eventually be removed before the
process is joined.  Otherwise you cannot be sure that processes which have
put items on the queue will terminate.  Remember also that non-daemonic
processes will be joined automatically.</p>
<p>An example which will deadlock is the following:</p>
<div><div><pre><span></span><span>from</span> <span>multiprocessing</span> <span>import</span> <span>Process</span><span>,</span> <span>Queue</span>

<span>def</span> <span>f</span><span>(</span><span>q</span><span>):</span>
    <span>q</span><span>.</span><span>put</span><span>(</span><span>&#39;X&#39;</span> <span>*</span> <span>1000000</span><span>)</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#39;__main__&#39;</span><span>:</span>
    <span>queue</span> <span>=</span> <span>Queue</span><span>()</span>
    <span>p</span> <span>=</span> <span>Process</span><span>(</span><span>target</span><span>=</span><span>f</span><span>,</span> <span>args</span><span>=</span><span>(</span><span>queue</span><span>,))</span>
    <span>p</span><span>.</span><span>start</span><span>()</span>
    <span>p</span><span>.</span><span>join</span><span>()</span>                    <span># this deadlocks</span>
    <span>obj</span> <span>=</span> <span>queue</span><span>.</span><span>get</span><span>()</span>
</pre></div>
</div>
<p>A fix here would be to swap the last two lines (or simply remove the
<code><span>p.join()</span></code> line).</p>
</div></blockquote>
<p>Explicitly pass resources to child processes</p>
<blockquote>
<div><p>On Unix using the <em>fork</em> start method, a child process can make
use of a shared resource created in a parent process using a
global resource.  However, it is better to pass the object as an
argument to the constructor for the child process.</p>
<p>Apart from making the code (potentially) compatible with Windows
and the other start methods this also ensures that as long as the
child process is still alive the object will not be garbage
collected in the parent process.  This might be important if some
resource is freed when the object is garbage collected in the
parent process.</p>
<p>So for instance</p>
<div><div><pre><span></span><span>from</span> <span>multiprocessing</span> <span>import</span> <span>Process</span><span>,</span> <span>Lock</span>

<span>def</span> <span>f</span><span>():</span>
    <span>...</span> <span>do</span> <span>something</span> <span>using</span> <span>&quot;lock&quot;</span> <span>...</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#39;__main__&#39;</span><span>:</span>
    <span>lock</span> <span>=</span> <span>Lock</span><span>()</span>
    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>10</span><span>):</span>
        <span>Process</span><span>(</span><span>target</span><span>=</span><span>f</span><span>)</span><span>.</span><span>start</span><span>()</span>
</pre></div>
</div>
<p>should be rewritten as</p>
<div><div><pre><span></span><span>from</span> <span>multiprocessing</span> <span>import</span> <span>Process</span><span>,</span> <span>Lock</span>

<span>def</span> <span>f</span><span>(</span><span>l</span><span>):</span>
    <span>...</span> <span>do</span> <span>something</span> <span>using</span> <span>&quot;l&quot;</span> <span>...</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#39;__main__&#39;</span><span>:</span>
    <span>lock</span> <span>=</span> <span>Lock</span><span>()</span>
    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>10</span><span>):</span>
        <span>Process</span><span>(</span><span>target</span><span>=</span><span>f</span><span>,</span> <span>args</span><span>=</span><span>(</span><span>lock</span><span>,))</span><span>.</span><span>start</span><span>()</span>
</pre></div>
</div>
</div></blockquote>
<p>Beware of replacing <a><code><span>sys.stdin</span></code></a> with a “file like object”</p>
<blockquote>
<div><p><a><code><span>multiprocessing</span></code></a> originally unconditionally called:</p>
<div><div><pre><span></span><span>os</span><span>.</span><span>close</span><span>(</span><span>sys</span><span>.</span><span>stdin</span><span>.</span><span>fileno</span><span>())</span>
</pre></div>
</div>
<p>in the <code><span>multiprocessing.Process._bootstrap()</span></code> method — this resulted
in issues with processes-in-processes. This has been changed to:</p>
<div><div><pre><span></span><span>sys</span><span>.</span><span>stdin</span><span>.</span><span>close</span><span>()</span>
<span>sys</span><span>.</span><span>stdin</span> <span>=</span> <span>open</span><span>(</span><span>os</span><span>.</span><span>open</span><span>(</span><span>os</span><span>.</span><span>devnull</span><span>,</span> <span>os</span><span>.</span><span>O_RDONLY</span><span>),</span> <span>closefd</span><span>=</span><span>False</span><span>)</span>
</pre></div>
</div>
<p>Which solves the fundamental issue of processes colliding with each other
resulting in a bad file descriptor error, but introduces a potential danger
to applications which replace <a><code><span>sys.stdin()</span></code></a> with a “file-like object”
with output buffering.  This danger is that if multiple processes call
<a><code><span>close()</span></code></a> on this file-like object, it could result in the same
data being flushed to the object multiple times, resulting in corruption.</p>
<p>If you write a file-like object and implement your own caching, you can
make it fork-safe by storing the pid whenever you append to the cache,
and discarding the cache when the pid changes. For example:</p>
<div><div><pre><span></span><span>@property</span>
<span>def</span> <span>cache</span><span>(</span><span>self</span><span>):</span>
    <span>pid</span> <span>=</span> <span>os</span><span>.</span><span>getpid</span><span>()</span>
    <span>if</span> <span>pid</span> <span>!=</span> <span>self</span><span>.</span><span>_pid</span><span>:</span>
        <span>self</span><span>.</span><span>_pid</span> <span>=</span> <span>pid</span>
        <span>self</span><span>.</span><span>_cache</span> <span>=</span> <span>[]</span>
    <span>return</span> <span>self</span><span>.</span><span>_cache</span>
</pre></div>
</div>
<p>For more information, see <a>bpo-5155</a>, <a>bpo-5313</a> and <a>bpo-5331</a></p>
</div></blockquote>
</div>
<div>
<h3>17.2.3.2. The <em>spawn</em> and <em>forkserver</em> start methods<a>¶</a></h3>
<p>There are a few extra restriction which don’t apply to the <em>fork</em>
start method.</p>
<p>More picklability</p>
<blockquote>
<div>Ensure that all arguments to <code><span>Process.__init__()</span></code> are picklable.
Also, if you subclass <a><code><span>Process</span></code></a> then make sure that
instances will be picklable when the <a><code><span>Process.start</span></code></a> method is called.</div></blockquote>
<p>Global variables</p>
<blockquote>
<div><p>Bear in mind that if code run in a child process tries to access a global
variable, then the value it sees (if any) may not be the same as the value
in the parent process at the time that <a><code><span>Process.start</span></code></a> was called.</p>
<p>However, global variables which are just module level constants cause no
problems.</p>
</div></blockquote>
<p>Safe importing of main module</p>
<blockquote>
<div><p>Make sure that the main module can be safely imported by a new Python
interpreter without causing unintended side effects (such a starting a new
process).</p>
<p>For example, using the <em>spawn</em> or <em>forkserver</em> start method
running the following module would fail with a
<a><code><span>RuntimeError</span></code></a>:</p>
<div><div><pre><span></span><span>from</span> <span>multiprocessing</span> <span>import</span> <span>Process</span>

<span>def</span> <span>foo</span><span>():</span>
    <span>print</span><span>(</span><span>&#39;hello&#39;</span><span>)</span>

<span>p</span> <span>=</span> <span>Process</span><span>(</span><span>target</span><span>=</span><span>foo</span><span>)</span>
<span>p</span><span>.</span><span>start</span><span>()</span>
</pre></div>
</div>
<p>Instead one should protect the “entry point” of the program by using <code><span>if</span>
<span>__name__</span> <span>==</span> <span>'__main__':</span></code> as follows:</p>
<div><div><pre><span></span><span>from</span> <span>multiprocessing</span> <span>import</span> <span>Process</span><span>,</span> <span>freeze_support</span><span>,</span> <span>set_start_method</span>

<span>def</span> <span>foo</span><span>():</span>
    <span>print</span><span>(</span><span>&#39;hello&#39;</span><span>)</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#39;__main__&#39;</span><span>:</span>
    <span>freeze_support</span><span>()</span>
    <span>set_start_method</span><span>(</span><span>&#39;spawn&#39;</span><span>)</span>
    <span>p</span> <span>=</span> <span>Process</span><span>(</span><span>target</span><span>=</span><span>foo</span><span>)</span>
    <span>p</span><span>.</span><span>start</span><span>()</span>
</pre></div>
</div>
<p>(The <code><span>freeze_support()</span></code> line can be omitted if the program will be run
normally instead of frozen.)</p>
<p>This allows the newly spawned Python interpreter to safely import the module
and then run the module’s <code><span>foo()</span></code> function.</p>
<p>Similar restrictions apply if a pool or manager is created in the main
module.</p>
</div></blockquote>
</div>
</div>
<div>
<span></span><h2>17.2.4. Examples<a>¶</a></h2>
<p>Demonstration of how to create and use customized managers and proxies:</p>
<div><div><pre><span></span><span>from</span> <span>multiprocessing</span> <span>import</span> <span>freeze_support</span>
<span>from</span> <span>multiprocessing.managers</span> <span>import</span> <span>BaseManager</span><span>,</span> <span>BaseProxy</span>
<span>import</span> <span>operator</span>

<span>##</span>

<span>class</span> <span>Foo</span><span>:</span>
    <span>def</span> <span>f</span><span>(</span><span>self</span><span>):</span>
        <span>print</span><span>(</span><span>&#39;you called Foo.f()&#39;</span><span>)</span>
    <span>def</span> <span>g</span><span>(</span><span>self</span><span>):</span>
        <span>print</span><span>(</span><span>&#39;you called Foo.g()&#39;</span><span>)</span>
    <span>def</span> <span>_h</span><span>(</span><span>self</span><span>):</span>
        <span>print</span><span>(</span><span>&#39;you called Foo._h()&#39;</span><span>)</span>

<span># A simple generator function</span>
<span>def</span> <span>baz</span><span>():</span>
    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>10</span><span>):</span>
        <span>yield</span> <span>i</span><span>*</span><span>i</span>

<span># Proxy type for generator objects</span>
<span>class</span> <span>GeneratorProxy</span><span>(</span><span>BaseProxy</span><span>):</span>
    <span>_exposed_</span> <span>=</span> <span>[</span><span>&#39;__next__&#39;</span><span>]</span>
    <span>def</span> <span>__iter__</span><span>(</span><span>self</span><span>):</span>
        <span>return</span> <span>self</span>
    <span>def</span> <span>__next__</span><span>(</span><span>self</span><span>):</span>
        <span>return</span> <span>self</span><span>.</span><span>_callmethod</span><span>(</span><span>&#39;__next__&#39;</span><span>)</span>

<span># Function to return the operator module</span>
<span>def</span> <span>get_operator_module</span><span>():</span>
    <span>return</span> <span>operator</span>

<span>##</span>

<span>class</span> <span>MyManager</span><span>(</span><span>BaseManager</span><span>):</span>
    <span>pass</span>

<span># register the Foo class; make `f()` and `g()` accessible via proxy</span>
<span>MyManager</span><span>.</span><span>register</span><span>(</span><span>&#39;Foo1&#39;</span><span>,</span> <span>Foo</span><span>)</span>

<span># register the Foo class; make `g()` and `_h()` accessible via proxy</span>
<span>MyManager</span><span>.</span><span>register</span><span>(</span><span>&#39;Foo2&#39;</span><span>,</span> <span>Foo</span><span>,</span> <span>exposed</span><span>=</span><span>(</span><span>&#39;g&#39;</span><span>,</span> <span>&#39;_h&#39;</span><span>))</span>

<span># register the generator function baz; use `GeneratorProxy` to make proxies</span>
<span>MyManager</span><span>.</span><span>register</span><span>(</span><span>&#39;baz&#39;</span><span>,</span> <span>baz</span><span>,</span> <span>proxytype</span><span>=</span><span>GeneratorProxy</span><span>)</span>

<span># register get_operator_module(); make public functions accessible via proxy</span>
<span>MyManager</span><span>.</span><span>register</span><span>(</span><span>&#39;operator&#39;</span><span>,</span> <span>get_operator_module</span><span>)</span>

<span>##</span>

<span>def</span> <span>test</span><span>():</span>
    <span>manager</span> <span>=</span> <span>MyManager</span><span>()</span>
    <span>manager</span><span>.</span><span>start</span><span>()</span>

    <span>print</span><span>(</span><span>&#39;-&#39;</span> <span>*</span> <span>20</span><span>)</span>

    <span>f1</span> <span>=</span> <span>manager</span><span>.</span><span>Foo1</span><span>()</span>
    <span>f1</span><span>.</span><span>f</span><span>()</span>
    <span>f1</span><span>.</span><span>g</span><span>()</span>
    <span>assert</span> <span>not</span> <span>hasattr</span><span>(</span><span>f1</span><span>,</span> <span>&#39;_h&#39;</span><span>)</span>
    <span>assert</span> <span>sorted</span><span>(</span><span>f1</span><span>.</span><span>_exposed_</span><span>)</span> <span>==</span> <span>sorted</span><span>([</span><span>&#39;f&#39;</span><span>,</span> <span>&#39;g&#39;</span><span>])</span>

    <span>print</span><span>(</span><span>&#39;-&#39;</span> <span>*</span> <span>20</span><span>)</span>

    <span>f2</span> <span>=</span> <span>manager</span><span>.</span><span>Foo2</span><span>()</span>
    <span>f2</span><span>.</span><span>g</span><span>()</span>
    <span>f2</span><span>.</span><span>_h</span><span>()</span>
    <span>assert</span> <span>not</span> <span>hasattr</span><span>(</span><span>f2</span><span>,</span> <span>&#39;f&#39;</span><span>)</span>
    <span>assert</span> <span>sorted</span><span>(</span><span>f2</span><span>.</span><span>_exposed_</span><span>)</span> <span>==</span> <span>sorted</span><span>([</span><span>&#39;g&#39;</span><span>,</span> <span>&#39;_h&#39;</span><span>])</span>

    <span>print</span><span>(</span><span>&#39;-&#39;</span> <span>*</span> <span>20</span><span>)</span>

    <span>it</span> <span>=</span> <span>manager</span><span>.</span><span>baz</span><span>()</span>
    <span>for</span> <span>i</span> <span>in</span> <span>it</span><span>:</span>
        <span>print</span><span>(</span><span>&#39;&lt;</span><span>%d</span><span>&gt;&#39;</span> <span>%</span> <span>i</span><span>,</span> <span>end</span><span>=</span><span>&#39; &#39;</span><span>)</span>
    <span>print</span><span>()</span>

    <span>print</span><span>(</span><span>&#39;-&#39;</span> <span>*</span> <span>20</span><span>)</span>

    <span>op</span> <span>=</span> <span>manager</span><span>.</span><span>operator</span><span>()</span>
    <span>print</span><span>(</span><span>&#39;op.add(23, 45) =&#39;</span><span>,</span> <span>op</span><span>.</span><span>add</span><span>(</span><span>23</span><span>,</span> <span>45</span><span>))</span>
    <span>print</span><span>(</span><span>&#39;op.pow(2, 94) =&#39;</span><span>,</span> <span>op</span><span>.</span><span>pow</span><span>(</span><span>2</span><span>,</span> <span>94</span><span>))</span>
    <span>print</span><span>(</span><span>&#39;op._exposed_ =&#39;</span><span>,</span> <span>op</span><span>.</span><span>_exposed_</span><span>)</span>

<span>##</span>

<span>if</span> <span>__name__</span> <span>==</span> <span>&#39;__main__&#39;</span><span>:</span>
    <span>freeze_support</span><span>()</span>
    <span>test</span><span>()</span>
</pre></div>
</div>
<p>Using <a><code><span>Pool</span></code></a>:</p>
<div><div><pre><span></span><span>import</span> <span>multiprocessing</span>
<span>import</span> <span>time</span>
<span>import</span> <span>random</span>
<span>import</span> <span>sys</span>

<span>#</span>
<span># Functions used by test code</span>
<span>#</span>

<span>def</span> <span>calculate</span><span>(</span><span>func</span><span>,</span> <span>args</span><span>):</span>
    <span>result</span> <span>=</span> <span>func</span><span>(</span><span>*</span><span>args</span><span>)</span>
    <span>return</span> <span>&#39;</span><span>%s</span><span> says that </span><span>%s%s</span><span> = </span><span>%s</span><span>&#39;</span> <span>%</span> <span>(</span>
        <span>multiprocessing</span><span>.</span><span>current_process</span><span>()</span><span>.</span><span>name</span><span>,</span>
        <span>func</span><span>.</span><span>__name__</span><span>,</span> <span>args</span><span>,</span> <span>result</span>
        <span>)</span>

<span>def</span> <span>calculatestar</span><span>(</span><span>args</span><span>):</span>
    <span>return</span> <span>calculate</span><span>(</span><span>*</span><span>args</span><span>)</span>

<span>def</span> <span>mul</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>):</span>
    <span>time</span><span>.</span><span>sleep</span><span>(</span><span>0.5</span> <span>*</span> <span>random</span><span>.</span><span>random</span><span>())</span>
    <span>return</span> <span>a</span> <span>*</span> <span>b</span>

<span>def</span> <span>plus</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>):</span>
    <span>time</span><span>.</span><span>sleep</span><span>(</span><span>0.5</span> <span>*</span> <span>random</span><span>.</span><span>random</span><span>())</span>
    <span>return</span> <span>a</span> <span>+</span> <span>b</span>

<span>def</span> <span>f</span><span>(</span><span>x</span><span>):</span>
    <span>return</span> <span>1.0</span> <span>/</span> <span>(</span><span>x</span> <span>-</span> <span>5.0</span><span>)</span>

<span>def</span> <span>pow3</span><span>(</span><span>x</span><span>):</span>
    <span>return</span> <span>x</span> <span>**</span> <span>3</span>

<span>def</span> <span>noop</span><span>(</span><span>x</span><span>):</span>
    <span>pass</span>

<span>#</span>
<span># Test code</span>
<span>#</span>

<span>def</span> <span>test</span><span>():</span>
    <span>PROCESSES</span> <span>=</span> <span>4</span>
    <span>print</span><span>(</span><span>&#39;Creating pool with </span><span>%d</span><span> processes</span><span>\n</span><span>&#39;</span> <span>%</span> <span>PROCESSES</span><span>)</span>

    <span>with</span> <span>multiprocessing</span><span>.</span><span>Pool</span><span>(</span><span>PROCESSES</span><span>)</span> <span>as</span> <span>pool</span><span>:</span>
        <span>#</span>
        <span># Tests</span>
        <span>#</span>

        <span>TASKS</span> <span>=</span> <span>[(</span><span>mul</span><span>,</span> <span>(</span><span>i</span><span>,</span> <span>7</span><span>))</span> <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>10</span><span>)]</span> <span>+</span> \
                <span>[(</span><span>plus</span><span>,</span> <span>(</span><span>i</span><span>,</span> <span>8</span><span>))</span> <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>10</span><span>)]</span>

        <span>results</span> <span>=</span> <span>[</span><span>pool</span><span>.</span><span>apply_async</span><span>(</span><span>calculate</span><span>,</span> <span>t</span><span>)</span> <span>for</span> <span>t</span> <span>in</span> <span>TASKS</span><span>]</span>
        <span>imap_it</span> <span>=</span> <span>pool</span><span>.</span><span>imap</span><span>(</span><span>calculatestar</span><span>,</span> <span>TASKS</span><span>)</span>
        <span>imap_unordered_it</span> <span>=</span> <span>pool</span><span>.</span><span>imap_unordered</span><span>(</span><span>calculatestar</span><span>,</span> <span>TASKS</span><span>)</span>

        <span>print</span><span>(</span><span>&#39;Ordered results using pool.apply_async():&#39;</span><span>)</span>
        <span>for</span> <span>r</span> <span>in</span> <span>results</span><span>:</span>
            <span>print</span><span>(</span><span>&#39;</span><span>\t</span><span>&#39;</span><span>,</span> <span>r</span><span>.</span><span>get</span><span>())</span>
        <span>print</span><span>()</span>

        <span>print</span><span>(</span><span>&#39;Ordered results using pool.imap():&#39;</span><span>)</span>
        <span>for</span> <span>x</span> <span>in</span> <span>imap_it</span><span>:</span>
            <span>print</span><span>(</span><span>&#39;</span><span>\t</span><span>&#39;</span><span>,</span> <span>x</span><span>)</span>
        <span>print</span><span>()</span>

        <span>print</span><span>(</span><span>&#39;Unordered results using pool.imap_unordered():&#39;</span><span>)</span>
        <span>for</span> <span>x</span> <span>in</span> <span>imap_unordered_it</span><span>:</span>
            <span>print</span><span>(</span><span>&#39;</span><span>\t</span><span>&#39;</span><span>,</span> <span>x</span><span>)</span>
        <span>print</span><span>()</span>

        <span>print</span><span>(</span><span>&#39;Ordered results using pool.map() --- will block till complete:&#39;</span><span>)</span>
        <span>for</span> <span>x</span> <span>in</span> <span>pool</span><span>.</span><span>map</span><span>(</span><span>calculatestar</span><span>,</span> <span>TASKS</span><span>):</span>
            <span>print</span><span>(</span><span>&#39;</span><span>\t</span><span>&#39;</span><span>,</span> <span>x</span><span>)</span>
        <span>print</span><span>()</span>

        <span>#</span>
        <span># Test error handling</span>
        <span>#</span>

        <span>print</span><span>(</span><span>&#39;Testing error handling:&#39;</span><span>)</span>

        <span>try</span><span>:</span>
            <span>print</span><span>(</span><span>pool</span><span>.</span><span>apply</span><span>(</span><span>f</span><span>,</span> <span>(</span><span>5</span><span>,)))</span>
        <span>except</span> <span>ZeroDivisionError</span><span>:</span>
            <span>print</span><span>(</span><span>&#39;</span><span>\t</span><span>Got ZeroDivisionError as expected from pool.apply()&#39;</span><span>)</span>
        <span>else</span><span>:</span>
            <span>raise</span> <span>AssertionError</span><span>(</span><span>&#39;expected ZeroDivisionError&#39;</span><span>)</span>

        <span>try</span><span>:</span>
            <span>print</span><span>(</span><span>pool</span><span>.</span><span>map</span><span>(</span><span>f</span><span>,</span> <span>list</span><span>(</span><span>range</span><span>(</span><span>10</span><span>))))</span>
        <span>except</span> <span>ZeroDivisionError</span><span>:</span>
            <span>print</span><span>(</span><span>&#39;</span><span>\t</span><span>Got ZeroDivisionError as expected from pool.map()&#39;</span><span>)</span>
        <span>else</span><span>:</span>
            <span>raise</span> <span>AssertionError</span><span>(</span><span>&#39;expected ZeroDivisionError&#39;</span><span>)</span>

        <span>try</span><span>:</span>
            <span>print</span><span>(</span><span>list</span><span>(</span><span>pool</span><span>.</span><span>imap</span><span>(</span><span>f</span><span>,</span> <span>list</span><span>(</span><span>range</span><span>(</span><span>10</span><span>)))))</span>
        <span>except</span> <span>ZeroDivisionError</span><span>:</span>
            <span>print</span><span>(</span><span>&#39;</span><span>\t</span><span>Got ZeroDivisionError as expected from list(pool.imap())&#39;</span><span>)</span>
        <span>else</span><span>:</span>
            <span>raise</span> <span>AssertionError</span><span>(</span><span>&#39;expected ZeroDivisionError&#39;</span><span>)</span>

        <span>it</span> <span>=</span> <span>pool</span><span>.</span><span>imap</span><span>(</span><span>f</span><span>,</span> <span>list</span><span>(</span><span>range</span><span>(</span><span>10</span><span>)))</span>
        <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>10</span><span>):</span>
            <span>try</span><span>:</span>
                <span>x</span> <span>=</span> <span>next</span><span>(</span><span>it</span><span>)</span>
            <span>except</span> <span>ZeroDivisionError</span><span>:</span>
                <span>if</span> <span>i</span> <span>==</span> <span>5</span><span>:</span>
                    <span>pass</span>
            <span>except</span> <span>StopIteration</span><span>:</span>
                <span>break</span>
            <span>else</span><span>:</span>
                <span>if</span> <span>i</span> <span>==</span> <span>5</span><span>:</span>
                    <span>raise</span> <span>AssertionError</span><span>(</span><span>&#39;expected ZeroDivisionError&#39;</span><span>)</span>

        <span>assert</span> <span>i</span> <span>==</span> <span>9</span>
        <span>print</span><span>(</span><span>&#39;</span><span>\t</span><span>Got ZeroDivisionError as expected from IMapIterator.next()&#39;</span><span>)</span>
        <span>print</span><span>()</span>

        <span>#</span>
        <span># Testing timeouts</span>
        <span>#</span>

        <span>print</span><span>(</span><span>&#39;Testing ApplyResult.get() with timeout:&#39;</span><span>,</span> <span>end</span><span>=</span><span>&#39; &#39;</span><span>)</span>
        <span>res</span> <span>=</span> <span>pool</span><span>.</span><span>apply_async</span><span>(</span><span>calculate</span><span>,</span> <span>TASKS</span><span>[</span><span>0</span><span>])</span>
        <span>while</span> <span>1</span><span>:</span>
            <span>sys</span><span>.</span><span>stdout</span><span>.</span><span>flush</span><span>()</span>
            <span>try</span><span>:</span>
                <span>sys</span><span>.</span><span>stdout</span><span>.</span><span>write</span><span>(</span><span>&#39;</span><span>\n\t</span><span>%s</span><span>&#39;</span> <span>%</span> <span>res</span><span>.</span><span>get</span><span>(</span><span>0.02</span><span>))</span>
                <span>break</span>
            <span>except</span> <span>multiprocessing</span><span>.</span><span>TimeoutError</span><span>:</span>
                <span>sys</span><span>.</span><span>stdout</span><span>.</span><span>write</span><span>(</span><span>&#39;.&#39;</span><span>)</span>
        <span>print</span><span>()</span>
        <span>print</span><span>()</span>

        <span>print</span><span>(</span><span>&#39;Testing IMapIterator.next() with timeout:&#39;</span><span>,</span> <span>end</span><span>=</span><span>&#39; &#39;</span><span>)</span>
        <span>it</span> <span>=</span> <span>pool</span><span>.</span><span>imap</span><span>(</span><span>calculatestar</span><span>,</span> <span>TASKS</span><span>)</span>
        <span>while</span> <span>1</span><span>:</span>
            <span>sys</span><span>.</span><span>stdout</span><span>.</span><span>flush</span><span>()</span>
            <span>try</span><span>:</span>
                <span>sys</span><span>.</span><span>stdout</span><span>.</span><span>write</span><span>(</span><span>&#39;</span><span>\n\t</span><span>%s</span><span>&#39;</span> <span>%</span> <span>it</span><span>.</span><span>next</span><span>(</span><span>0.02</span><span>))</span>
            <span>except</span> <span>StopIteration</span><span>:</span>
                <span>break</span>
            <span>except</span> <span>multiprocessing</span><span>.</span><span>TimeoutError</span><span>:</span>
                <span>sys</span><span>.</span><span>stdout</span><span>.</span><span>write</span><span>(</span><span>&#39;.&#39;</span><span>)</span>
        <span>print</span><span>()</span>
        <span>print</span><span>()</span>


<span>if</span> <span>__name__</span> <span>==</span> <span>&#39;__main__&#39;</span><span>:</span>
    <span>multiprocessing</span><span>.</span><span>freeze_support</span><span>()</span>
    <span>test</span><span>()</span>
</pre></div>
</div>
<p>An example showing how to use queues to feed tasks to a collection of worker
processes and collect the results:</p>
<div><div><pre><span></span><span>import</span> <span>time</span>
<span>import</span> <span>random</span>

<span>from</span> <span>multiprocessing</span> <span>import</span> <span>Process</span><span>,</span> <span>Queue</span><span>,</span> <span>current_process</span><span>,</span> <span>freeze_support</span>

<span>#</span>
<span># Function run by worker processes</span>
<span>#</span>

<span>def</span> <span>worker</span><span>(</span><span>input</span><span>,</span> <span>output</span><span>):</span>
    <span>for</span> <span>func</span><span>,</span> <span>args</span> <span>in</span> <span>iter</span><span>(</span><span>input</span><span>.</span><span>get</span><span>,</span> <span>&#39;STOP&#39;</span><span>):</span>
        <span>result</span> <span>=</span> <span>calculate</span><span>(</span><span>func</span><span>,</span> <span>args</span><span>)</span>
        <span>output</span><span>.</span><span>put</span><span>(</span><span>result</span><span>)</span>

<span>#</span>
<span># Function used to calculate result</span>
<span>#</span>

<span>def</span> <span>calculate</span><span>(</span><span>func</span><span>,</span> <span>args</span><span>):</span>
    <span>result</span> <span>=</span> <span>func</span><span>(</span><span>*</span><span>args</span><span>)</span>
    <span>return</span> <span>&#39;</span><span>%s</span><span> says that </span><span>%s%s</span><span> = </span><span>%s</span><span>&#39;</span> <span>%</span> \
        <span>(</span><span>current_process</span><span>()</span><span>.</span><span>name</span><span>,</span> <span>func</span><span>.</span><span>__name__</span><span>,</span> <span>args</span><span>,</span> <span>result</span><span>)</span>

<span>#</span>
<span># Functions referenced by tasks</span>
<span>#</span>

<span>def</span> <span>mul</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>):</span>
    <span>time</span><span>.</span><span>sleep</span><span>(</span><span>0.5</span><span>*</span><span>random</span><span>.</span><span>random</span><span>())</span>
    <span>return</span> <span>a</span> <span>*</span> <span>b</span>

<span>def</span> <span>plus</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>):</span>
    <span>time</span><span>.</span><span>sleep</span><span>(</span><span>0.5</span><span>*</span><span>random</span><span>.</span><span>random</span><span>())</span>
    <span>return</span> <span>a</span> <span>+</span> <span>b</span>

<span>#</span>
<span>#</span>
<span>#</span>

<span>def</span> <span>test</span><span>():</span>
    <span>NUMBER_OF_PROCESSES</span> <span>=</span> <span>4</span>
    <span>TASKS1</span> <span>=</span> <span>[(</span><span>mul</span><span>,</span> <span>(</span><span>i</span><span>,</span> <span>7</span><span>))</span> <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>20</span><span>)]</span>
    <span>TASKS2</span> <span>=</span> <span>[(</span><span>plus</span><span>,</span> <span>(</span><span>i</span><span>,</span> <span>8</span><span>))</span> <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>10</span><span>)]</span>

    <span># Create queues</span>
    <span>task_queue</span> <span>=</span> <span>Queue</span><span>()</span>
    <span>done_queue</span> <span>=</span> <span>Queue</span><span>()</span>

    <span># Submit tasks</span>
    <span>for</span> <span>task</span> <span>in</span> <span>TASKS1</span><span>:</span>
        <span>task_queue</span><span>.</span><span>put</span><span>(</span><span>task</span><span>)</span>

    <span># Start worker processes</span>
    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>NUMBER_OF_PROCESSES</span><span>):</span>
        <span>Process</span><span>(</span><span>target</span><span>=</span><span>worker</span><span>,</span> <span>args</span><span>=</span><span>(</span><span>task_queue</span><span>,</span> <span>done_queue</span><span>))</span><span>.</span><span>start</span><span>()</span>

    <span># Get and print results</span>
    <span>print</span><span>(</span><span>&#39;Unordered results:&#39;</span><span>)</span>
    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>len</span><span>(</span><span>TASKS1</span><span>)):</span>
        <span>print</span><span>(</span><span>&#39;</span><span>\t</span><span>&#39;</span><span>,</span> <span>done_queue</span><span>.</span><span>get</span><span>())</span>

    <span># Add more tasks using `put()`</span>
    <span>for</span> <span>task</span> <span>in</span> <span>TASKS2</span><span>:</span>
        <span>task_queue</span><span>.</span><span>put</span><span>(</span><span>task</span><span>)</span>

    <span># Get and print some more results</span>
    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>len</span><span>(</span><span>TASKS2</span><span>)):</span>
        <span>print</span><span>(</span><span>&#39;</span><span>\t</span><span>&#39;</span><span>,</span> <span>done_queue</span><span>.</span><span>get</span><span>())</span>

    <span># Tell child processes to stop</span>
    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>NUMBER_OF_PROCESSES</span><span>):</span>
        <span>task_queue</span><span>.</span><span>put</span><span>(</span><span>&#39;STOP&#39;</span><span>)</span>


<span>if</span> <span>__name__</span> <span>==</span> <span>&#39;__main__&#39;</span><span>:</span>
    <span>freeze_support</span><span>()</span>
    <span>test</span><span>()</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div>
        <div>
  <h3><a>Table Of Contents</a></h3>
  <ul>
<li><a>17.2. <code><span>multiprocessing</span></code> — Process-based parallelism</a><ul>
<li><a>17.2.1. Introduction</a><ul>
<li><a>17.2.1.1. The <code><span>Process</span></code> class</a></li>
<li><a>17.2.1.2. Contexts and start methods</a></li>
<li><a>17.2.1.3. Exchanging objects between processes</a></li>
<li><a>17.2.1.4. Synchronization between processes</a></li>
<li><a>17.2.1.5. Sharing state between processes</a></li>
<li><a>17.2.1.6. Using a pool of workers</a></li>
</ul>
</li>
<li><a>17.2.2. Reference</a><ul>
<li><a>17.2.2.1. <code><span>Process</span></code> and exceptions</a></li>
<li><a>17.2.2.2. Pipes and Queues</a></li>
<li><a>17.2.2.3. Miscellaneous</a></li>
<li><a>17.2.2.4. Connection Objects</a></li>
<li><a>17.2.2.5. Synchronization primitives</a></li>
<li><a>17.2.2.6. Shared <code><span>ctypes</span></code> Objects</a><ul>
<li><a>17.2.2.6.1. The <code><span>multiprocessing.sharedctypes</span></code> module</a></li>
</ul>
</li>
<li><a>17.2.2.7. Managers</a><ul>
<li><a>17.2.2.7.1. Customized managers</a></li>
<li><a>17.2.2.7.2. Using a remote manager</a></li>
</ul>
</li>
<li><a>17.2.2.8. Proxy Objects</a><ul>
<li><a>17.2.2.8.1. Cleanup</a></li>
</ul>
</li>
<li><a>17.2.2.9. Process Pools</a></li>
<li><a>17.2.2.10. Listeners and Clients</a><ul>
<li><a>17.2.2.10.1. Address Formats</a></li>
</ul>
</li>
<li><a>17.2.2.11. Authentication keys</a></li>
<li><a>17.2.2.12. Logging</a></li>
<li><a>17.2.2.13. The <code><span>multiprocessing.dummy</span></code> module</a></li>
</ul>
</li>
<li><a>17.2.3. Programming guidelines</a><ul>
<li><a>17.2.3.1. All start methods</a></li>
<li><a>17.2.3.2. The <em>spawn</em> and <em>forkserver</em> start methods</a></li>
</ul>
</li>
<li><a>17.2.4. Examples</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p><a href="threading.html"
           >17.1. <code><span>threading</span></code> — Thread-based parallelism</a></p>
  <h4>Next topic</h4>
  <p><a href="concurrent.html"
           >17.3. The <code><span>concurrent</span></code> package</a></p>
  <div>
    <h3>This Page</h3>
    <ul>
      <li><a>Report a Bug</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/3.6/Doc/library/multiprocessing.rst"
>Show Source
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div></div>
    </div>  
    <div>
      <h3>Navigation</h3>
      <ul>
        <li>
          <a href="../genindex.html" title="General Index"
>index</a></li>
        <li>
          <a href="../py-modindex.html" title="Python Module Index"
>modules</a> |</li>
        <li>
          <a href="concurrent.html" title="17.3. The concurrent package"
>next</a> |</li>
        <li>
          <a href="threading.html" title="17.1. threading — Thread-based parallelism"
>previous</a> |</li>
        <li><img src="../_static/py.png" alt=""
      ></li>
        <li><a>Python</a> &#187;</li>
        <li>
          <span>en</span>
          <span>3.6.5</span>
          <a>Documentation </a> &#187;
        </li>

          <li><a>The Python Standard Library</a> &#187;</li>
          <li><a>17. Concurrent Execution</a> &#187;</li>
    <li>
        

    <div>
        <form>
          <input>
          <input>
          <input>
          <input>
        </form>
    </div>
    <script>$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div>
    &copy; <a>Copyright</a> 2001-2018, Python Software Foundation.
    <br>
    The Python Software Foundation is a non-profit corporation.
    <a>Please donate.</a>
    <br>
    Last updated on May 20, 2018.
    <a>Found a bug</a>?
    <br>
    Created using <a>Sphinx</a> 1.7.4.
    </div>

  </body>
</html>